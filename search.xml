<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[基于 EventEmitter 的双向数据 pipeline 实现]]></title>
    <url>%2F2018%2F04%2F14%2Fimplement-eventemitter-pipline%2F</url>
    <content type="text"><![CDATA[基于 EventEmitter 的双向数据 pipeline 实现想法来源GulpGulp 是前端工具链中常用的流式任务执行器，适用于许多小型库的编译打包任务。它的设计思想其实很像 Linux 命令行里面的 Pipe（管道）：12345gulp.src(paths.scripts.src, &#123; sourcemaps: true &#125;) .pipe(babel()) .pipe(uglify()) .pipe(concat('main.min.js')) .pipe(gulp.dest(paths.scripts.dest)); gulp 是单向的，即对于同一个 pipeline，数据一般不能被逆向还原。 TCP/IP stack我们知道，计算机网络协议是分层设计的，每层分别为数据赋予不同的含义、完成不同的使命。源主机采用网络协议栈将原始二进制流 层层编码（encode） 后送往目的主机，目的主机采用同样的协议栈将数据 层层解码（decode） 后得到原始数据。典型的 HTTP 协议将请求数据通过 TCP/IP 协议栈自上而下编码后送出，之后自下而上解码后得到响应数据： 123456789101112131415 +---------+ | &quot;Hello&quot; | +---------+ +-------------+---------+ | HTTP header | PAYLOAD | +-------------+---------+ +------------+-----------------------+ | TCP header | PAYLOAD | +------------+-----------------------+ +------------+------------------------------------+ | IP header | PAYLOAD | +------------+------------------------------------++------------+--------------------------------------------------+| Eth header | PAYLOAD |+------------+--------------------------------------------------+ TCP/IP 协议栈是双向的，即对于同一套协议，数据既可以被编码也可以被解码。 那么问题来了，是否可以抽象一种轻量的 Pipeline，实现类似网络协议栈双向数据流的处理能力，并且能够让用户定制化每层的处理逻辑？ 数据流设计之前，先根据数据流划分功能模块，这里 PIPE 是数据和各个数据处理单元的调度者，PIPE_UNIT_x 是每层数据的处理单元，可以有多个，并且按顺序前后串联。 123 +------------------ PIPE -------------------+[RAW_DATA] &lt;==&gt; | [PIPE_UNIT_1] &lt;==&gt; ... &lt;==&gt; [PIPE_UNIT_2] | &lt;==&gt; [ENCODED_DATA] +-------------------------------------------+ 用户可以实现自己的 PIPE_UNIT 来达到定制化处理逻辑的功能，也可以任意调换 PIPE_UNIT 的顺序来达到不同的处理效果。 Pipe 设计Pipe 需要提供一个数据入口来启动链式处理流程： 12345678910111213141516171819202122232425262728293031323334353637const EventEmitter = require('events');const PIPE_TYPE_ENCODE = 'PIPE_TYPE_ENCODE';const PIPE_TYPE_DECODE = 'PIPE_TYPE_DECODE';class Pipe extends EventEmitter &#123; // 构造 Pipe 时，传入的处理单元数组约定为 encode 顺序 constructor(units) &#123; super(); this._encode_units = units; this._decode_units = [].concat(units).reverse(); &#125; // 数据处理入口 feed(type, data) &#123; const units = type === PIPE_TYPE_ENCODE ? this._encode_units : this._decode_units; if (units.length &lt; 1) &#123; return; &#125; const first = units[0]; if (first.listenerCount(type) &lt; 1) &#123; // 构建链式响应逻辑 const last = units.reduce((prev, next) =&gt; &#123; prev.on(type, (dt) =&gt; next._write(type, dt)); return next; &#125;); last.on(type, (dt) =&gt; &#123; // 最后一个 unit 完成之后 feed 的任务就结束了 this.emit(type, dt); &#125;); &#125; // 触发处理流程 first._write(type, data); &#125;&#125; PipeUnit 接口设计PipeUnit 需要暴露编码（encode）和解码（decode）两个接口，考虑到处理单元可能异步执行，因此使用 async 黑膜法： 123456789101112131415161718192021class PipeUnit extends EventEmitter &#123; async _write(type, data) &#123; if (type === PIPE_TYPE_ENCODE) &#123; this.emit(type, await this.encode(data)); &#125; else &#123; this.emit(type, await this.decode(data)); &#125; &#125; // 编码接口 async encode(data) &#123; return data; &#125; // 解码接口 async decode(data) &#123; return data; &#125;&#125; 实现 PipeUnit首先实现一个提供压缩、解压缩功能的 PipeUnit： 12345678910111213141516171819202122232425262728293031const zlib = require('zlib');class ZipPipeUnit extends PipeUnit &#123; async encode(data) &#123; console.log('ZipPipeUnit::encode &lt;-', data); return new Promise((resolve, reject) =&gt; &#123; zlib.deflate(data, (err, buffer) =&gt; &#123; if (err) &#123; reject(err); &#125; else &#123; resolve(buffer); &#125; &#125;); &#125;); &#125; async decode(data) &#123; console.log('ZipPipeUnit::decode &lt;-', data); return new Promise((resolve, reject) =&gt; &#123; zlib.unzip(data, (err, buffer) =&gt; &#123; if (err) &#123; reject(err); &#125; else &#123; resolve(buffer); &#125; &#125;); &#125;); &#125;&#125; 下面再实现一个提供 AES 对称加解密功能的 PipeUnit，这次采用同步执行： 123456789101112131415161718192021const crypto = require('crypto');class CryptoPipeUnit extends PipeUnit &#123; // 编码实现 encode(plaintext) &#123; console.log('CryptoPipeUnit::encode &lt;-', plaintext); const cipher = crypto.createCipher('aes192', 'a password'); const encrypted = cipher.update(plaintext); return Buffer.concat([encrypted, cipher.final()]); &#125; // 解码实现 decode(ciphertext) &#123; console.log('CryptoPipeUnit::decode &lt;-', ciphertext); const decipher = crypto.createDecipher('aes192', 'a password'); const decrypted = decipher.update(ciphertext); return Buffer.concat([decrypted, decipher.final()]); &#125;&#125; 实际运行1234567891011121314151617181920212223242526272829// 自由组合处理单元const units = [ new ZipPipeUnit(), new CryptoPipeUnit(), // new CryptoPipeUnit(), // 再来一个也可以];// 来一个 pipe 对象const pipe = new Pipe(units);pipe.on(PIPE_TYPE_ENCODE, (data) =&gt; &#123; console.log('encoded:', data); console.log(''); // 解码 pipe.feed(PIPE_TYPE_DECODE, data);&#125;);pipe.on(PIPE_TYPE_DECODE, (data) =&gt; console.log('decoded:', data.toString()));// 编码pipe.feed(PIPE_TYPE_ENCODE, Buffer.from('awesome nodejs'));// 输出如下:// ZipPipeUnit::encode &lt;- &lt;Buffer 61 77 65 73 6f 6d 65 20 6e 6f 64 65 6a 73&gt;// CryptoPipeUnit::encode &lt;- &lt;Buffer 78 9c 4b 2c 4f 2d ce cf 4d 55 c8 cb 4f 49 cd 2a 06 00 2a 0c 05 95&gt;// encoded: &lt;Buffer a9 61 bc 37 1a 4c 41 e8 20 63 d2 90 86 94 7b 48 98 b1 91 16 84 66 58 9b 6d 88 53 da 9b b9 18 fb&gt;// CryptoPipeUnit::decode &lt;- &lt;Buffer a9 61 bc 37 1a 4c 41 e8 20 63 d2 90 86 94 7b 48 98 b1 91 16 84 66 58 9b 6d 88 53 da 9b b9 18 fb&gt;// ZipPipeUnit::decode &lt;- &lt;Buffer 78 9c 4b 2c 4f 2d ce cf 4d 55 c8 cb 4f 49 cd 2a 06 00 2a 0c 05 95&gt;// decoded: awesome nodejs 可以看到，通过对 EventEmitter 简单的封装就可以实现双向数据 pipeline，同时支持异步单元操作。 性能测试功能实现了，性能又如何呢？抛开 PipeUnit 的业务实现，简单分析一下链式 EventEmitter 结构的性能影响因素，理论上很大程度取决于 EventEmitter 本身的性能，Pipe::feed 只在第一次被调用时构建响应链，之后的调用几乎不会有性能损失。 测试用例Node.js 版本如下： 123456789101112131415&gt; process.versions&#123; http_parser: &apos;2.8.0&apos;, node: &apos;9.11.1&apos;, v8: &apos;6.2.414.46-node.23&apos;, uv: &apos;1.19.2&apos;, zlib: &apos;1.2.11&apos;, ares: &apos;1.13.0&apos;, modules: &apos;59&apos;, nghttp2: &apos;1.29.0&apos;, napi: &apos;3&apos;, openssl: &apos;1.0.2o&apos;, icu: &apos;61.1&apos;, unicode: &apos;10.0&apos;, cldr: &apos;33.0&apos;, tz: &apos;2018c&apos; &#125; 下面分别考察 0 ~ 30000（每次递增 1000） 个 PipeUnit 实例的执行时间，来评估上述设计的性能表现： 12345678910111213141516171819202122232425const &#123; performance &#125; = require('perf_hooks');const payload = Buffer.alloc(4096);for (let i = 0; i &lt;= 30; i++) &#123; const units = Array(i * 1000).fill().map(() =&gt; new PipeUnit()); performance.mark('A_' + i); &#123; const pipe = new Pipe(units); pipe.on(PIPE_TYPE_ENCODE, (data) =&gt; &#123; pipe.feed(PIPE_TYPE_DECODE, data); &#125;); pipe.on(PIPE_TYPE_DECODE, () =&gt; null); pipe.feed(PIPE_TYPE_ENCODE, payload); &#125; performance.mark('B_' + i); performance.measure(`$&#123;units.length&#125; units`, 'A_' + i, 'B_' + i);&#125;const entries = performance.getEntriesByType('measure');for (const &#123; name, duration &#125; of entries) &#123; console.log(`$&#123;name&#125;: $&#123;duration&#125;ms`);&#125; 执行4次，可以将结果绘制到一张图中： 可以看到每次运行的结果高度一致，由上万个 PipeUnit 构成的链式 EventEmitter 能够以令人满意的效率完成运行。 不过出人意料的是，在特定数量的 PipeUnit 上总会出现尖峰，这可能和 V8 引擎的优化机制有关，作者能力有限，感兴趣的同学可以深挖原因。]]></content>
      <tags>
        <tag>tech</tag>
        <tag>eventemitter</tag>
        <tag>nodejs</tag>
        <tag>pipeline</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高效加载 WebAssembly 模块]]></title>
    <url>%2F2018%2F04%2F13%2Floading-webassembly-modules-efficiently%2F</url>
    <content type="text"><![CDATA[【译文】高效加载 WebAssembly 模块原文作者：Mathias Bynens原文地址：https://developers.google.com/web/updates/2018/04/loading-wasm在使用 WebAssembly 的时候，通常需要下载、编译、实例化一个模块，然后通过 JavaScript 调用由该模块导出的一些东西。这篇文章从一个常见但不是很优秀的代码片段开始，讨论几种可能的优化方法，最后得出最简单、最高效的通过 JavaScript 运行 WebAssembly 的方法。注意：诸如 Emscripten 的一些工具可以为你准备样板代码，因此你不需要自己编写 wasm 代码。如果你要更加细粒度地控制 WebAssembly 模块加载，那么请专注于下面的最佳实践吧。下面的代码片段完成了下载-编译-实例化的整个过程，尽管不是很优秀的方式：123456789// 别这么做(async () =&gt; &#123; const response = await fetch('fibonacci.wasm'); const buffer = await response.arrayBuffer(); const module = new WebAssembly.Module(buffer); const instance = new WebAssembly.Instance(module); const result = instance.exports.fibonacci(42); console.log(result);&#125;)(); 注意我们是如何使用 new WebAssembly.Module(buffer) 将响应数据转换成一个模块的。这是一个同步 API，意味着它在完成之前会阻塞主线程。为了防止滥用，Chrome 禁止在超过 4KB 的 buffer 上使用 WebAssembly.Module。为了避免大小限制，我们可以用 await WebAssembly.compile(buffer) 来代替： 12345678(async () =&gt; &#123; const response = await fetch('fibonacci.wasm'); const buffer = await response.arrayBuffer(); const module = await WebAssembly.compile(buffer); const instance = new WebAssembly.Instance(module); const result = instance.exports.fibonacci(42); console.log(result);&#125;)(); await WebAssembly.compile(buffer) 仍然不是一个优秀的方式，不过姑且先这样。 在修改后的代码片段中，几乎所有的操作都是异步的，因为 await 使之变得很清晰。只有 new WebAssembly.Instance(module) 是个例外。为了一致性，我们可以用异步 WebAssembly.instantiate(module)。 12345678(async () =&gt; &#123; const response = await fetch('fibonacci.wasm'); const buffer = await response.arrayBuffer(); const module = await WebAssembly.compile(buffer); const instance = await WebAssembly.instantiate(module); const result = instance.exports.fibonacci(42); console.log(result);&#125;)(); 让我们回顾一下我之前提到的对于 compile 的优化。利用 流式编译，浏览器可以在模块数据下载过程中就开始编译 WebAssembly 模块。因为下载和编译过程是并发的，特别是对于大模块，这样将会更快。 使用 WebAssembly.compileStreaming 替换 WebAssembly.compile 可以开启这个功能。这么做之后还可以避免产生中间数据，因为现在我们可以直接传递由 await fetch(url) 返回的 Response 实例。 1234567(async () =&gt; &#123; const response = await fetch('fibonacci.wasm'); const module = await WebAssembly.compileStreaming(response); const instance = await WebAssembly.instantiate(module); const result = instance.exports.fibonacci(42); console.log(result);&#125;)(); 注意：服务端必须经过配置能够支持以 Content-Type: application/wasm 头发送 .wasm 文件。在之前的例子中，我们将响应数据当做 arraybuffer 传递，因此不需要进行 MIME 类型检查。 WebAssembly.compileStreaming API 也能接收一个 resolve 为 Response 的 promise 实例。如果你没在别的地方使用 response，你可以直接传递由 fetch 返回的 promise 对象，而不需要 await： 1234567(async () =&gt; &#123; const fetchPromise = fetch('fibonacci.wasm'); const module = await WebAssembly.compileStreaming(fetchPromise); const instance = await WebAssembly.instantiate(module); const result = instance.exports.fibonacci(42); console.log(result);&#125;)(); 如果你也没在其他地方使用 fetch 的结果，你甚至也可以直接传递它： 1234567(async () =&gt; &#123; const module = await WebAssembly.compileStreaming( fetch('fibonacci.wasm')); const instance = await WebAssembly.instantiate(module); const result = instance.exports.fibonacci(42); console.log(result);&#125;)(); 我个人认为将其单独成行可读性更好。 想知道我们是如何将响应数据编译为模块然后实例化的？事实证明，WebAssembly.instantiate 可以一步到位。 12345678(async () =&gt; &#123; const fetchPromise = fetch('fibonacci.wasm'); const &#123; module, instance &#125; = await WebAssembly.instantiateStreaming(fetchPromise); // 稍后创建 instance 对象: const otherInstance = await WebAssembly.instantiate(module); const result = instance.exports.fibonacci(42); console.log(result);&#125;)(); 如果你只需要 instance 对象，那没理由再保留 module 对象，简化代码如下： 1234567// 这是加载 WebAssembly 的建议方式。(async () =&gt; &#123; const fetchPromise = fetch('fibonacci.wasm'); const &#123; instance &#125; = await WebAssembly.instantiateStreaming(fetchPromise); const result = instance.exports.fibonacci(42); console.log(result);&#125;)(); 总结一下我们所用过的优化方法： 使用异步 API 来避免阻塞主线程 使用流式 API 来加快 WebAssembly 模块的编译和实例化速度 不要写你不需要的代码 尽情享用 WebAssembly 吧！]]></content>
      <tags>
        <tag>tech</tag>
        <tag>webassembly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 16.3 Context API 实践]]></title>
    <url>%2F2018%2F03%2F12%2Freact-16-3-context-api%2F</url>
    <content type="text"><![CDATA[React 16.3 Context API 实践摘要本文简单介绍了 Context API 的提出背景、API 设计和用法；之后比较了 React-Redux 的设计；然后提出了一种基于 Context API 的二次封装；最后再将二次封装和 mobx-react 进行了比较。背景React 项目组成员 @acdlite 于 2017-12-05 提出关于新 Context API 的 RFC。实际上 Context 在 React 的早期版本中就已经存在，但不能解决当 shouldComponentUpdate 返回 false 时，组件无法响应 context 的改变的问题。由于 shouldComponentUpdate 常用于性能优化，被大量开源库或框架广泛使用，因此原版的 Context 变得十分鸡肋，新的 Context API 很好地解决了这一问题。Context API首先安装 16.3.x 版本的 react 及 react-dom:1$ yarn add react@next react-dom@next 来看一个简单的例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import React, &#123; createContext &#125; from 'react';import ReactDOM from 'react-dom';const &#123; Provider, Consumer &#125; = createContext(&#123;&#125;);class Child extends React.Component &#123; render() &#123; // const &#123; date &#125; = this.props; return ( &lt;div&gt; &lt;Consumer&gt; // 子组件在任意位置通过 &lt;Consumer&gt; 消费顶层给 &lt;Provider&gt; 传入的 value， // 感知 value 的变化来重新渲染该区块。 &#123;(&#123; date &#125;) =&gt; &lt;p&gt;&#123;date&#125;&lt;/p&gt;&#125; &lt;/Consumer&gt; &lt;/div&gt; ); &#125;&#125;class App extends React.Component &#123; state = &#123; date: '', &#125;; componentDidMount() &#123; setInterval(() =&gt; &#123; // 在父组件中更新状态 this.setState(&#123; date: new Date().toString() &#125;); &#125;, 1e3); &#125; render() &#123; return ( &lt;Provider value=&#123;this.state&#125;&gt; // 父组件不用给子组件显式传入任何数据 &lt;Child/&gt; &lt;/Provider&gt; ); &#125;&#125;ReactDOM.render(&lt;App/&gt;, document.querySelector('#root')); 使用 Context API 最大的好处就是解决深层嵌套组件层层传递 props 的问题。但这样做也存在一个问题： state 的被保存在 &lt;App&gt; 中，更新状态时必须调用 &lt;App&gt; 的 this.setState()，如果子组件需要更新 state，那么需要通过 &lt;Provider&gt; 向下传递封装了 this.setState() 的回调函数: 12345678&lt;Provider value=&#123;&#123; state: this.state, actions: &#123; doSomething(newState) &#123; this.setState(newState); &#125; &#125;&#125;&#125;&gt; &lt;Child/&gt;&lt;/Provider&gt; 之后，子组件要求改变状态时，在 &lt;Consumer&gt; 中调用该回调方法即可： 12345&lt;Consumer&gt; &#123;(&#123; state: &#123; date &#125;, actions &#125;) =&gt; &lt;button onClick=&#123;() =&gt; actions.doSomething(...)&#125;&gt;&#123;date&#125;&lt;/button&gt; &#125;&lt;/Consumer&gt; 另有一个问题是如何实现在 组件外 更新状态，让组件也能响应状态变化？ 这样的需求通常在应用需要与第三方库交互时会遇到，举一个实际的例子： Q: 一个 web 应用使用 websocket 做数据交换，我们需要在页面上实时显示 websocket 连接的延迟： 123456// ws.jsconst ws = io.connect('/');ws.on('pong', (latency) =&gt; &#123; // 如何将 latency 渲染到组件里？&#125;); 先前例子中将 state 内化的方式显然不可行了，这个时候联想到 Redux，利用它全局 store 的设计，借助 store.dispatch 就可以实现上面的需求了。 Redux/React-ReduxReact-Redux 是对 React 老版本 Context 的封装，它允许子组件通过 connect 方法建立对 store 中状态变化的响应，下面是一个简单的 Redux 应用： 123456789101112131415161718192021222324252627282930313233343536373839// app.jsimport React from 'react';import &#123; createStore &#125; from 'redux';import &#123; connect &#125; from 'react-redux';// 创建一个 reducer 来处理 actionfunction reducer(state = &#123; date: '' &#125;, action) &#123; switch (action.type) &#123; case 'UPDATE_DATE': return &#123; date: action.date &#125;; default: return state; &#125;&#125;// 创建一个全局 store 来存储状态const store = createStore(reducer);class App extends React.Component &#123; componentDidMount() &#123; setInterval(() =&gt; &#123; // 发一个 action 来更新 store store.dispatch(&#123; type: 'UPDATE_DATE', date: new Date().toString() &#125;); &#125;, 1e3); &#125; render() &#123; return ( &lt;Provider store=&#123;store&#125;&gt; // 父组件不用给子组件显式传入任何数据 &lt;Child/&gt; &lt;/Provider&gt; ); &#125;&#125;ReactDOM.render(&lt;App/&gt;, document.querySelector('#root')); 12345678910111213141516// child.jsfunction mapStateToProps(state) &#123; return &#123; date: state.date &#125;;&#125;// 通过 connect 来感知全局 store 的变化@connect(mapStateToProps, null)class Child extends React.Component &#123; render() &#123; return ( &lt;div&gt;&#123;this.props.date&#125;&lt;/div&gt; ); &#125;&#125; 可以看到在 Redux 的套路中，完成一次 状态更新 需要 dispatch 一个 action 到 reducer，这个过程同时牵扯到三个概念，有些复杂；而在 Context API 的套路中，完成一次 状态更新 只需要 setState(...) 就够了，但单纯的 Context API 无法解决先前提到的 组件外 更新状态的问题。 对 Context API 的简单封装下面对 Context API 进行二次封装，让它支持类似 Redux 全局 store 的特性，但用法又比 Redux 更加简单。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// context.jsimport React, &#123; createContext &#125; from 'react';const AppContext = createContext();// self 是对 &lt;Provider&gt; 组件实例的引用let self = null;class Provider extends React.Component &#123; state = &#123;&#125;; constructor(props) &#123; super(props); self = this; &#125; render() &#123; return ( &lt;AppContext.Provider value=&#123;this.state&#125;&gt; &#123;this.props.children&#125; &lt;/AppContext.Provider&gt; ); &#125;&#125;const Consumer = AppContext.Consumer;function getState() &#123; if (self) &#123; return self.state; &#125; else &#123; console.warn('cannot getState() because &lt;Provider&gt; is not initialized'); &#125;&#125;function setState(...args) &#123; if (self) &#123; self.setState(...args); &#125; else &#123; console.warn('cannot setState() because &lt;Provider&gt; is not initialized'); &#125;&#125;function createStore() &#123; return &#123; getState, setState &#125;;&#125;export &#123; Provider, Consumer, createStore &#125;; 用法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import React from 'react';import ReactDOM from 'react-dom';import &#123; Provider, Consumer, createStore &#125; from './context';// 新建一个全局 storeconst store = createStore();class Child extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;p&gt;1. 通过回调参数获取最新状态&lt;/p&gt; &lt;Consumer&gt; &#123;(&#123; date &#125;) =&gt; &lt;div&gt;&#123;date&#125;&lt;/div&gt;&#125; &lt;/Consumer&gt; &lt;p&gt;2. 通过 store.getState() 获取所有状态&lt;/p&gt; &lt;Consumer&gt; &#123;() =&gt; &lt;pre&gt;&#123;JSON.stringify(store.getState(), null, 2)&#125;&lt;/pre&gt;&#125; &lt;/Consumer&gt; &lt;p&gt;3. 通过 store.setState() 更新状态&lt;/p&gt; &lt;Consumer&gt; &#123;() =&gt; &lt;button onClick=&#123;() =&gt; store.setState(&#123; foo: new Date().toString() &#125;)&#125;&gt;子组件触发状态更新&lt;/button&gt;&#125; &lt;/Consumer&gt; &lt;/div&gt; ); &#125;&#125;class App extends React.Component &#123; componentDidMount() &#123; // 父组件触发状态更新 setInterval(() =&gt; &#123; store.setState(&#123; date: new Date().toString() &#125;); &#125;, 1e3); &#125; render() &#123; return ( // 现在 &lt;Provider&gt; 不需要任何参数了 &lt;Provider&gt; &lt;Child/&gt; &lt;/Provider&gt; ); &#125;&#125;ReactDOM.render(&lt;App/&gt;, document.querySelector('#root')); 现在在应用的任意位置调用 store.setState() 方法，就能更新组件的状态了： 123456789import store from './store';// ws.jsconst ws = io.connect('/');ws.on('pong', (latency) =&gt; &#123; // 如何将 latency 渲染到组件里？ store.setState(&#123; latency &#125;);&#125;); 和 mobx/mobx-react 进行比较MobX 基于观察者模式，通过 mobx-react 封装后许多地方和 Context API 类似，下面是官方提供的一个例子： 1234567891011121314151617class App extends React.Component &#123; render() &#123; return ( &lt;div&gt; &#123;this.props.person.name&#125; &lt;Observer&gt; &#123;() =&gt; &lt;div&gt;&#123;this.props.person.name&#125;&lt;/div&gt;&#125; &lt;/Observer&gt; &lt;/div&gt; ) &#125;&#125;const person = observable(&#123; name: "John" &#125;)React.render(&lt;App person=&#123;person&#125; /&gt;, document.body)person.name = "Mike" // will cause the Observer region to re-render 在 mobx-react 的套路中，组件可以通过 &lt;Observer&gt; 消费由 observable() 创建出来的对象，直接修改该对象中的键值可以实现组件的重新渲染。 二次封装后的 Context API 相比 mobx-react 用法相近，但 mobx 得益于 setter/getter Hooks 具有更直观的状态改变方式。 参考资料 https://github.com/acdlite/rfcs/blob/new-version-of-context/text/0000-new-version-of-context.md https://github.com/reactjs/rfcs/pull/2 https://github.com/facebook/react/pull/11818]]></content>
      <tags>
        <tag>tech</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qnimate, an animated colorful voronoi diagram powered by d3.js]]></title>
    <url>%2F2016%2F10%2F11%2Fqnimate%2F</url>
    <content type="text"><![CDATA[qnimateAn animated colorful Voronoi diagrampowered by d3.Live demohttps://micooz.github.io/qnimateTry it!Install via npm:12$ git clone https://github.com/micooz/qnimate$ cd qnimate &amp;&amp; npm i Run in development: 1$ npm start Build and bundle: 1$ npm run build:prod UsageHTML: &lt;div id=&quot;&quot;playground&quot;&quot;&gt;&lt;/div&gt; js: &lt;script src=&quot;&quot;qnimate.min.js&quot;&quot;&gt;&lt;/script&gt; Qnimate will be exposed to window, create an instance of Qnimate, pass an option object and then call run(): 123456789document.addEventListener('DOMContentLoaded', function main() &#123; var qnimate = new Qnimate(&#123; id: 'playground', width: 960, height: 500, vertices: 40 &#125;); qnimate.run();&#125;); Acknowledgmentsd3.voronoi - https://github.com/d3/d3-voronoi Known issues New triangle appears suddenly. White triangle appears from time to time. Any advice?Send me issue.]]></content>
      <tags>
        <tag>tech</tag>
        <tag>d3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[How to disable text selection in svg]]></title>
    <url>%2F2016%2F07%2F26%2Fhow-to-disable-text-selection-in-svg%2F</url>
    <content type="text"><![CDATA[In sass style:1234567text &#123; user-select: none; &amp;::selection &#123; background: none; &#125;&#125;]]></content>
      <tags>
        <tag>tech</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[D3绘图套路]]></title>
    <url>%2F2016%2F06%2F16%2Fd3-stereotype%2F</url>
    <content type="text"><![CDATA[接触D3三天，发现有些套路可以反复运用，所以记录一下。D3相比其他图表库，学习成本较高。但最为灵活，需要使用者精雕细琢图形的每个细节。D3处处体现了函数式的编程思维。NOTE: 这里所用D3版本是：123&quot;&quot;dependencies&quot;&quot;: &#123; &quot;&quot;d3&quot;&quot;: &quot;&quot;^4.0.0-alpha.49&quot;&quot;&#125; 下面以一个简单的横纵坐标图为例。 ① 定义高宽1234567var margin = &#123;left: 70, top: 20, right: 20, bottom: 50&#125;;var svgWidth = 800;var svgHeight = 500;var graphWidth = svgWidth - margin.left - margin.right;var graphHeight = svgHeight - margin.top - margin.bottom; 这一步实际上比较重要，图形高宽参数会在后面绘图中常常用到。 ② 创建svg123var svg = d3.select('.container').append('svg') .attr('width', svgWidth) .attr('height', svgHeight); 这里可以直接在html中放一个&lt;svg&gt;，但为了可移植性，用脚本生成。 ③ 创建绘制区域1234var graph = svg.append('g') .attr('width', graphWidth) .attr('height', graphHeight) .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')'); &lt;g&gt;中将包含所有图形元素（坐标轴、标签、线条……），现在svg树是这样的： 123&lt;svg&gt; &lt;g&gt;&lt;/g&gt;&lt;/svg&gt; ④ 设置X、Y的图形坐标范围12345var x = d3.scaleTime() .range([0, graphWidth]);var y = d3.scaleLinear() .range([graphHeight, 0]); 这个时候由于数据还没获取，只能先设置他们的图形坐标范围，注意这个不是数据的定义域。 这个两个函数通常有两个用途，以x为例： 12var px = x(data); // 根据数据值计算对应的x坐标值var data = x.invert(px); // 根据x坐标值反算对应的数据值 ⑤ 获取数据一般情况下都是从远端取回特定格式的数据，这是个异步过程： 123d3.csv('data.csv', parser, function(err, data) &#123; // data&#125;) D3很人性化的给你留了个格式化数据的地方parser。 123456function parser(d) &#123; return &#123; date: d3.timeParse('%b %Y')(d.date), value: +(d.price) &#125;;&#125; D3取出数据的每一行，依次传入该函数，然后可以返回你需要的格式化数据，最后以数组形成出现在data变量中。 ⑥ 设置X、Y的值域12345678// value domain of x and yx.domain(d3.extent(data, function (d) &#123; return d.date;&#125;));y.domain([0, d3.max(data, function (d) &#123; return d.value;&#125;)]); 现在可以给x和y设置值域了，值域类型可以很灵活，上面设置x的值域是一个时间范围。 ⑦ 开始绘制接下来就是构思你图形的各个部分了，坐标轴、标签、图形内容等等，也是逐步生成一个完整svg的过程。为了简便起见，这里不会贴出冗余代码。 绘制X轴： 123456// X、Y轴可以利用D3的axisXXXXXX函数简单创建，// 它会把坐标轴的每个数据标签、包括刻度线都为你生成好graph.append('g') .attr('class', '.x-axis') .attr('transform', 'translate(-1,' + graphHeight + ')') .call(d3.axisBottom(x)); 绘制折线： 1234567891011121314// 创建一个线段生成器，会根据绑定数据，通过x和y访问器计算每个点的坐标位置var line = d3.line() .x(function (d) &#123; return x(d.date) &#125;) .y(function (d) &#123; return y(d.value) &#125;);// 折线图可以用svg中的&lt;path&gt;并设置其d属性来绘制// line函数需要一个点集来生成一个字符串，这个字符串可以直接填充&lt;path&gt;的d属性// 为了使线段可见，还需要设置其stroke和stroke-width样式。var path = graph.append('path') .attr('d', line(data)); 至此，就可以看到一个基本图形了。]]></content>
      <tags>
        <tag>tech</tag>
        <tag>d3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【记坑】关于d3.zoom]]></title>
    <url>%2F2016%2F06%2F14%2Fd3-zoom%2F</url>
    <content type="text"><![CDATA[D3.js的最新v4版提供了d3.zoom模块，用它可以给svg图形增加缩放/移动的特性，但通过非鼠标/触控的方式改变图形的位置和缩放比例后，d3.zoom的行为就变得不正常了。本文给出一个解决方法。1234567891011121314// 1. 初始化一个zoom行为const zoom = d3.zoom();// 2. 设置zoom行为参数zoom.scaleExtent([.5, 5]);...// 3. 添加三个事件监听器zoom.on('start', () =&gt; &#123;...&#125;);zoom.on('zoom', zoom);zoom.on('end', () =&gt; &#123;...&#125;);// 4. 应用行为g.call(zoom); 我们一般会关注zoom事件： 1234const zoom = () =&gt; &#123; // d3自动计算的transform值会放在d3.event里 container.attr('transform', d3.event.transform);&#125;; 有趣的是，如果我们在其他地方主动设置： 1container.attr('transform', 'translate(10, 10)'); 再用鼠标或者触控板调整图形时，zoom行为并不会从(10, 10)位置开始计算下一个d3.event.transform，zoom行为似乎自己保存了上一次的transform，而不关心我们设置到container上的transform。 结果就是我们用attr设置的transform其实是临时的。 如果查看应用了zoom行为的宿主元素（这里是g）的属性，会发现其Element上有一个__zoom: Transform，这个玩意儿每次走zoom方法的时候都会变化，这正是zoom自己保存的transform对象。 所以我们在主动设置transform后，只需要想办法更新这个__zoom就可以骗过zoom行为，让它下一次调用zoom()事，从我们设置的值开始计算。 查阅文档： https://github.com/d3/d3-zoom/blob/master/README.md#zoom_transform https://github.com/d3/d3-zoom/blob/master/README.md#transform_scale 可以这样设置： 1234567891011// 自定义transformcontainer.attr('transform', 'translate(10, 10)');// 初始化一个空的Transform对象，这一点文档没说明怎么构造一个Transform对象const transform = d3.zoomTransform(0)// 填充&#123;x, y&#125; .translate(10, 10);// 注意一定要设置在.call(zoom)的元素上，它才有'__zoom'd3.zoom().transform(g, transform); 之后d3触发zoom回调之前会取g的__zoom计算下一次的transform，这个transform才是我们想要的。]]></content>
      <tags>
        <tag>tech</tag>
        <tag>d3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[link in docker]]></title>
    <url>%2F2016%2F05%2F12%2Flink-in-docker%2F</url>
    <content type="text"><![CDATA[–link in docker容器A通过–link选项使用容器B的某个服务，docker-compose.yml 配置如下：A: image: image_a links: - B:B ... B: image: image_b ... 当容器B被重启后，A的link不会被自动更新，要一并重启A才行：$ docker-compose restart B # A doesn&apos;t work $ docker-compose restart A # it works well]]></content>
      <tags>
        <tag>tech</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack-dev-server 最佳实践]]></title>
    <url>%2F2016%2F05%2F10%2Fwebpack-dev-server-best-practice%2F</url>
    <content type="text"><![CDATA[简述webpack-dev-server 是用express和websocket实现的一套在开发环境下前端自动更新的工具。webpack-dev-server提供CLI接口，读取传入的webpack.config.js配置文件，根据webpack配置，建立一个静态服务器，供前端加载静态资源，其中有一个关键附加脚本是 webpack-dev-server.js，位于PATH根路径，即 /webpack-dev-server.js，其中存放着websocket客户端。一般使用方法可以通过下面的命令运行webpack-dev-server：$ node node_modules/.bin/webpack-dev-server --config webpack/dev.config.js --inline --profile --colors --watch --display-error-details --display-cached 参数说明参考：这里执行后会自动运行webpack进行打包等一系列操作。在webpack配置文件中只需添加一个 devServer 配置项即可定义webpack-dev-server的行为：12345678910devServer: &#123; port: 3000, host: 'localhost', historyApiFallback: true, quiet: false, watchOptions: &#123; aggregateTimeout: 300, poll: 1000 &#125;&#125;, 在这个例子中，webpack-dev-server会在本地3000端口上启动一个静态服务器，服务器serve的目录是webpack的必选配置 output.path，这是一个绝对路径。 一些问题？请考虑下面这个问题： 我有一个网站项目，分模块，每个模块是一个node项目，且每个模块可以独立存在（启动，调试，运行），它们有些用到了webpack-dev-server。 再次强调每个模块相互独立，它们之间的耦合方式只有一种：请求代理。 现在假设模块A作为API服务器，监听3000端口；模块B作为应用服务器，要提供资源给浏览器，于是用webpack-dev-server在端口3001的 / 上建立了静态服务器。模块B还要从模块A存取数据，那么必定存在从3001跨域请求到3000的问题，消除这个问题有多种解决办法： 在A上设置 Access-Control-Allow-Origin 为B的域。 在A、B上层建立代理服务器，屏蔽端口限制。 不深入讨论上面的方法，现在假设我们采用方法二解决了跨域请求问题，然后我们再考虑一下接下来的一个问题： 假设存在模块C，和B十分类似，也属于应用服务器；如果B和C存在同名资源，比如 main.js，访问该资源就会引发冲突，因为两个模块都在 / 上建立了静态服务器，而这又符合每个模块可以独立存在的先决条件： // B http://localhost/B/index.html http://localhost/main.js // C http://localhost/C/index.html http://localhost/main.js // 哪个 main.js ? 解决办法看似很明显： // B http://localhost/B/index.html http://localhost/B/main.js // C http://localhost/C/index.html http://localhost/C/main.js // everyone is happy 但这又破坏了每个模块的独立性，我希望单独启动C时，C总能从 / 上获取资源，而不是 /C/... 这么冗余。 最佳实践问题就出在 webpack-dev-server，它适合作为静态资源服务器，而不是开发服务器。因此，我们的开发环境除了需要 webpack-dev-server，还需要专门的开发服务器。 // =&gt; Module B // dev server http://localhost/B/index.html // webpack-dev-server for B http://localhost:3001/... // =&gt; Module C // dev server http://localhost/C/index.html // webpack-dev-server for C http://localhost:3003/... 每个模块从对应的 webpack-dev-server 获取资源，解决了冲突又保留了每个模块的独立性。]]></content>
      <tags>
        <tag>tech</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular2 如何多次触发子组件的 ngOnInit]]></title>
    <url>%2F2016%2F03%2F29%2Fangular2-multiple-ngoninit%2F</url>
    <content type="text"><![CDATA[通常子组件加载后只会执行一次ngOnInit，不利于子组件的自我更新，但设法使子组件从Dom中移除后重建就可以多次触发ngOnInit。1&lt;person *ngIf="show"&gt;&lt;/person&gt; 12345class PersonComponent &#123; ngOnInit() &#123; // triggered if show is available &#125;&#125; 像这种带星号的指令就是Angular2中一种模板语法糖，可以管控组件的生命周期。]]></content>
      <tags>
        <tag>tech</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack复习]]></title>
    <url>%2F2016%2F03%2F22%2Fwebpack-review%2F</url>
    <content type="text"><![CDATA[使用ProvidePlugin暴露对象到全局：1234567plugins: [ new webpack.ProvidePlugin(&#123; $: 'jquery', jQuery: 'jquery', 'window.jQuery': 'jquery' &#125;)] 自定义require返回值： 12345678// webpack.config.jsexternals: &#123; 'data': 'data data...'&#125;// use in codevar data = require('data'); // 'data data...' 开启Hot Module Replacement(HMR) 方法一： $ webpack --hot --inline –hot: 添加HotModuleReplacementPlugin –inline: 在生成的js中添加websocket客户端 方法二： 12345678910// webpack.config.jsentry: &#123; 'webpack/hot/dev-server', // 仅仅是为window添加一个listener 'webpack-dev-server/client?http://localhost:8000' // websocket客户端&#125;plugins: [ new webpack.HotModuleReplacementPlugin()]]]></content>
      <tags>
        <tag>tech</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用索引提升js的执行效率]]></title>
    <url>%2F2016%2F03%2F17%2Fimprove-js-performance-by-using-index%2F</url>
    <content type="text"><![CDATA[问题引入：前段时间，有一个任务是需要频繁在大量的数据集合中快速定位并修改某个元素某个字段的值。数据结构是数组，元素的结构可能相当复杂且乱序。问题分析：假定这个数据集如下：// array dataset [{ name: &apos;name1&apos;, body: { metadata: { header: { id: 1 // unique } } }, ... }] 实际上就是一个查找算法问题，假设要从1000条数据中查找id为1的元素，最SB做法是直接遍历整个数据集：12345for(let ele of dataset) &#123; if (ele.body.metadata.header.id === 1) &#123; return ele; &#125;&#125; 最坏的情况是O(n)，当然也可以使用其他常见的查找算法减少遍历次数，但如果要频繁查找，同步操作会导致页面直接卡死。 如果有一张哈希表就帮大忙了，不妨先想想下面这个问题： 在数据库里，为什么给一个字段加个索引就可以极大提升查询效率（通常情况）？ 解决方案： 首先理解索引的含义，在js中，数组是线性结构，它的下标可以当成一种索引，通过下标访问元素时间复杂度为O(1)： 12const db = [1, 2, 3, 4, 5, ...];const ele = db[2]; // very quick 对于一个Object，同样的： 1234567const obj = &#123; col1: 1, col2: 2, ...&#125;;const col2 = obj['col2']; // very quickconst col2 = obj.col2; // very quick 再看看最开始的那个问题，如果我们可以： 12const id = 1;const ele = dataset[id]; // very quick 实现这个效果实际上就要建立索引，此时的 dataset 显然已经不能是最原始的数组了。当id不是数字的时候，dataset 也不能是数组，那么Object就理所当然地充当js里的HashMap了（ES6中已经有标准的Map实现）。 编写一个通用的索引创建函数，这个函数可以为一个数组，通过传入的回调函数的返回值创建一个包含所有数据引用的索引对象（Object）： 1234567891011const index = (arr, fn) =&gt; &#123; let indexes = &#123;&#125;; for (let it of arr) &#123; const key = fn(it); if (!indexes[key]) &#123; indexes[key] = &#123;&#125;; &#125; indexes[key] = it; &#125; return indexes;&#125; 函数只需要遍历一次数据集来建立索引。 用法： 1234567891011121314151617const our_index = _index(dataset, ele =&gt; ele.body.metadata.header.id);/*&#123; "1": &#123; name: 'name1', body: &#123; metadata: &#123; header: &#123; id: 1 // unique &#125; &#125; &#125; &#125;, "2": &#123;...&#125;, ...&#125;*/ 有了这个索引 our_index，就可以愉快的以O(1)的复杂度来访问任意元素，取出的元素是引用，于是也可以直接对原存储空间的数据进行操作： 123let ele = our_index[1];// operation on eleele.name = '_' + ele.name; 小结 原生JavaScript不支持Map数据结构，因此可以通过对象来实现；关键在于如何根据需要建立索引，建立索引的字段必须满足唯一性。]]></content>
      <tags>
        <tag>tech</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular2 事件绑定注意]]></title>
    <url>%2F2016%2F02%2F23%2Fangular2-events-bind%2F</url>
    <content type="text"><![CDATA[123&lt;select [(ngModel)]="value" (change)="onSelect(value)"&gt; ...&lt;/select&gt; 123onSelect(value) &#123; // value 还是原来的值，没来得及改变&#125; 解决办法 12345onSelect(value) &#123; setTimeout(() =&gt; &#123; // value 绑定完成后的值 &#125;);&#125; console.log 或者说Chrome DevTools的坑考虑下面的代码： 12345678let obj = &#123;a: []&#125;, n = 100;while(n--) &#123; obj.a.push(n);&#125;console.log(obj); // obj.a[50]: -100obj.a[50] = -100;console.log(obj); // obj.a[50]: -100 浏览器里可以发现两次输出的结果中 a[50] 都是 -100。这一点如果第一次遇到的话还真是匪夷所思。 这里我故意把 a 数组的元素弄得很多，使 DevTools 以 折叠 方式显示： Object {a: Array[100]}Object {a: Array[100]} 看似友好的显示方式，实际上里面有很大的问题。 当我们展开第一个输出时， DevTools 会 及时 读取变量值，由于这是个 引用 类型，实际上它读到的是 obj 的最终值，及 a[50] 是 -100。 如果数组a只有很少的元素，DevTools 不启用智能显示时就不会出现这个问题。 也就是说，console.log 到 DevTools 里的实际上是引用而不是拷贝，展开操作会及时读取变量值。 如果把上面例子的两个输出改成： 1console.log(JSON.stringify(obj)); 结果将和预期的一致。 因此，在浏览器中调试 js 程序应该以 调试器 下断点为主，日志为辅。]]></content>
      <tags>
        <tag>tech</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular2 @Input 绑定问题]]></title>
    <url>%2F2016%2F02%2F19%2Fangular2-input-bind%2F</url>
    <content type="text"><![CDATA[@Component({ template: `&lt;child [value]=&quot;bindValue&quot;&gt;&lt;/child&gt;` }) class HomeComponent { bindValue:string = &apos;hello&apos;; } @Component({ selector: &apos;child&apos;, template: `...` }) class ChildComponent{ @Input() value; ngOnInit(){ // 这里可以取到value的值为&apos;hello&apos; // 当bindValue动态改变时，此函数不会再次调用，需要在ngOnChanges中手动更新 } ngOnChanges(changes) { // this.value = changes[&apos;value&apos;].currentValue; // ... // 但是要小心这个函数会被频繁调用， // 不要做复杂逻辑 } } Array.prototype.map 的坑map回调如果不给出返回值，则默认返回 undefined，MDN文档中似乎并未提到这一点。var numbers = [1, 4, 9]; var roots = numbers.map(n =&gt; { if (n === 4) { return -1; } }); // [undefined, -1, undefined]]]></content>
      <tags>
        <tag>tech</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浮动元素z-index无效问题]]></title>
    <url>%2F2016%2F02%2F18%2Ffloat-element-z-index-problem%2F</url>
    <content type="text"><![CDATA[.view-container { float: right !important; z-index: 999; /* invalid! */ /* position must be set */ position: relative; }]]></content>
      <tags>
        <tag>tech</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Object.assign]]></title>
    <url>%2F2016%2F02%2F17%2Fobject-assign%2F</url>
    <content type="text"><![CDATA[const _new = Object.assign(target, {...}); 会改变 target 本身，引发问题。The Object.assign() method is used to copy the values of all enumerable own properties from one or more source objects to a target object. It will return the target object.有三个解决办法：逐个拷贝const _new = {k1: target.k1, k2: target.k2, ...}; ES6const _new = {...target, ...{...}}; （最佳）把第一个参数设成空对象const _new = Object.assign({}, target, {...});]]></content>
      <tags>
        <tag>tech</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular2 - Routing & Navigation]]></title>
    <url>%2F2016%2F02%2F15%2Fangular2-routing-navigation%2F</url>
    <content type="text"><![CDATA[@routerCanActive 在加载组件前执行，其回调函数有两种返回方式：@routerCanActive(function() { // return true; 同步 // return Promise.resolve(true); 异步 })]]></content>
      <tags>
        <tag>tech</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Docker部署PHP应用的设计方案]]></title>
    <url>%2F2015%2F08%2F29%2Fdocker-lnmp%2F</url>
    <content type="text"><![CDATA[1. DockerDocker的官方定义是：Docker allows you to package an application with all of its dependencies into a standardized unit for software development.– https://www.docker.com/whatisdocker毫无疑问的是，Docker解决了应用部署上一个巨大的问题：客户: 安装好了，用不了。发布者：我的机器上没问题。如何解决每个应用的依赖在Docker出现之前是个头疼的问题，现在仅仅通过一次配置，Dockerfile或者image作为最终交付，就能在任何Linux上完美运行了。说起来很简单的样子，但在Docker配置过程中，又存在很多值得思考的问题：应用各个组件如何安排？一个Container解决问题还是细化Container？Container之间何如通信？等等。。下面用一个最普遍的WEB应用配置部署来说明这些问题。NOTE：本文假定读者对Docker中的一些概念有基本的认识，如果不甚了解，我推荐这篇文章：https://linux.cn/article-6074-weibo.html2. LNMP典型的PHP应用配置方案是LAMP或者LNMP，本文以LNMP为例。设计方案如下图:应用由4个组件组成，分别是Nginx，PHP-FPM(PHP)，MySQL以及WWW，4个组件运行在由各自镜像创建出来的独立的容器中。其中WWW Container只是一个存储业务代码和静态资源的容器，可以认为是”死”的。事实上LNMP架构采用上面的设计方式应该是最容易想到的，也是最清晰的，每个组件有相对的独立性。其中除了WWW容器，其他3个容器都可以直接通过官方镜像构建出来。然而网上很多同学并不是这样做的，不会分的这么细，通常是把Nginx和WWW放到一个容器内，或者干脆全部放到一个容器中。可以学习一下大家的Dockerfile:https://github.com/search?utf8=✓&amp;q=docker-lnmp细化Container这种设计的优缺点：容器间的耦合性增大。可以看到PHP-FPM容器和另外三个容器间有耦合关系，MySQL容器最独立。虽然耦合性比较大，但这种端口耦合，文件系统耦合关系可以通过增加几个运行选项解决掉，后面有介绍。由于容器对整个架构的划分，使得容器中的内容变得十分独立和安全。例如，我希望在线上更新WWW中的代码，只需要进入WWW容器做修改，不会影响到Nginx，PHP-FPM或者是MySQL。各容器可灵活拆卸更换，比如我想把MySQL换成Mongodb，或者干脆把业务代码搬个家，不会影响到其他容器（仅仅更改相关配置文件）由于各容器经由官方的镜像创建，因此可以随时花最少的代价使用最新的官方镜像尝鲜。占用空间会比较大，一个简单的应用要这么做的话，四个镜像会占用大量的存储空间。2.1 容器间通信问题细化Container面临着另一个问题，就是如何进行容器间通信。下面简要描述一下上图中的数据流程：客户端的http请求达到server的80端口，该端口被映射到Nginx Container的80端口，因此进入Nginx处理。Nginx会分析请求资源，判定是静态资源还是php脚本，如果是静态资源，则直接从WWW中取出发回客户端；如果是脚本程序，则要告诉PHP-FPM到WWW获取相应脚本，然后通过php-cgi处理。fast-cgi通过php执行脚本，必要时访问MySQL存取数据。这样耦合关系就出来了：Nginx需要连接PHP-FPM开放的9000端口，需要访问WWW中的文件系统。PHP-FPM也需要访问WWW中的文件系统，还要访问MySQL的3306端口。2.2 解决问题可以看出有两类耦合关系：端口和文件系统。对于端口耦合，docker是通过–link选项解决的；对于文件系统耦合，docker是通过–volumes-from选项解决的。解决第一个耦合关系：12345$ sudo docker run -p 80:80 -p 443:443 # 主机端口映射到容器--volumes-from WWW_CONTAINER_NAME # 把WWW容器VOLUME过的文件夹挂载到将启动的容器上--link PHP_FPM_CONTAINER_NAME:fpmservice # 冒号前是正在运行的FPM容器名称，后面是别名，别名会作为hostname在将启动的容器内可见-d # detachNGINX_IMAGE # 镜像名 解决第二个耦合关系： 1234$ sudo docker run --volumes-from WWW_CONTAINER_NAME--link MYSQL_CONTAINER_NAME:mysql-dPHP_FPM_IMAGE 参考文档：https://docs.docker.com/reference/run/ 因此容器启动的先后顺序就出来了： MySQL Container WWW Container (由于没有任何服务运行，容器run后会立即exit，可以使用 tail -f 等block命令使容器保持运行不退出) PHP-FPM Container Nginx Container 其中1和2可以对换。 3. DockerfileDockerfiles 请参见： https://github.com/micooz/dockerfile http://git.oschina.net/micooz/dockerfile 4. 总结利用Docker部署Web应用可以带来很多便利，在宏观上实现应用组件化，为实现分布式系统奠定了基础。 可以看到实际上在Docker容器间共享数据是很方便的，搞清楚各容器的依赖关系就不难解决。 P.s. 本文是我学习docker两天后的心得体会，纰漏在所难免，如有错误还请斧正。]]></content>
      <tags>
        <tag>tech</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++使用模板类实现任意类型switch和变量case]]></title>
    <url>%2F2015%2F06%2F02%2Fcpp-template-class-switch-case%2F</url>
    <content type="text"><![CDATA[最近自己维护的一个项目program_options(是一个命令行生成与解析的C++库)在实际应用的时候遇到一个需求：需要switch一个字符串来执行相应代码块，然而原生的switch-case条件选择语法针对condition有严格的限制，下面摘录一段switch的语法标准：switch statementTransfers control to one of the several statements, depending on the value of a condition.Syntax12345678910attr(optional) switch ( condition ) statement attr(C++11) - any number of attributescondition - any expression of integral or enumeration type, or of a class type contextually implicitly convertible to an integral or enumeration type, or a declaration of a single non-array variable of such type with a brace-or-equals initializer.statement - any statement (typically a compound statement). case: and default: labels are permitted in statement and break; statement has special meaning.attr(optional) case constant_expression : statement (1) attr(optional) default : statement (2) constant_expression - a constant expression of the same type as the type of condition after conversions and integral promotions condition原生switch语法的condition支持整数，枚举或者根据上下文能够隐式转换为整数或者枚举的类，再或者是非数组类型的=或{}初始化语句，举例来说就是如下四类： 12345switch(100)enum color &#123;r, g, b&#125;switch(r)switch(int n = 1)switch(int n = &#123;1&#125;) case必须是常量，这样一来就无法做变量与变量之间的比较。 statement当statement没有被{}包围的时候，在其内使用声明语句会导致编译错误。比如： 1234567switch(num)&#123; case 1: int n = 0; // error: jump bypasses variable initialization break; default: break;&#125; 显然我的需求不能用原生的switch来实现，得老老实实if-elseif-elseif…来分别判断，导致代码又长又臭，if越套越多，逐条判断效率也让人心塞。 有需求就有想法，有想法就有创新，相信这样的需求早就有人实现过了，比如： 为C++添加短字符串的switch-case支持将字符串通过#@转换为整形再进行case 使用C++11新特性，实现用字符串作为switch的case子句利用C++11的constexpr，计算字符串的hash值再进行case 想法很不错，但是我想要更灵活的解决方案，我希望新的switch支持switch(object)，case(object)，还希望statement对变量声明没有限制，何不完全抛开原生switch的枷锁，自己利用标准库造一个switch来解决问题呢。 蓝图我希望利用C++强大的template来兼容任意类型，用C++11的lambda匿名函数实现statement，用操作符重载operator==来匹配条件，用hash表来提升匹配效率，看起来很容易不是吗？ 开始Coding之前我先拟定好蓝图： 1234567891011121314151617181920// 蓝图1select(condition, &#123; &#123;"case1", []() &#123; // code goes here &#125;&#125;, &#123;"case2", []() &#123; // code goes here &#125;&#125;&#125;);// 蓝图2select(condition) .found("case1", []() &#123; // code goes here &#125;) .found("case2", []() &#123; // code goes here &#125;) .others([]() &#123; // default &#125;); 我承认我是受到了javascript的影响，我一直以为C++越来越像是一种高级的脚本语言，或许也是它未来的发展趋势。 蓝图的设计首先符合C++的语法规范，没有语法错误，其次力求语义明确，简洁。 蓝图1的大括号太多，书写时容易出错。 蓝图2语法简洁明了，我相信任何会闭包的Coder都能理解。 实现有了蓝图后我们就可以照着这个模样来写代码了，首先分析一下蓝图2。 存在链式操作，显然select函数要返回一个对象，该对象有found和others方法，并且，found方法要返回实例本身。 condition和found的第一个参数类型必须一致，但不一定是string，也可以是int，Object，可用template实现 found第二个参数是lambda表达式，类型是std::function&lt;…&gt;，类似C里面的函数指针，可定义为回调函数。 每个found块对应于switch里的case，是一个kv关系，可用std::map来存储关联。 C++建议模板类的声明和定义必须写在同一个文件里，因此起一个switch.hpp文件： 12345678910111213141516171819202122232425#include &lt;functional&gt;#include &lt;map&gt;template &lt;typename Ty&gt;class Switch &#123; public: Switch()&#123;&#125; explicit Switch(const Ty&amp; target) : target_(target) &#123;&#125; Switch&amp; found(const Ty&amp; _case, const std::function&lt;void(void)&gt;&amp; callback) &#123; reflections_[_case] = callback; return *this; &#125; private: const Ty&amp; target_; std::map&lt;const Ty, std::function&lt;void(void)&gt;&gt; reflections_;&#125;;template &lt;typename Ty&gt;Switch&lt;Ty&gt; select(const Ty&amp; expression) &#123; return Switch&lt;Ty&gt;(expression);&#125; 这么一来就实现了found得链式操作，存储了kv对，全局(也可以在某个命名空间内)select函数是一个简化书写的帮助函数，创建对象后返回该对象的拷贝，实现了如下调用： 12select(std::string("condition")) .found ... 接下来我需要实现查找到对应的target，然后调用它的callback。 增加一个done()方法，该方法被调用意味着结束整个Switch，开始匹配found块，如果没找到，调用others函数(对应default块)： 1234567891011inline void done() &#123; auto kv = reflections_.find(target_); if (kv != reflections_.end()) &#123; // found auto scope = kv-&gt;second; scope(); &#125; else if (has_others_scope_) &#123; // not found, call others others_(); &#125;&#125; std::map的find方法时间复杂度是O(logN)，而原生switch匹配时间复杂度是O(1)，肯定是有很大差距的，但是为了实现switch没有的功能，这点损失也是十分值得的。 others方法如下： 12345inline void others(const Scope&amp; callback) &#123; has_others_scope_ = true; others_ = callback; this-&gt;done();&#125; 当用户调用others方法定义了default块之后，就没必要再调用done了，又可以减少7个字符的书写。 这里has_others_scope_为bool成员；others_是单独存放的lambda表达式成员，为了简化查找，不宜放在reflections_中。 再简化书写，用typedef缩短类型，然后替换原类中相应类型为短类型： 12typedef std::function&lt;void(void)&gt; Scope;typedef std::map&lt;const Ty, Scope&gt; Reflections; 这么一来几乎很完美了，全新的Switch如下： 123456789101112131415161718192021222324252627282930#define printl(line) printf((line)); printf("\n")std::string condition("windows");// match std::stringselect(condition) .found("apple", []() &#123; printl("it's apple"); &#125;) .found("windows", []() &#123; printl("it's windows"); &#125;) .found("linux", []() &#123; printl("it's linux"); &#125;).done();// match intselect(100) .found(10, []() &#123; printl("it's 10"); &#125;) .found(20, []() &#123; printl("it's 20"); &#125;) .others([]() &#123; printl("nothing found"); &#125;);// output// it's windows// nothing found 我想进一步实现自定义class的case，定义一个User类： 1234567891011class User &#123; public: explicit User(int age) : age_(age) &#123;&#125; bool operator&lt;(const User&amp; user) const &#123; return this-&gt;age_ &lt; user.age(); &#125; int age() const &#123; return age_; &#125; private: int age_;&#125;; Switch如下： 123456789User u1(20), u2(22), ux(20); select(ux) .found(u1, []() &#123; printl("it's u1"); &#125;) .found(u2, []() &#123; printl("it's u2"); &#125;).done(); // it's u2 非常有必要说明的是这个重载： 1bool operator&lt;(const User&amp; user) const &#123; return this-&gt;age_ &lt; user.age(); &#125; 返回bool没有问题，但为什么必须是operator&lt;呢，原因在这句： 1auto kv = reflections_.find(target_); std::map&lt;&gt;::find不是通过==进行查找的，而是&lt;，因此必须重载&lt;。 该重载必须被const修饰，原因也是find这句里面，const对象只能调用const方法。 标准库里的实现如下： 123456struct _LIBCPP_TYPE_VIS_ONLY less : binary_function&lt;_Tp, _Tp, bool&gt;&#123; _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY bool operator()(const _Tp&amp; __x, const _Tp&amp; __y) const &#123;return __x &lt; __y;&#125;&#125;; 可以非常明显的看到const和&lt;。 此外我还实现了Switch之间的found块组合，比较简单就不阐述了。 存在的问题常量字符串的转型问题： 123select("condition") .found("case", ...) .done(); 编译器将”condition”理解为const char[10]，数组类型有固定长度，found块的_case参数类型是const char[5]，导致编译错误。原因在于： 1Switch&amp; found(const Ty&amp; _case, const Scope&amp; callback) 这里传递const引用，因此编译器把”case”当做了const char[5]。此时Ty的类型和说好的const char[10]不一致，编译失败。 解决方法是通过std::string来避免数组长度不匹配问题： 123select(std::string("condition")) .found("case", ...) .done(); 希望读者有更好地解决方案。 完整代码这里直接引用我项目里面的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#ifndef PROGRAM_OPTIONS_SWITCH_HPP_#define PROGRAM_OPTIONS_SWITCH_HPP_#include &lt;functional&gt;#include &lt;map&gt;namespace program_options &#123;/*** @brief The Switch template class.* @param Ty The target type.*/template &lt;typename Ty&gt;class Switch &#123; public: typedef std::function&lt;void(void)&gt; Scope; typedef std::map&lt;const Ty, Scope&gt; Reflections; Switch() : has_others_scope_(false) &#123;&#125; explicit Switch(const Ty&amp; target) : target_(target), has_others_scope_(false) &#123;&#125; /** * @brief Create a case block with an expression and a callback function. * @param _case The case expression, variable is allowed. * @param callback The callback function, can be a lambda expression. * @return The current Switch instance. */ Switch&amp; found(const Ty&amp; _case, const Scope&amp; callback) &#123; reflections_[_case] = callback; return *this; &#125; /** * @brief Create a default block with a callback function, * if no cases matched, this block will be called. * @param callback */ inline void others(const Scope&amp; callback) &#123; has_others_scope_ = true; others_ = callback; this-&gt;done(); &#125; /** * @brief Finish the cases, * others() will call this method automatically. */ inline void done() &#123; auto kv = reflections_.find(target_); if (kv != reflections_.end()) &#123; // found auto scope = kv-&gt;second; scope(); &#125; else if (has_others_scope_) &#123; // not found, call others others_(); &#125; &#125; /** * @brief Combine the cases to this Switch from another Switch. * Note that this two Switch should be the same template. * @param _switch Another Switch instance. * @return */ inline Switch&amp; combine(const Switch&amp; _switch) &#123; for (auto kv : _switch.reflections()) &#123; this-&gt;reflections_[kv.first] = kv.second; &#125; return *this; &#125; /** * @brief Return the case-callback pairs. * @return */ inline Reflections reflections() const &#123; return reflections_; &#125; private: const Ty&amp; target_; bool has_others_scope_; Scope others_; Reflections reflections_;&#125;;/** * @brief Define which expression does the Switch match. * @param expression * @return */template &lt;typename Ty&gt;Switch&lt;Ty&gt; select(const Ty&amp; expression) &#123; return Switch&lt;Ty&gt;(expression);&#125;&#125;#endif // PROGRAM_OPTIONS_SWITCH_HPP_ 欢迎各位读者指正。]]></content>
      <tags>
        <tag>tech</tag>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google C++ Style Guide 笔记]]></title>
    <url>%2F2015%2F02%2F23%2Fgoogle-cpp-style-guide-note%2F</url>
    <content type="text"><![CDATA[英文原版: http://google-styleguide.googlecode.com/svn/trunk/cppguide.html头文件每个源文件都要对应一个头文件。例外：单元测试文件和仅包含main的小型源文件。独立头文件以.h结尾的都是应该是独立的，以.inc结尾的仅用作文本包含，所有头文件都必须是独立的。inline和template函数的声明和定义(实现)应该在同一个文件中。Note:这里的独立是指，用户和重构工具可以无特殊限制地包含头文件。define宏保护所有头文件都应该使用#define来防止重复包含。格式如下：头文件路径：foo/src/bar/baz.h&lt;!-- lang: cpp --&gt; #ifndef FOO_BAR_BAZ_H_ #define FOO_BAR_BAZ_H_ ... #endif // FOO_BAR_BAZ_H_ 前置声明前置声明用来避免不必要的include，但有很多缺陷。当使用在一个头文件中已声明的函数时，总是include那个头文件当使用类模板，最好include它的头文件当使用一个一般的class时，可以进行前置声明，但是要小心它可能是不完整或不正确的，不确定时，就include合适的头文件不要为了避免使用include而把数据成员换成指针内联函数仅在函数少于10行时，才可以把函数定义为inline。过度使用inline，实际上会使程序变慢。inline一个非常短的函数可以缩短代码长度，而inline一个很长的函数反而会戏剧性地增大代码长度。小心析构函数，他们的代码通常比表面上的更长，因为存在虚函数和父析构函数调用。虚函数和递归函数不应该被inline。参数顺序顺序应该是：输入，输出输入参数通常是按值，或按const引用传入。输出则是non-const的指针（引用也是指针实现的）。当要新增一个参数时，应该按照上面顺序加入。注意这个规则不是硬性的，可以放宽这个规则以确保一致性。includes的名称和顺序顺序：关联的头文件 —-&gt; 确保编译当前源文件时提前报错，而不牵扯到别人的文件。C库C++库第三方库你的项目头文件每个部分再按字典顺序排列。例如：&lt;!-- lang: cpp --&gt; #include &quot;foo/server/fooserver.h&quot; #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt; #include &lt;hash_map&gt; #include &lt;vector&gt; #include &quot;base/basictypes.h&quot; #include &quot;base/commandlineflags.h&quot; #include &quot;foo/server/bar.h&quot; 系统相关的头文件可用宏来限定，以减小代码和保持本地化。&lt;!-- lang: cpp --&gt; #include &quot;foo/public/fooserver.h&quot; #include &quot;base/port.h&quot; // For LANG_CXX11. #ifdef LANG_CXX11 #include &lt;initializer_list&gt; #endif // LANG_CXX11 作用域命名空间在源文件中鼓励使用匿名命名空间（ namespace {…} ），对于非匿名命名空间则选取它的路径来命名。不要使用using namespace。不要使用inline命名空间。匿名命名空间可以避免链接期的名字冲突：namespace { // This is in a .cc file.// The content of a namespace is not indented.//// This function is guaranteed not to generate a colliding symbol// with other symbols at link time, and is only visible to// callers in this .cc file.bool UpdateInternals(Frobber* f, int newval) {…}} // namespace不要在头文件中使用匿名命名空间。含名称的命名空间在includes，gflags声明和定义，其他命名空间中class的前置声明之后，包裹全部的代码：// In the .h filenamespace mynamespace {// All declarations are within the namespace scope.// Notice the lack of indentation.class MyClass {public:... void Foo(); };} // namespace mynamespace// In the .cc filenamespace mynamespace {// Definition of functions is within scope of the namespace.void MyClass::Foo() {... }} // namespace mynamespace不要在std中声明任何东西，也不要对标准库的class进行前置声明。不要使用using namespace// Forbidden – This pollutes the namespace.using namespace foo;可以在源文件的任意位置，在头文件的函数，方法，class中使用using声明// OK in .cc files.// Must be in a function, method or class in .h files.using ::foo::bar;别名命名空间可以在源文件的任意位置，头文件的namespace内，函数，方法内使用。// Shorten access to some commonly used names in .cc files.namespace fbz = ::foo::bar::baz;// Shorten access to some commonly used names (in a .h file).namespace librarian {// The following alias is available to all files including// this header (in namespace librarian):// alias names should therefore be chosen consistently// within a project.namespace pd_s = ::pipeline_diagnostics::sidetable;inline void my_inline_function() {// namespace alias local to a function (or method). namespace fbz = ::foo::bar::baz; ... }} // namespace librarianNote：尽量避免在公共头文件中使用别名命名空间。不要使用inline命名空间成员类&lt;!-- lang: cpp --&gt; class Foo { private: // Bar is a member class, nested within Foo. class Bar { ... }; }; 不要把成员类公开，除非他们确实是这个接口的一部分。非成员，静态成员和全局函数最好在命名空间中使用非成员函数，或使用静态成员函数，而不要或很少使用全局函数。非成员函数不应该依赖于外部变量，并且应该总处于一个命名空间中。那些仅仅用来集结静态成员函数，且没有共享静态数据的类，应该用命名空间取而代之。如果必须要使用非成员函数并且只在当前这个源文件中使用，则用一个匿名命名空间或static修饰来限制它的作用域。局部变量将一个函数中的变量放到尽可能有限的作用域内，并在声明时初始化。&lt;!-- lang: cpp --&gt; int i; i = f(); // Bad -- initialization separate from declaration. int j = g(); // Good -- declaration has initialization. vector&lt;int&gt; v; v.push_back(1); // Prefer initializing using brace initialization. v.push_back(2); vector&lt;int&gt; v = {1, 2}; // Good -- v starts initialized. 一些供if,while,for使用的变量应该在statement处声明。&lt;!-- lang: cpp --&gt; while (const char* p = strchr(str, &apos;/&apos;)) str = p + 1; 一点注意：如果是变量是一个对象，构造函数将在每次进入作用域时被执行，析构函数将在每次离开作用域时被执行。&lt;!-- lang: cpp --&gt; // Inefficient implementation: for (int i = 0; i &lt; 1000000; ++i) { Foo f; // My ctor and dtor get called 1000000 times each. f.DoSomething(i); } // 对象放在外面更高效 Foo f; // My ctor and dtor get called once each. for (int i = 0; i &lt; 1000000; ++i) { f.DoSomething(i); } 静态和全局变量类的静态或全局变量是禁止使用的。然而constexpr的变量是被允许的，因为他们不会动态初始化或销毁。静态存储的对象，包括全局变量，静态变量，静态类成员变量以及函数内静态变量，必须是Plain Old Data(POD)。只有int,char,float,pointer,或者arrays/structs属于POD。静态vector应该用C数组代替，静态string应该用const char []代替。如果需要使用静态或全局类对象，考虑初使用它的指针类型（不会被order-of-destrctor释放掉），注意必须是一个纯的指针，而不是一个智能指针。类构造函数该做的事避免在构造函数中进行复杂初始化，比如那些可能会失败或者进行虚函数调用的步骤。构造函数不应该调用虚函数，或者试图抛出非致命性错误。如果你的对象需要进行重要的初始化工作，考虑使用一个工厂函数或init方法。初始化明确构造函数在具有一个参数的构造函数上使用explicit关键字。因为构造时传入一个参数可能会被编译器当做拷贝构造进行隐式转换。&lt;!-- lang: cpp --&gt; explicit Foo(string name); 除了构造函数的第一个参数外，其他参数都应该指定一个默认值,来防止不期望的类型转换。&lt;!-- lang: cpp --&gt; Foo::Foo(string name, int id = 42) 拷贝构造函数，以及作为其他类的透明包装的类，不应该被explicit修饰。可拷贝和可移动类型可拷贝的例子：std::string可移动但不可拷贝的例子：std::unique_ptr对于一些不需要拷贝操作的类型，提供拷贝操作符可能会产生混淆，无意义或者完全是不正确的。基类的拷贝、赋值操作符是有风险的，他们会导致对象分裂。如果要加入拷贝特性，就要同时定义拷贝构造函数和赋值操作符。如果你的类型可拷贝，但移动操作符更高效，那么就同时定义移动操作。避免给试图被继承的类提供赋值操作符或公开的拷贝/移动构造函数。如果你的基类需要被拷贝，提供一个公开的虚Clone()方法，和一个保护的拷贝构造函数，来使子类能够实现它。如果你不想支持拷贝/移动操作，使用 = delete 来明确地禁用它们。委托和继承构造函数委托构造的例子：&lt;!-- lang: cpp --&gt; X::X(const string&amp; name) : name_(name) { ... } X::X() : X(&quot;&quot;) { } 继承构造的例子：&lt;!-- lang: cpp --&gt; class Base { public: Base(); Base(int n); Base(const string&amp; s); ... }; class Derived : public Base { public: using Base::Base; // Base&apos;s constructors are redeclared here. }; 在能减少冗余和改善可读性的前提下使用委托和继承。结构体 vs. 类struct仅在存储数据时使用，否则使用class。struct可以直接访问字段而不通过方法调用。struct内的方法只用来设置数据成员。如果需要更多地函数支持，class更合适，如果不确定用哪个，就用class。注意struct和class内的成员变量具有不同的命名方式。继承组合通常比继承更合适。当使用继承时，指明为public。实际上，继承在C++中主要应用于两个方面：实现继承（最普通意义上的继承）接口继承（仅继承方法，实现接口）所有的继承都应当是public的，如果你需要用private继承，你就应该保存一份基类的成员实例来替代private继承（达到private的效果）。不要过度使用实现继承，因为代码实现被分散于子类和基类。继承应该被限定为”is-a”的关系，即”子类是基类的特例”。如果你的类中有虚函数，那么你的析构函数也必须是virtual。数据成员应该是private的。多继承仅有很少的多重实现继承是有用的。你通常可以找到一个不同的，更明确地，更干净的解决方案。多继承仅允许在父类都是纯接口的时候使用。接口一个类是纯接口的条件：只有public的纯虚函数（= 0）和静态方法（析构函数除外）不含非静态的数据成员不需要构造函数，如果有，一定没有参数以及被声明为protected如果它是子类，它的父类也必须符合这些条件操作符重载不要重载那些很少使用的，特殊的操作符。不要给用户字面值定义操作符。为了使类模板函数正常工作，你或许需要定义操作符。虽然操作符重载可以使代码更简洁，但它有以下几个缺点：它会让我们以为原本高代价的操作是划算的不便于寻找到底调用了那个方法，例如Equals()要比==更方便查找许多操作符对指针也有效，很容易出bug。例如：Foo + 4和 &amp;Foo + 4截然不同用户字面值允许创造出新的句法，即使经验丰富的C++程序员也会觉得陌生重载也会出现意想不到的后果，比如，一个类重载了一元operator&amp;，它将不能安全的被前置声明。一般而言，不要定义操作符重载。需要时你可以用普通的函数例如Equals()来替代。不要重载operator””，即用户字面值。当然，有些情况下可以进行重载，例如对标准C++库：&lt;!-- lang: cpp --&gt; operator&lt;&lt;(ostream&amp;, const T&amp;) for logging 访问控制使数据成员是private的，然后提供访问函数（getter/setter）来访问它们。例如：一个叫做foo_的变量有一个foo()访问函数，或者set_foo()。例外：static const 数据成员(kFoo)不应该是private。访问器的定义通常是内联在头文件中的。声明顺序public: protected: private: ；方法在数据成员之前。每个区块内的顺序：typedef &amp; enum常量（包括静态数据成员）构造函数析构函数方法（包括静态方法）数据成员（静态数据除外）友元函数总是在private内声明。在源文件中的方法定义应该和声明顺序尽量保持一致。写出短小的函数书写短小的，清晰地函数。如果一个函数超过40行，可以考虑是否可以在不改变程序结构的前提下进行分割。Google经验技巧所有权和智能指针最好使用std::unique_ptr来使所有权传递更明确：&lt;!-- lang: cpp --&gt; std::unique_ptr&lt;Foo&gt; FooFactory(); void FooConsumer(std::unique_ptr&lt;Foo&gt; ptr); 在没有一个非常好的理由的前提下，不要把你的代码设计为共享所有权。不要再新的代码中使用scoped_ptr除非为了适配老版本的C++。不要使用std::auto_ptr，用std::unique_ptr代替。cpplint使用cpplint.py来检查风格错误。其他C++特性引用参数所有按引用传递的参数必须被const修饰。&lt;!-- lang: cpp --&gt; void Foo(const string &amp;in, string *out); 有些情况下用const T* 做输入参数比const T&amp;好：要传递一个空指针该函数将指针或引用保存到输入参数记住大多数时候输入参数都写为const T&amp;。右值引用右值引用只在move构造函数以及move赋值操作符定义时使用，不要使用std::forward。在move构造函数中应用右值引用，可以实现移动数据而不是复制数据，例如：auto v2(std::move(v1))会把v1数据移动到v2中，而不是完全复制一遍，可用于性能提升。无论参数是否为临时对象，右值引用都可以经行参数传递。右值引用对于没有明确定义拷贝操作，但你仍想向其传递参数的函数有很大的意义，比如向容器内存放数据而不需要copy。std::move对高效使用一些标准库类型，例如std::unique_ptr很有必要。右值引用作为C++11的新特性，还没有被广泛得理解和应用。函数重载如果一个函数依靠参数类型的不同来进行重载，读者可能必须理解C++的复杂匹配机制来确定接下来会发生什么。如果你像重载一个函数，考虑给出一些信息对参数进行限定，例如使用AppendString(), AppendInt()而不仅仅是Append()。默认参数除了下面几个情形，我们不允许默认函数参数。如果合适的话，请用函数重载在替代。当默认参数做函数指针时容易使人混淆，因为函数签名常常不会匹配调用。加入默认参数时会改变函数的类型，这样会在获取它的地址时造成一些问题。使用函数重载可以避免这个问题。一些例外：当一个静态函数出现在源文件中时，由于本地化的缘故上述规则不再适用。另外，默认参数可在构造函数中使用，上述规则也不适用，因为不可能获取到构造函数的地址。还有一个例外是默认参数用来模拟变长数组时，例如：&lt;!-- lang: cpp --&gt; // Support up to 4 params by using a default empty AlphaNum. string StrCat(const AlphaNum &amp;a, const AlphaNum &amp;b = gEmptyAlphaNum, const AlphaNum &amp;c = gEmptyAlphaNum, const AlphaNum &amp;d = gEmptyAlphaNum); 变长数组和alloca()我们不允许使用变长数组或者alloca()变长数组和alloca()并不是标准C++的一部分。更重要的是，他会在栈空间中分配大量的空间，可能会触发内存覆盖的bug：在我机器上运行的好好的，在生产环境却死掉了。。友元友元通常都应该被定义在同一个文件中。通常会定义一个FooBuilder作为Foo的一个友元。在创建一个单元测试的时候，使用友元很管用。例外我们不使用C++的exceptions。运行时类型信息（RTTI）避免使用RTTI。在运行时查询对象的类型可以说是一个错误的设计问题。类型转换使用C++的类型转换如static_cast()。而不要用C-style的int y = (int)x或者int y = int(x)。使用const_cast来除去const限定，只在你知道你在做什么的情况下，使用reinterpret_cast来做不安全的指针转换。流流仅用于日志。使用类似printf的形式来代替流。前加和前减在迭代器和其他模板对象上使用前加或前减。当表达式的返回值被忽略时，++i比i++更高效。如果i是一个迭代器，由于i++的复制，开销很大。const只要讲得通，随时随地使用const。C++11中的constexpr是更好的选择。如果一个函数不会修改按引用传递，指针传递的参数，那么这个参数应该是const。如果可以，把方法声明为const。访问器应该总是const的。其他方法如果不修改任何数据成员，不调用任何非const方法，不返回非const指针或非const引用，也应该修饰为const。数据成员在构造函数执行之后不会被修改，应该声明为const。const应该放在哪儿？&lt;!-- lang: cpp --&gt; int const *foo; const int* foo; 把const放在第一位具有更好地可读性，因为它符合英语的习惯：形容词（const），然后是名词（int）。constexpr在C++11中，可以使用constexpr来定义真实地常量或者确保常量初始化。整形&lt;stdint.h&gt;中定义了一些不同长度的整形：int16_t, uint32_t, int64_t 等等。你应该总是使用这些整形，特别是你需要保证整形的长度时。当我们认为一个整数”比较大”时，用int64_t。你不应该使用无符号整形，如uint32_t，除非有一个合理的原因。特别的，不要认为使用了无符号类型它就不会是负数，使用断言来检验正负。如果你需要接收一个容器的大小，确保你的类型能够容纳这个数字，否则使用一个更大的类型。注意整形转换、类型提升可能会导致非预期行为。关于无符号整形&lt;!-- lang: cpp --&gt; for (unsigned int i = foo.Length()-1; i &gt;= 0; --i) ... 这将是一个死循环，因为unsigned int 和 int 比较。因此使用断言来证明非负。不要使用无符号类型来表示非负数。预处理宏最好使用内联函数、枚举和const量代替宏。在使用宏之前，考虑是否有非宏的解决方案。如果你使用了宏，应该注意：不要在头文件中定义宏使用前正确定义它，使用后undef它不要仅仅是为了替换为自己的而undef一个宏，应该取一个唯一的新名字最好不要用##来生成函数、类、变量名0 、nullptr、NULL用0表示整形，0.0表示实数、nullptr（或NULL）表示指针，’\0’表示字符。特别在一些情况下，sizeof(NULL)和sizeof(0)不同。sizeof最好使用sizeof(varname)而非sizeof(type)。因为当var改变时，sizeof(type)不会改变而sizeof(varname)会跟着改变。&lt;!-- lang: cpp --&gt; Struct data; memset(&amp;data, 0, sizeof(data)); memset(&amp;data, 0, sizeof(Struct)); if (raw_size &lt; sizeof(int)) { LOG(ERROR) &lt;&lt; &quot;compressed record not big enough for count: &quot; &lt;&lt; raw_size; return false; } auto只在类型名十分混乱时使用auto，如果能增加可读性，继续使用完整地类型声明，除了局部变量外不要到处都用auto。不要在文件域，命名空间域，类成员中使用auto。从不对大括号初始化列表使用auto。括号初始化列表一些例子：&lt;!-- lang: cpp --&gt; // Basically the same, ignoring some small technicalities. // You may choose to use either form. vector&lt;string&gt; v = {&quot;foo&quot;, &quot;bar&quot;}; // Usable with &apos;new&apos; expressions. auto p = new vector&lt;string&gt;{&quot;foo&quot;, &quot;bar&quot;}; // A map can take a list of pairs. Nested braced-init-lists work. map&lt;int, string&gt; m = {{1, "one"}, {2, "2"}}; // A braced-init-list can be implicitly converted to a return type. vector&lt;int&gt; test_function() { return {1, 2, 3}; } // Iterate over a braced-init-list. for (int i : {-1, -2, -3}) {} // Call a function using a braced-init-list. void TestFunction2(vector&lt;int&gt; v) {} TestFunction2({1, 2, 3}); 也可以给自己的类型定义初始化列表：&lt;!-- lang: cpp --&gt; class MyType { public: // std::initializer_list references the underlying init list. // It should be passed by value. MyType(std::initializer_list&lt;int&gt; init_list) { for (int i : init_list) append(i); } MyType&amp; operator=(std::initializer_list&lt;int&gt; init_list) { clear(); for (int i : init_list) append(i); } }; MyType m{2, 3, 5, 7}; 在没有使用std::initializer_list的情况下也可以：&lt;!-- lang: cpp --&gt; double d{1.23}; // Calls ordinary constructor as long as MyOtherType has no // std::initializer_list constructor. class MyOtherType { public: explicit MyOtherType(string); MyOtherType(int, string); }; MyOtherType m = {1, &quot;b&quot;}; // If the constructor is explicit, you can&apos;t use the &quot;= {}&quot; form. MyOtherType m{&quot;b&quot;}; 不要给{}使用auto：&lt;!-- lang: cpp --&gt; auto d = {1.23}; // d is a std::initializer_list&lt;double&gt; auto d = double{1.23}; // Good -- d is a double, not a std::initializer_list. lambda表达式在适当的条件下用lambda表达式，不要使用默认的lambda捕获，把所有捕获明确地写出来。如果匿名函数超过了5行，考虑给它起一个名字或者使用一个有名函数代替lambda表达式。C++11合适的时候，用C++11编写的类库。在使用C++11之前，考虑好对其他环境的可移植性。命名规则普遍命名规则函数名，变量名和文件名应该是具有描述性的，而不是缩略的。&lt;!-- lang: cpp --&gt; int price_count_reader; // No abbreviation. int num_errors; // &quot;num&quot; is a widespread convention. int num_dns_connections; // Most people know what &quot;DNS&quot; stands for. int n; // Meaningless. int nerr; // Ambiguous abbreviation. int n_comp_conns; // Ambiguous abbreviation. int wgc_connections; // Only your group knows what this stands for. int pc_reader; // Lots of things can be abbreviated &quot;pc&quot;. int cstmr_id; // Deletes internal letters. 文件名文件名都该是小写的，并且可以包含下划线或者短划线-。如果你的项目没有约定，最好用下划线。一些例子：&lt;!-- lang: cpp --&gt; my_useful_class.cc my-useful-class.cc myusefulclass.cc myusefulclass_test.cc // _unittest and _regtest are deprecated. 不要使用在/usr/include中已近存在的文件名，例如：db.h普遍地，明确你的文件名。例如：http_server_logs.h 比 logs.h 好很多。如果内联函数非常短，应该直接写在头文件中。类型名类型名以大写字母开头，并且每个词开头都是大写的：MyExcitingClass, MyExcitingEnum。&lt;!-- lang: cpp --&gt; // classes and structs class UrlTable { ... class UrlTableTester { ... struct UrlTableProperties { ... // typedefs typedef hash_map&lt;UrlTableProperties *, string&gt; PropertiesMap; // enums enum UrlTableErrors { ... 变量名变量和数据成员都是小写的，单词间有下划线：a_local_variable, a_struct_data_member, a_class_data_member_。&lt;!-- lang: cpp --&gt; string table_name; // OK - uses underscore. string tablename; // OK - all lowercase. string tableName; // Bad - mixed case. 类数据成员，末尾一个下划线：&lt;!-- lang: cpp --&gt; class TableInfo { ... private: string table_name_; // OK - underscore at end. string tablename_; // OK. static Pool&lt;TableInfo&gt;* pool_; // OK. }; 结构体数据成员，末尾没有下划线：&lt;!-- lang: cpp --&gt; struct UrlTableProperties { string name; int num_entries; static Pool&lt;UrlTableProperties&gt;* pool; }; 全局变量，没有一个特定的规则。如果你需要一个规则，考虑给全局变量加上g_前缀，来区分局部变量。常量名在常量之前加上k，例如：const int kDaysInWeek = 7。函数名和变量命名方式相似，但可以是大小写混合：&lt;!-- lang: cpp --&gt; MyExcitingFunction(), MyExcitingMethod(), my_exciting_member_variable(), set_my_exciting_member_variable(). 访问器(get)和修改器(set)应该匹配要访问或修改的那个变量名：&lt;!-- lang: cpp --&gt; class MyClass { public: ... int num_entries() const { return num_entries_; } void set_num_entries(int num_entries) { num_entries_ = num_entries; } private: int num_entries_; }; 命名空间名全为小写，并且尽可能是表示目录结构：google_awesome_project.枚举名&lt;!-- lang: cpp --&gt; enum UrlTableErrors { kOK = 0, kErrorOutOfMemory, kErrorMalformedInput, }; enum AlternateUrlTableErrors { OK = 0, OUT_OF_MEMORY = 1, MALFORMED_INPUT = 2, }; 宏名通常情况下宏不应该被使用，然而它又绝对是需要的，宏名应该全为大写。&lt;!-- lang: cpp --&gt; #define ROUND(x) ... #define PI_ROUNDED 3.0 命名规则的例外如果你在为现存的C/C++代码工作，依据现存的命名方式，例如：&lt;!-- lang: cpp --&gt; bigopen() function name, follows form of open() uint typedef bigpos struct or class, follows form of pos sparse_hash_map STL-like entity; follows STL naming conventions LONGLONG_MAX a constant, as in INT_MAX 注释为你的读者写注释，因为下一个读者也许就是你。注释风格保持//和/**/的一致性，通常//更普遍。文件注释以许可协议（例如：Apache 2.0, BSD, LGPL, GPL）开头，接下来是关于内容的描述。如果你对一个已近存在作者标记的文件进行了修改，请删除作者那一行。不要重复在头文件和源文件中书写注释。类注释每个类定义都应该有一个用于描述它的作用，如何使用的注释：&lt;!-- lang: cpp --&gt; // Iterates over the contents of a GargantuanTable. Sample usage: // GargantuanTableIterator* iter = table-&gt;NewIterator(); // for (iter-&gt;Seek(&quot;foo&quot;); !iter-&gt;done(); iter-&gt;Next()) { // process(iter-&gt;key(), iter-&gt;value()); // } // delete iter; class GargantuanTableIterator { ... }; 函数注释&lt;!-- lang: cpp --&gt; // Returns an iterator for this table. It is the client&apos;s // responsibility to delete the iterator when it is done with it, // and it must not use the iterator once the GargantuanTable object // on which the iterator was created has been deleted. // // The iterator is initially positioned at the beginning of the table. // // This method is equivalent to: // Iterator* iter = table-&gt;NewIterator(); // iter-&gt;Seek(&quot;&quot;); // return iter; // If you are going to immediately seek to another place in the // returned iterator, it will be faster to use NewIterator() // and avoid the extra seek. Iterator* GetIterator() const; 去掉不必要的注释：&lt;!-- lang: cpp --&gt; // Returns true if the table cannot hold any more entries. bool IsTableFull(); 变量注释应该说明这个变量用来干什么，在特定的情况下，需要更多的注释。例如：&lt;!-- lang: cpp --&gt; private: // Keeps track of the total number of entries in the table. // Used to ensure we do not go over the limit. -1 means // that we don&apos;t yet know how many entries the table has. int num_total_entries_; 所有的全局变量都应该给出一个注释，来描述它用来做什么。&lt;!-- lang: cpp --&gt; // The total number of tests cases that we run through in this regression test. const int kNumTestCases = 6; 实现注释一些难懂的，复杂的代码块应该被注释：&lt;!-- lang: cpp --&gt; // Divide result by two, taking into account that x // contains the carry from the add. for (int i = 0; i &lt; result-&gt;size(); i++) { x = (x &lt;&lt; 8) + (*result)[i]; (*result)[i] = x &gt;&gt; 1; x &amp;= 1; } 意义不明显的行末应该空两个字符并给出注释：&lt;!-- lang: cpp --&gt; // If we have enough memory, mmap the data portion too. mmap_budget = max&lt;int64&gt;(0, mmap_budget - index_-&gt;length()); if (mmap_budget &gt;= data_size_ &amp;&amp; !MmapData(mmap_chunk_bytes, mlock)) return; // Error already logged. 如果接下来的几行都有注释，最好排列起来增强可读性：&lt;!-- lang: cpp --&gt; DoSomething(); // Comment here so the comments line up. DoSomethingElseThatIsLonger(); // Two spaces between the code and the comment. { // One space before comment when opening a new scope is allowed, // thus the comment lines up with the following comments and code. DoSomethingElse(); // Two spaces before line comments normally. } vector&lt;string&gt; list{// Comments in braced lists describe the next element .. &quot;First item&quot;, // .. and should be aligned appropriately. &quot;Second item&quot;}; DoSomething(); /* For trailing block comments, one space is fine. */ 当你传递一个空指针，布尔值或者字面整形值时，你应该考虑添加注释来说明他们是什么，或者使你的代码自我注释：&lt;!-- lang: cpp --&gt; bool success = CalculateSomething(interesting_value, 10, false, NULL); // What are these arguments?? versus: bool success = CalculateSomething(interesting_value, 10, // Default base value. false, // Not the first time we&apos;re calling this. NULL); // No callback. Or alternatively, constants or self-describing variables: const int kDefaultBaseValue = 10; const bool kFirstTimeCalling = false; Callback *null_callback = NULL; bool success = CalculateSomething(interesting_value, kDefaultBaseValue, kFirstTimeCalling, null_callback); 切记不要描述代码自身：&lt;!-- lang: cpp --&gt; // Now go through the b array and make sure that if i occurs, // the next element is i+1. ... // Geez. What a useless comment. 标点，拼写和语法完整的句子往往比句子片段更容易理解。TODO 注释使用TODO注释是一个临时的，短期的解决方案，很好的但不是完美的。当你创建一个TODO时，总是给出你的名字：&lt;!-- lang: cpp --&gt; // TODO(kl@gmail.com): Use a &quot;*&quot; here for concatenation operator. // TODO(Zeke) change this to use relations. 弃用注释使用DEPRECATED注释标记一个弃用的接口。在DEPRECATED之后写出你的名字，email地址或其他能标识你的信息。弃用注释必须包含简易的，清楚的指引来帮助使用者修复他们的问题。C++中，你可以将弃用的方法放在内联函数中，然后调用新的接口。格式化行长度一行最多80个字符。一些原始字符串可能会超出80个字符，除了测试外，这样的字符串应该出现在该文件的顶部。#include 语句可能会超过80列。非ascii字符非ascii字符很少出现，但必须使用UTF-8编码。十六进制也可以使用，在那些需要加强可读性的地方更建议使用。你不应该使用C++11提供的char116_t和char32_t，因为他们用于非UTF8得文本。同样的，，你也不应该使用wchar_t，除非你是在用Windows API编写程序。空格和制表符只用空格并且缩进两个字符。函数声明和定义返回类型出现在函数名的同一行，如果能适应，参数也出现在同一行。如果不能适应，折行书写参数表。&lt;!-- lang: cpp --&gt; ReturnType ClassName::FunctionName(Type par_name1, Type par_name2) { DoSomething(); ... } If you have too much text to fit on one line: ReturnType ClassName::ReallyLongFunctionName(Type par_name1, Type par_name2, Type par_name3) { DoSomething(); ... } or if you cannot fit even the first parameter: ReturnType LongClassName::ReallyReallyReallyLongFunctionName( Type par_name1, // 4 space indent Type par_name2, Type par_name3) { DoSomething(); // 2 space indent ... } 需要指出：如果不能把返回类型和函数名放在同一行，请折行如果折行书写了返回类型，不要缩进左圆括号始终和函数名处在同一行括号和参数之间没有空格左花括号始终和最后一个参数在同一行右花括号在最后一行或者和左花括号在同一行右小括号和左花括号之间有一个空格所有参数都改命名，无论是在头文件，或者源文件中如果可能，所有参数都要对齐默认缩进2个字符折行的参数有4个字符缩进如果一些参数未使用，在函数声明处注释出来：&lt;!-- lang: cpp --&gt; // Always have named parameters in interfaces. class Shape { public: virtual void Rotate(double radians) = 0; }; // Always have named parameters in the declaration. class Circle : public Shape { public: virtual void Rotate(double radians); }; // Comment out unused named parameters in definitions. void Circle::Rotate(double /*radians*/) {} // Bad - if someone wants to implement later, it&apos;s not clear what the // variable means. void Circle::Rotate(double) {} lambda表达式像其他函数一样格式化参数和函数体，捕获表如其他逗号分隔的列表。&lt;!-- lang: cpp --&gt; int x = 0; auto add_to_x = [&amp;x](int n) { x += n; }; 简短的lambda表达式应该作为函数参数内联：&lt;!-- lang: cpp --&gt; std::set&lt;int&gt; blacklist = {7, 8, 9}; std::vector&lt;int&gt; digits = {3, 9, 1, 8, 4, 7, 1}; digits.erase(std::remove_if(digits.begin(), digits.end(), [&amp;blacklist](int i) { return blacklist.find(i) != blacklist.end(); }), digits.end()); 函数调用将函数调用写在一行，用小括号包裹参数；或者将参数置于新行，用4个空格缩进。使用最小的行数。如下格式：&lt;!-- lang: cpp --&gt; bool retval = DoSomething(argument1, argument2, argument3); 如果参数太多，折行书写，括号左右不要有空格。&lt;!-- lang: cpp --&gt; bool retval = DoSomething(averyveryveryverylongargument1, argument2, argument3); if (...) { ... ... if (...) { DoSomething( argument1, argument2, // 4 space indent argument3, argument4); } 花括号初始化列表格式&lt;!-- lang: cpp --&gt; // Examples of braced init list on a single line. return {foo, bar}; functioncall({foo, bar}); pair&lt;int, int&gt; p{foo, bar}; // When you have to wrap. SomeFunction( {&quot;assume a zero-length name before {&quot;}, some_other_function_parameter); SomeType variable{ some, other, values, {&quot;assume a zero-length name before {&quot;}, SomeOtherType{ &quot;Very long string requiring the surrounding breaks.&quot;, some, other values}, SomeOtherType{&quot;Slightly shorter string&quot;, some, other, values}}; SomeType variable{ &quot;This is too long to fit all in one line&quot;}; MyType m = { // Here, you could also break before {. superlongvariablename1, superlongvariablename2, {short, interior, list}, {interiorwrappinglist, interiorwrappinglist2}}; 条件语句最好括号内无空格。if和else关键字属于分立的行中。&lt;!-- lang: cpp --&gt; if(condition) { // Bad - space missing after IF. if (condition){ // Bad - space missing before {. if(condition){ // Doubly bad. if (condition) { // Good - proper space after IF and before {. 简短的条件块可以写在一行，如果能强化可读性。&lt;!-- lang: cpp --&gt; if (x == kFoo) return new Foo(); if (x == kBar) return new Bar(); 如果含有else块，则不允许写在一行：&lt;!-- lang: cpp --&gt; // Not allowed - IF statement on one line when there is an ELSE clause if (x) DoThis(); else DoThat(); 一般而言，单行条件语句不需要花括号，如果你喜欢也可以加上，特别是在循环中存在复杂的条件时，使用花括号可增加可读性。有些项目还要求if块必须含有完整地括号对。然而，if-else一部分使用了花括号，那么所有块都必须使用：&lt;!-- lang: cpp --&gt; // Not allowed - curly on IF but not ELSE if (condition) { foo; } else bar; // Not allowed - curly on ELSE but not IF if (condition) foo; else { bar; } // Curly braces around both IF and ELSE required because // one of the clauses used braces. if (condition) { foo; } else { bar; } 循环和选择语句switch块必须包含default，如果default永不会被执行，则写一个assert：&lt;!-- lang: cpp --&gt; switch (var) { case 0: { // 2 space indent ... // 4 space indent break; } case 1: { ... break; } default: { assert(false); } } 空的case块用花括号括起来。单语句循环，花括号可以省略，空循环用花括号括起来或者写continue，而不仅仅是分号。&lt;!-- lang: cpp --&gt; while (condition) { // Repeat test until it returns false. } for (int i = 0; i &lt; kSomeNumber; ++i) {} // Good - empty body. while (condition) continue; // Good - continue indicates no logic. while (condition); // Bad - looks like part of do/while loop. 指针和引用表达式句号和箭头周围无空格：&lt;!-- lang: cpp --&gt; x = *p; p = &amp;x; x = r.y; x = r-&gt;y; 当声明一个指针类型变量时，保证星号两侧仅有一个空格：&lt;!-- lang: cpp --&gt; // These are fine, space preceding. char *c; const string &amp;str; // These are fine, space following. char* c; // but remember to do &quot;char* c, *d, *e, ...;&quot;! const string&amp; str; char * c; // Bad - spaces on both sides of * const string &amp; str; // Bad - spaces on both sides of &amp; 布尔表达式当一个布尔表达式超过标准行长度(80)时，保证折行书写的一致性。&lt;!-- lang: cpp --&gt; if (this_one_thing &gt; this_other_thing &amp;&amp; a_third_thing == a_fourth_thing &amp;&amp; yet_another &amp;&amp; last_one) { ... } 返回值不要给return语句加上括号。仅在返回一个逻辑表达式的时候加括号。&lt;!-- lang: cpp --&gt; return result; // No parentheses in the simple case. // Parentheses OK to make a complex expression more readable. return (some_long_condition &amp;&amp; another_condition); return (value); // You wouldn&apos;t write var = (value); return(result); // return is not a function! 变量和数组初始化可以选择=，()或者{}。下面都是正确的：&lt;!-- lang: cpp --&gt; int x = 3; int x(3); int x{3}; string name = &quot;Some Name&quot;; string name(&quot;Some Name&quot;); string name{&quot;Some Name&quot;}; 当心{}会调用std::initializer_list 构造函数。为了避免这个问题，使用()：&lt;!-- lang: cpp --&gt; vector&lt;int&gt; v(100, 1); // A vector of 100 1s. vector&lt;int&gt; v{100, 1}; // A vector of 100, 1. 预处理指令总是在一行的开头书写，无论是不是在代码块内：&lt;!-- lang: cpp --&gt; // Good - directives at beginning of line if (lopsided_score) { #if DISASTER_PENDING // Correct -- Starts at beginning of line DropEverything(); # if NOTIFY // OK but not required -- Spaces after # NotifyClient(); # endif #endif BackToNormal(); } // Bad - indented directives if (lopsided_score) { #if DISASTER_PENDING // Wrong! The &quot;#if&quot; should be at beginning of line DropEverything(); #endif // Wrong! Do not indent &quot;#endif&quot; BackToNormal(); } 类格式化public,protected,private前面有一个空格：&lt;!-- lang: cpp --&gt; class MyClass : public OtherClass { public: // Note the 1 space indent! MyClass(); // Regular 2 space indent. explicit MyClass(int var); ~MyClass() {} void SomeFunction(); void SomeFunctionThatDoesNothing() { } void set_some_var(int var) { some_var_ = var; } int some_var() const { return some_var_; } private: bool SomeInternalFunction(); int some_var_; int some_other_var_; }; 注意：基类名和子类名放在一行除了第一个public，其他关键字前需要空一行，这个规则在小型类中可选。这些关键字下面不要有空行构造函数初始化列表初始化列表可以在一行内，也可以折行，前面缩进4个字符：&lt;!-- lang: cpp --&gt; // When it all fits on one line: MyClass::MyClass(int var) : some_var_(var), some_other_var_(var + 1) {} or // When it requires multiple lines, indent 4 spaces, putting the colon on // the first initializer line: MyClass::MyClass(int var) : some_var_(var), // 4 space indent some_other_var_(var + 1) { // lined up ... DoSomething(); ... } 命名空间格式命名空间内的内容不缩进。&lt;!-- lang: cpp --&gt; namespace { void foo() { // Correct. No extra indentation within namespace. ... } } // namespace Do not indent within a namespace: namespace { // Wrong. Indented when it should not be. void foo() { ... } } // namespace 水平空格水平空格依赖于位置，不要行末添加空格。&lt;!-- lang: cpp --&gt; void f(bool b) { // Open braces should always have a space before them. ... int i = 0; // Semicolons usually have no space before them. // Spaces inside braces for braced-init-list are optional. If you use them, // put them on both sides! int x[] = { 0 }; int x[] = {0}; // Spaces around the colon in inheritance and initializer lists. class Foo : public Bar { public: // For inline function implementations, put spaces between the braces // and the implementation itself. Foo(int b) : Bar(), baz_(b) {} // No spaces inside empty braces. void Reset() { baz_ = 0; } // Spaces separating braces from implementation. ... 循环和条件，&lt;!-- lang: cpp --&gt; if (b) { // Space after the keyword in conditions and loops. } else { // Spaces around else. } while (test) {} // There is usually no space inside parentheses. switch (i) { for (int i = 0; i &lt; 5; ++i) { // Loops and conditions may have spaces inside parentheses, but this // is rare. Be consistent. switch ( i ) { if ( test ) { for ( int i = 0; i &lt; 5; ++i ) { // For loops always have a space after the semicolon. They may have a space // before the semicolon, but this is rare. for ( ; i &lt; 5 ; ++i) { ... // Range-based for loops always have a space before and after the colon. for (auto x : counts) { ... } switch (i) { case 1: // No space before colon in a switch case. ... case 2: break; // Use a space after a colon if there&apos;s code after it. 操作符，&lt;!-- lang: cpp --&gt; // Assignment operators always have spaces around them. x = 0; // Other binary operators usually have spaces around them, but it&apos;s // OK to remove spaces around factors. Parentheses should have no // internal padding. v = w * x + y / z; v = w*x + y/z; v = w * (x + z); // No spaces separating unary operators and their arguments. x = -5; ++x; if (x &amp;&amp; !y) ... 模板和类型转换，&lt;!-- lang: cpp --&gt; // No spaces inside the angle brackets (&lt; and &gt;), before // &lt;, or between &gt;( in a cast vector&lt;string&gt; x; y = static_cast&lt;char*&gt;(x); // Spaces between type and pointer are OK, but be consistent. vector&lt;char *&gt; x; set&lt;list&lt;string&gt;&gt; x; // Permitted in C++11 code. set&lt;list&lt;string&gt; &gt; x; // C++03 required a space in &gt; &gt;. // You may optionally use symmetric spacing in &lt; &lt;. set&lt; list&lt;string&gt; &gt; x; 纵向空格使纵向空格最小化。当你没必要时，不要留很多空行。特别的，在函数间不要留超过一行或两行的空白。函数开始不要有空行，函数结束也不要有空行。基本原则：一个屏幕上有越多的代码，就越容易理解程序的控制流程。当然，可读性也很重要。以上规则的例外情况现存的不一致代码你可能会在不符合本规则的代码上工作，为了保持一致性，你不应该生搬硬套这个规则。Windows代码不要使用匈牙利命名法，例如 iNum。使用上面介绍的命名规则。Windows定义了许多自己的类型，如DWORD，HANDLE等等。即便这样，你也应该使用你熟知的C++类型，例如：const TCHAR * 来代替LPCTSTR。当使用Microsoft Visual C++编译时，将编译器设置3或以上的警告等级，并把所有警告视为错误。不要使用#pragma once。使用第一个介绍的头文件保护策略。实际上，不要使用任何非标准的扩展指令，像#pragma和declspec，除非你必须使用。允许使用declspec(dllimport) 和 __declspec(dllexport)。当然，你必须通过DLLIMPORT和DLLEXPORT宏来间接使用它们。上面的一些规则在Windows上不适用：禁止多重实现继承。在使用COM和一些ATL/WTL类时，多重继承是必要的。不使用exception。在ATL和一些Visual C++的STL中使用了exception。使用ATL时，你应该定义_ATL_NO_EXCEPTIONS来禁用异常。使用预编译头文件的一贯方法是包含StdAfx.h或者precompile.h。你应该避免手动包含预编译头文件，使用/FI编译器选项来自动包含这个文件。资源头文件resource.h，仅包含宏，不需要套用本规则。最后的话符合常识以及保持一致性。在编辑代码之前，花几分钟看看当前代码的编码风格。并与之保持一致的风格。]]></content>
      <tags>
        <tag>tech</tag>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CMake官方Tutorial中英对照翻译]]></title>
    <url>%2F2015%2F01%2F08%2Fcmake-tutorial-translation%2F</url>
    <content type="text"><![CDATA[CMake Tutorial原版英文Tutorial：http://www.cmake.org/cmake-tutorial/Step1-Step7的源代码及CMakeLists：http://public.kitware.com/cgi-bin/viewcvs.cgi/CMake/Tests/Tutorial/Below is a step-by-step tutorial covering common build system issuesthat CMake helps to address. Many of these topics have been introducedin Mastering CMake as separate issues but seeing how they all worktogether in an example project can be very helpful. This tutorial canbe found in the Tests/Tutorial directory of the CMake source codetree. Each step has its own subdirectory containing a complete copy ofthe tutorial for that step下面是涵盖CMake解决常见构建系统问题的一个手把手教程。通过单独的例子，阐述了CMake是如何协同工作的，这将会对你十分有帮助。这个教程可以在CMake源代码树的Test/Tutorial目录下找到。每个步骤有各自的子目录，且包含了一份关于这个步骤的完整教程。A Basic Starting Point (Step1) 简单的开始The most basic project is an executable built from source code files.For simple projects a two line CMakeLists file is all that isrequired. This will be the starting point for our tutorial. TheCMakeLists file looks like:最基本的工程是从源代码文件构建出可执行程序。对于简单的工程而言，一个两行的CMakeLists文件已经足够了。这将会是我们教程开始的第一步。CMakeLists文件看起来像这样：123456cmake_minimum_required (VERSION 2.6)project (Tutorial)add_executable(Tutorial tutorial.cxx) Note that this example uses lower case commands in the CMakeListsfile. Upper, lower, and mixed case commands are supported by CMake.The source code for tutorial.cxx will compute the square root of anumber and the first version of it is very simple, as follows: 注意到这个例子在CMakeLists中用的是小写命令。无论是大写、小写、还是混合大小写，CMake都支持。源代码文件tutorial.cxx将计算一个数的平方根，第一个版本十分简单： &lt;!-- lang: cpp --&gt; // A simple program that computes the square root of a number #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;math.h&gt; int main (int argc, char *argv[]) { if (argc &lt; 2) { fprintf(stdout,&quot;Usage: %s number\n&quot;,argv[0]); return 1; } double inputValue = atof(argv[1]); double outputValue = sqrt(inputValue); fprintf(stdout,&quot;The square root of %g is %g\n&quot;, inputValue, outputValue); return 0; } Adding a Version Number and Configured Header File 添加一个版本号和用于配置的头文件 The first feature we will add is to provide our executable and projectwith a version number. While you can do this exclusively in the sourcecode, doing it in the CMakeLists file provides more flexibility. Toadd a version number we modify the CMakeLists file as follows: 我们将为可执行程序和工程提供一个版本号作为第一个特性。当然你可以在源代码中专门这样做，但是使用CMakeLists文件将更加灵活。为了添加一个版本号，我们修改CMakeLists文件如下： &lt;!-- lang: shell --&gt; cmake_minimum_required (VERSION 2.6) project (Tutorial) # The version number. set (Tutorial_VERSION_MAJOR 1) set (Tutorial_VERSION_MINOR 0) # configure a header file to pass some of the CMake settings # to the source code configure_file ( &quot;${PROJECT_SOURCE_DIR}/TutorialConfig.h.in&quot; &quot;${PROJECT_BINARY_DIR}/TutorialConfig.h&quot; ) # add the binary tree to the search path for include files # so that we will find TutorialConfig.h include_directories(&quot;${PROJECT_BINARY_DIR}&quot;) # add the executable add_executable(Tutorial tutorial.cxx) Since the configured file will be written into the binary tree we mustadd that directory to the list of paths to search for include files.We then create a TutorialConfig.h.in file in the source tree with thefollowing contents: 由于配置文件将被写入二进制树，我们必须要在路径列表中添加目录以搜索包含文件。然后我们在源代码树中添加TutorialConfig.h.in文件： &lt;!-- lang: cpp --&gt; // the configured options and settings for Tutorial #define Tutorial_VERSION_MAJOR @Tutorial_VERSION_MAJOR@ #define Tutorial_VERSION_MINOR @Tutorial_VERSION_MINOR@ When CMake configures this header file the values for@Tutorial_VERSION_MAJOR@ and @Tutorial_VERSION_MINOR@ will be replacedby the values from the CMakeLists file. Next we modify tutorial.cxx toinclude the configured header file and to make use of the versionnumbers. The resulting source code is listed below. CMake在配置过程中，将从CMakeLists文件中找到并替换头文件中的@Tutorial_VERSION_MAJOR@和@Tutorial_VERSION_MINOR@。之后我们修改tutorial.cxx，使它包含配置头文件，然后利用版本号。最终的源代码如下： &lt;!-- lang: cpp --&gt; // A simple program that computes the square root of a number #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;math.h&gt; #include &quot;TutorialConfig.h&quot; int main (int argc, char *argv[]) { if (argc &lt; 2) { fprintf(stdout,&quot;%s Version %d.%d\n&quot;, argv[0], Tutorial_VERSION_MAJOR, Tutorial_VERSION_MINOR); fprintf(stdout,&quot;Usage: %s number\n&quot;,argv[0]); return 1; } double inputValue = atof(argv[1]); double outputValue = sqrt(inputValue); fprintf(stdout,&quot;The square root of %g is %g\n&quot;, inputValue, outputValue); return 0; } The main changes are the inclusion of the TutorialConfig.h header fileand printing out a version number as part of the usage message. 主要的改变是添加了TutorialConfig.h头文件以及在使用帮助中打印出了版本号。 Adding a Library (Step 2) 添加一个库 Now we will add a library to our project. This library will containour own implementation for computing the square root of a number. Theexecutable can then use this library instead of the standard squareroot function provided by the compiler. For this tutorial we will putthe library into a subdirectory called MathFunctions. It will have thefollowing one line CMakeLists file: 现在我们将为工程添加一个库。这个库将包含计算一个数的平方根的实现代码。可执行程序可以使用这个库，来替代编译器提供的标准平方根函数。在这个教程中，我们将把库放进一个叫做MathFunctions的子目录中。CMakeLists文件将包含这样一行： &lt;!-- lang: shell --&gt; add_library(MathFunctions mysqrt.cxx) The source file mysqrt.cxx has one function called mysqrt thatprovides similar functionality to the compiler’s sqrt function. Tomake use of the new library we add an add_subdirectory call in the toplevel CMakeLists file so that the library will get built. We also addanother include directory so that the MathFunctions/mysqrt.h headerfile can be found for the function prototype. The last change is toadd the new library to the executable. The last few lines of the toplevel CMakeLists file now look like: 源代码文件mysqrt.cxx有一个叫做mysqrt的函数，提供了一个类似于编译器sqrt函数的功能。为了能利用这个新库，我们在CMakeLists文件的顶部添加一个add_subdirectory调用来使之能够被构建。同时，我们也添加一个包含目录使MathFunctions/mysqrt.h头文件提供函数原型。最后一个改变是给可执行程序添加新库。CMakeLists文件的最后几行看起来像这样： &lt;!-- lang: shell --&gt; include_directories (&quot;${PROJECT_SOURCE_DIR}/MathFunctions&quot;) add_subdirectory (MathFunctions) # add the executable add_executable (Tutorial tutorial.cxx) target_link_libraries (Tutorial MathFunctions) Now let us consider making the MathFunctions library optional. In thistutorial there really isn’t any reason to do so, but with largerlibraries or libraries that rely on third party code you might wantto. The first step is to add an option to the top level CMakeListsfile. 现在让我们考虑使MathFunctions库可选。这个教程中确实没有任何理由这样做，但是对于更大的库或依赖于第三方代码的库来说，你可能更愿意这样做。第一步是在CMakeLists中添加一个选项： &lt;!-- lang: shell --&gt; # should we use our own math functions? option (USE_MYMATH &quot;Use tutorial provided math implementation&quot; ON) This will show up in the CMake GUI with a default value of ON that theuser can change as desired. This setting will be stored in the cacheso that the user does not need to keep setting it each time they runCMake on this project. The next change is to make the build andlinking of the MathFunctions library conditional. To do this we changethe end of the top level CMakeLists file to look like the following: 这将在CMake GUI中默认显示为ON，这样使用者可以根据需要来改变它。这个配置将被保存在缓存中，这样使用者不必在工程中使用CMake时每次都去配置它。下一个改变是使构建和链接MathFunctions库有条件化。为了达到目的我们改变CMakeLists文件如下： &lt;!-- lang: shell --&gt; # add the MathFunctions library? # if (USE_MYMATH) include_directories (&quot;${PROJECT_SOURCE_DIR}/MathFunctions&quot;) add_subdirectory (MathFunctions) set (EXTRA_LIBS ${EXTRA_LIBS} MathFunctions) endif (USE_MYMATH) # add the executable add_executable (Tutorial tutorial.cxx) target_link_libraries (Tutorial ${EXTRA_LIBS}) This uses the setting of USE_MYMATH to determine if the MathFunctionsshould be compiled and used. Note the use of a variable (EXTRA_LIBS inthis case) to collect up any optional libraries to later be linkedinto the executable. This is a common approach used to keep largerprojects with many optional components clean. The correspondingchanges to the source code are fairly straight forward and leave uswith: 它使用了USE_MYMATH设置来决定MathFunctions是否应该被编译和使用。注意变量EXTRA_LIBS（本例中）用来收集接下来将被链接到可执行程序中的可选库。这是一个保持大型工程和许多可选组件干净的常用方法。在源代码中的相应改变非常简单： &lt;!-- lang: cpp --&gt; // A simple program that computes the square root of a number #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;math.h&gt; #include &quot;TutorialConfig.h&quot; #ifdef USE_MYMATH #include &quot;MathFunctions.h&quot; #endif int main (int argc, char *argv[]) { if (argc &lt; 2) { fprintf(stdout,&quot;%s Version %d.%d\n&quot;, argv[0], Tutorial_VERSION_MAJOR, Tutorial_VERSION_MINOR); fprintf(stdout,&quot;Usage: %s number\n&quot;,argv[0]); return 1; } double inputValue = atof(argv[1]); #ifdef USE_MYMATH double outputValue = mysqrt(inputValue); #else double outputValue = sqrt(inputValue); #endif fprintf(stdout,&quot;The square root of %g is %g\n&quot;, inputValue, outputValue); return 0; } In the source code we make use of USE_MYMATH as well. This is providedfrom CMake to the source code through the TutorialConfig.h.inconfigured file by adding the following line to it: 在源代码中我们利用了USE_MYMATH。它是由TutorialConfig.h.in文件通过CMake提供的： &lt;!-- lang: cpp --&gt; #cmakedefine USE_MYMATH Installing and Testing (Step 3) 安装和测试 For the next step we will add install rules and testing support to ourproject. The install rules are fairly straight forward. For theMathFunctions library we setup the library and the header file to beinstalled by adding the following two lines to MathFunctions’CMakeLists file: 下一步我们将给工程添加安装规则和测试支持。安装规则相当简单。 对于MathFunctions库，我们通过在MathFunction的CMakeLists文件中添加下面两行，来使它的库和头文件可以被安装： &lt;!-- lang: shell --&gt; install (TARGETS MathFunctions DESTINATION bin) install (FILES MathFunctions.h DESTINATION include) For the application the following lines are added to the top levelCMakeLists file to install the executable and the configured headerfile: 对于应用程序，在CMakeLists中添加下面的命令来安装可执行程序和配置文件： &lt;!-- lang: shell --&gt; # add the install targets install (TARGETS Tutorial DESTINATION bin) install (FILES &quot;${PROJECT_BINARY_DIR}/TutorialConfig.h&quot; DESTINATION include) That is all there is to it. At this point you should be able to buildthe tutorial, then type make install (or build the INSTALL target froman IDE) and it will install the appropriate header files, libraries,and executables. The CMake variable CMAKE_INSTALL_PREFIX is used todetermine the root of where the files will be installed. Addingtesting is also a fairly straight forward process. At the end of thetop level CMakeLists file we can add a number of basic tests to verifythat the application is working correctly. 就是这么一回事，现在你能够构建这个教程了，然后执行make install（或者通过IDE构建INSTALL目标），它将安装适当的头文件，库和可执行程序。CMake变量CMAKE_INSTALL_PREFIX用来决定所安装文件的根目录。 添加测试也非常简单。在顶级CMakeLists文件的最后，我们可以添加一系列基础测试来验证应用程序是否运行正常。 &lt;!-- lang: shell --&gt; # does the application run add_test (TutorialRuns Tutorial 25) # does it sqrt of 25 add_test (TutorialComp25 Tutorial 25) set_tests_properties (TutorialComp25 PROPERTIES PASS_REGULAR_EXPRESSION &quot;25 is 5&quot;) # does it handle negative numbers add_test (TutorialNegative Tutorial -25) set_tests_properties (TutorialNegative PROPERTIES PASS_REGULAR_EXPRESSION &quot;-25 is 0&quot;) # does it handle small numbers add_test (TutorialSmall Tutorial 0.0001) set_tests_properties (TutorialSmall PROPERTIES PASS_REGULAR_EXPRESSION &quot;0.0001 is 0.01&quot;) # does the usage message work? add_test (TutorialUsage Tutorial) set_tests_properties (TutorialUsage PROPERTIES PASS_REGULAR_EXPRESSION &quot;Usage:.*number&quot;) The first test simply verifies that the application runs, does notsegfault or otherwise crash, and has a zero return value. This is thebasic form of a CTest test. The next few tests all make use of thePASS_REGULAR_EXPRESSION test property to verify that the output of thetest contains certain strings. In this case verifying that thecomputed square root is what it should be and that the usage messageis printed when an incorrect number of arguments are provided. If youwanted to add a lot of tests to test different input values you mightconsider creating a macro like the following: 第一个测试例子验证了程序运行，是否出现段错误或者崩溃，是否返回0值。这是一个CTest的基本测试。接下来的几个测试都利用了PASS_REGULAR_EXPRESSION来验证输出是否包含指定的字符串。在这种情况下，验证计算平方根是必要的，当提供了一个错误的参数时就打印用法信息。如果你想添加测试多个不同的输入值，可以考虑写一个像下面这样的宏： &lt;!-- lang: shell --&gt; #define a macro to simplify adding tests, then use it macro (do_test arg result) add_test (TutorialComp${arg} Tutorial ${arg}) set_tests_properties (TutorialComp${arg} PROPERTIES PASS_REGULAR_EXPRESSION ${result}) endmacro (do_test) # do a bunch of result based tests do_test (25 &quot;25 is 5&quot;) do_test (-25 &quot;-25 is 0&quot;) For each invocation of do_test, another test is added to the projectwith a name, input, and results based on the passed arguments. 对于每个do_test调用，都会根据传入其中的参数，在工程中添加名称、输入和结果。 Adding System Introspection (Step 4) 添加系统反馈 Next let us consider adding some code to our project that depends onfeatures the target platform may not have. For this example we willadd some code that depends on whether or not the target platform hasthe log and exp functions. Of course almost every platform has thesefunctions but for this tutorial assume that they are less common. Ifthe platform has log then we will use that to compute the square rootin the mysqrt function. We first test for the availability of thesefunctions using the CheckFunctionExists.cmake macro in the top levelCMakeLists file as follows: 接下来让我们考虑在工程中添加一些代码，依赖目标平台上可能没有的特性。在这个例子中，我们将添加一些依赖于目标平台是否存在log和exp函数的代码。当然几乎所有的平台都有这些函数，但这个教程假设它们（这些函数）不常见。如果平台存在log，我们就在mysqrt中使用它来计算平方根。我们首先在顶级CMakeLists中使用CheckFunctionExists.cmake宏来测试这些函数的可用性： &lt;!-- lang: shell --&gt; # does this system provide the log and exp functions? include (CheckFunctionExists.cmake) check_function_exists (log HAVE_LOG) check_function_exists (exp HAVE_EXP) Next we modify the TutorialConfig.h.in to define those values if CMakefound them on the platform as follows: 接下来我们修改TutorialConfig.h.in，如果CMake在平台上找到他们（函数），就定义这些值： &lt;!-- lang: shell --&gt; // does the platform provide exp and log functions? #cmakedefine HAVE_LOG #cmakedefine HAVE_EXP It is important that the tests for log and exp are done before theconfigure_file command for TutorialConfig.h. The configure_filecommand immediately configures the file using the current settings inCMake. Finally in the mysqrt function we can provide an alternateimplementation based on log and exp if they are available on thesystem using the following code: 在为TutorialConfig.h执行configure_file命令之前完成对log和exp的测试非常重要。configure_file命令会使用CMake的当前设置立即配置这个文件。最后我们可以在mysqrt函数中提供基于log和exp的可选实现（如果他们在当前系统上可用）： &lt;!-- lang: cpp --&gt; // if we have both log and exp then use them #if defined (HAVE_LOG) &amp;&amp; defined (HAVE_EXP) result = exp(log(x)*0.5); #else // otherwise use an iterative approach . . . Adding a Generated File and Generator (Step 5) 添加生成的文件和生成器 In this section we will show how you can add a generated source fileinto the build process of an application. For this example we willcreate a table of precomputed square roots as part of the buildprocess, and then compile that table into our application. Toaccomplish this we first need a program that will generate the table.In the MathFunctions subdirectory a new source file namedMakeTable.cxx will do just that. 在这个单元中我们将为你展示如何在应用程序的构建过程中添加生成好的源文件。这个例子中我们将为构建过程造一个预计算平方根的表，然后将这个表编译进我们的应用程序。为了完成这个，我们首先需要一个可以生成这个表的程序。MathFunctions子目录下的MakeTable.cxx新源文件将完成这个工作： &lt;!-- lang: cpp --&gt; // A simple program that builds a sqrt table #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;math.h&gt; int main (int argc, char *argv[]) { int i; double result; // make sure we have enough arguments if (argc &lt; 2) { return 1; } // open the output file FILE *fout = fopen(argv[1],&quot;w&quot;); if (!fout) { return 1; } // create a source file with a table of square roots fprintf(fout,&quot;double sqrtTable[] = {\n&quot;); for (i = 0; i &lt; 10; ++i) { result = sqrt(static_cast&lt;double&gt;(i)); fprintf(fout,&quot;%g,\n&quot;,result); } // close the table with a zero fprintf(fout,&quot;0};\n&quot;); fclose(fout); return 0; } Note that the table is produced as valid C++ code and that the name ofthe file to write the output to is passed in as an argument. The nextstep is to add the appropriate commands to MathFunctions’ CMakeListsfile to build the MakeTable executable, and then run it as part of thebuild process. A few commands are needed to accomplish this, as shownbelow. 注意这个表格由C++代码产生，文件名作为参数传入以在里面输出结果。下一步是给MathFunctions的CMakeLists添加适当的命令来构建MakeTable程序。之后将作为构建过程的一部分来运行。需要很少的命令来完成这件事： &lt;!-- lang: shell --&gt; # first we add the executable that generates the table add_executable(MakeTable MakeTable.cxx) # add the command to generate the source code add_custom_command ( OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/Table.h COMMAND MakeTable ${CMAKE_CURRENT_BINARY_DIR}/Table.h DEPENDS MakeTable ) # add the binary tree directory to the search path for # include files include_directories( ${CMAKE_CURRENT_BINARY_DIR} ) # add the main library add_library(MathFunctions mysqrt.cxx ${CMAKE_CURRENT_BINARY_DIR}/Table.h ) First the executable for MakeTable is added as any other executablewould be added. Then we add a custom command that specifies how toproduce Table.h by running MakeTable. Next we have to let CMake knowthat mysqrt.cxx depends on the generated file Table.h. This is done byadding the generated Table.h to the list of sources for the libraryMathFunctions. We also have to add the current binary directory to thelist of include directories so that Table.h can be found and includedby mysqrt.cxx. When this project is built it will first build theMakeTable executable. It will then run MakeTable to produce Table.h.Finally, it will compile mysqrt.cxx which includes Table.h to producethe MathFunctions library. At this point the top level CMakeLists filewith all the features we have added looks like the following: 首先，MakeTable像其他任何一个可执行程序一样被添加进入。然后，我们添加一个定制的命令来指定如何运行MakeTable来产生Table.h。之后，我们必须让CMake知道mysqrt.cxx依赖生成的Table.h文件。将生成的Table.h添加到MathFunctions源代码列表中来搞定它。同时我们也必须将当前二进制目录添加到包含目录列表中，使得Table.h可以被找到，以及被mysqrt.cxx包含。 但工程开始构建时，他首先会构建MakeTable程序，然后执行MakeTable来产生Table.h。最后，他会编译包含了Table.h的mysqrt.cxx来生成MathFunctions库。 至此，顶层的CMakeLists文件包含了我们之前添加的所有特性： &lt;!-- lang: shell --&gt; cmake_minimum_required (VERSION 2.6) project (Tutorial) # The version number. set (Tutorial_VERSION_MAJOR 1) set (Tutorial_VERSION_MINOR 0) # does this system provide the log and exp functions? include (${CMAKE_ROOT}/Modules/CheckFunctionExists.cmake) check_function_exists (log HAVE_LOG) check_function_exists (exp HAVE_EXP) # should we use our own math functions option(USE_MYMATH &quot;Use tutorial provided math implementation&quot; ON) # configure a header file to pass some of the CMake settings # to the source code configure_file ( &quot;${PROJECT_SOURCE_DIR}/TutorialConfig.h.in&quot; &quot;${PROJECT_BINARY_DIR}/TutorialConfig.h&quot; ) # add the binary tree to the search path for include files # so that we will find TutorialConfig.h include_directories (&quot;${PROJECT_BINARY_DIR}&quot;) # add the MathFunctions library? if (USE_MYMATH) include_directories (&quot;${PROJECT_SOURCE_DIR}/MathFunctions&quot;) add_subdirectory (MathFunctions) set (EXTRA_LIBS ${EXTRA_LIBS} MathFunctions) endif (USE_MYMATH) # add the executable add_executable (Tutorial tutorial.cxx) target_link_libraries (Tutorial ${EXTRA_LIBS}) # add the install targets install (TARGETS Tutorial DESTINATION bin) install (FILES &quot;${PROJECT_BINARY_DIR}/TutorialConfig.h&quot; DESTINATION include) # does the application run add_test (TutorialRuns Tutorial 25) # does the usage message work? add_test (TutorialUsage Tutorial) set_tests_properties (TutorialUsage PROPERTIES PASS_REGULAR_EXPRESSION &quot;Usage:.*number&quot; ) #define a macro to simplify adding tests macro (do_test arg result) add_test (TutorialComp${arg} Tutorial ${arg}) set_tests_properties (TutorialComp${arg} PROPERTIES PASS_REGULAR_EXPRESSION ${result} ) endmacro (do_test) # do a bunch of result based tests do_test (4 &quot;4 is 2&quot;) do_test (9 &quot;9 is 3&quot;) do_test (5 &quot;5 is 2.236&quot;) do_test (7 &quot;7 is 2.645&quot;) do_test (25 &quot;25 is 5&quot;) do_test (-25 &quot;-25 is 0&quot;) do_test (0.0001 &quot;0.0001 is 0.01&quot;) TutorialConfig.h looks like: TutorialConfig.h如下： &lt;!-- lang: cpp --&gt; // the configured options and settings for Tutorial #define Tutorial_VERSION_MAJOR @Tutorial_VERSION_MAJOR@ #define Tutorial_VERSION_MINOR @Tutorial_VERSION_MINOR@ #cmakedefine USE_MYMATH // does the platform provide exp and log functions? #cmakedefine HAVE_LOG #cmakedefine HAVE_EXP And the CMakeLists file for MathFunctions looks like: MathFunctions的CMakeLists如下： &lt;!-- lang: shell --&gt; # first we add the executable that generates the table add_executable(MakeTable MakeTable.cxx) # add the command to generate the source code add_custom_command ( OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/Table.h DEPENDS MakeTable COMMAND MakeTable ${CMAKE_CURRENT_BINARY_DIR}/Table.h ) # add the binary tree directory to the search path # for include files include_directories( ${CMAKE_CURRENT_BINARY_DIR} ) # add the main library add_library(MathFunctions mysqrt.cxx ${CMAKE_CURRENT_BINARY_DIR}/Table.h) install (TARGETS MathFunctions DESTINATION bin) install (FILES MathFunctions.h DESTINATION include) Building an Installer (Step 6) 构建一个安装程序 Next suppose that we want to distribute our project to other people sothat they can use it. We want to provide both binary and sourcedistributions on a variety of platforms. This is a little differentfrom the instal we did previously in section Installing and Testing(Step 3), where we were installing the binaries that we had built fromthe source code. In this example we will be building installationpackages that support binary installations and package managementfeatures as found in cygwin, debian, RPMs etc. To accomplish this wewill use CPack to create platform specific installers as described inChapter Packaging with CPack. Specifically we need to add a few linesto the bottom of our toplevel CMakeLists.txt file. 下面假设我们想发布我们的工程给其他人使用。我们想同时在多个平台上提供二进制程序和源代码。这和我们之前在第三部分Installing and Testing中做的安装（从源代码构建安装）有一点不同。这个例子中，我们将构建一个支持二进制安装和包管理特性的安装包，就像在cygwin、debian、RPM中找到的安装包一样。为了完成这件事，我们将利用在章节Packaging with CPack提到的CPack制作指定平台的安装程序。特别地，我们需要在顶层CMakeLists下面添加几行： &lt;!-- lang: shell --&gt; # build a CPack driven installer package include (InstallRequiredSystemLibraries) set (CPACK_RESOURCE_FILE_LICENSE &quot;${CMAKE_CURRENT_SOURCE_DIR}/License.txt&quot;) set (CPACK_PACKAGE_VERSION_MAJOR &quot;${Tutorial_VERSION_MAJOR}&quot;) set (CPACK_PACKAGE_VERSION_MINOR &quot;${Tutorial_VERSION_MINOR}&quot;) include (CPack) That is all there is to it. We start by includingInstallRequiredSystemLibraries. This module will include any runtimelibraries that are needed by the project for the current platform.Next we set some CPack variables to where we have stored the licenseand version information for this project. The version informationmakes use of the variables we set earlier in this tutorial. Finally weinclude the CPack module which will use these variables and some otherproperties of the system you are on to setup an installer. The nextstep is to build the project in the usual manner and then run CPack onit. To build a binary distribution you would run: 就是这样，先包含InstallRequiredSystemLibraries。这个模块将包含工程在当前平台需要的任何运行库。然后，我们设置一些CPack变量指向工程存放license和version信息的地方。版本信息利用了我们之前在教程里设置的变量。最后，我们包含的CPack模块将会使用这些变量，以及你所在系统的其他一些属性，来制作一个安装包。 下一步是按照平常的方式构建工程然后启动CPack。要发布一个二进制版，你需要执行： &lt;!-- lang: shell --&gt; cpack -C CPackConfig.cmake To create a source distribution you would type 要发布源代码，你需要执行： &lt;!-- lang: shell --&gt; cpack -C CPackSourceConfig.cmake Adding Support for a Dashboard (Step 7) 添加面板支持 Adding support for submitting our test results to a dashboard is veryeasy. We already defined a number of tests for our project in theearlier steps of this tutorial. We just have to run those tests andsubmit them to a dashboard. To include support for dashboards weinclude the CTest module in our toplevel CMakeLists file. 为提交我们的测试结果添加面板支持十分简单。在之前的教程中，我们已经为工程定义了很多测试。我们仅仅需要执行这些测试以及把它们提交到面板。要包含面板支持我们需要在顶层CMakeLists中包含CTest模块。 &lt;!-- lang: shell --&gt; # enable dashboard scripting include (CTest) We also create a CTestConfig.cmake file where we can specify the nameof this project for the dashboard. 我们还为面板写了一个可以指定工程名的CTestConfig.cmake文件。 &lt;!-- lang: shell --&gt; set (CTEST_PROJECT_NAME &quot;Tutorial&quot;) CTest will read in this file when it runs. To create a simpledashboard you can run CMake on your project, change directory to thebinary tree, and then run ctest –D Experimental. The results of yourdashboard will be uploaded to Kitware’s public dashboard here. CTest将在运行时读取这个文件。要创建一个简单的面板，你可以在你的工程里运行CMake，将目录改变到二进制树，然后执行实验性的ctest -D。你面板上的结果将会被上传到Kitware的公开面板。 结束语由于本人水平所限，译文和原文内容难免存在差异，甚至错误，还请各位读者评批指出！谢谢！]]></content>
      <tags>
        <tag>tech</tag>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 字符编码问题探究和中文乱码的产生]]></title>
    <url>%2F2015%2F01%2F02%2Fcpp-encoding-problem%2F</url>
    <content type="text"><![CDATA[引言一直以来，C/C++对中文字符的处理时常让人摸不着头脑。主要有下面几个原因：文件编码方式的差异系统环境对中文的解释有差异不同编译器对标准库的实现有差异而这三者往往又相互影响，暗藏玄机，让人抓狂。在写本文之前我查阅了很多博客，关于中文的输入输出，cout，wcout，fstream，wfstream，乱码解决方案等等问题都有了十分详细的解答，但是，很多博文具有片面性。许多博主仅仅是针对自己所使用的环境做阐述，而又没有明确指明使用了何种IDE，何种编译器，何种系统。结果就是，博主们高高兴兴的解决的自己的问题并分享出来，大家高高兴兴的点赞，觉得自己和博主的问题是同一个问题，实际情况却大相径庭。必要的说明文本涉及的编译器和系统：msvc v120 Windows 8.1mingw 4.8 32bit Windows 8.1g++ 4.8.2 Linux 64bit开始测试测试之前很有必要说明一点：A program should not mix output operations on wcout with output operations on cout (or with other narrow-oriented output operations on stdout): Once an output operation has been performed on either, the standard output stream acquires an orientation (either narrow or wide) that can only be safely changed by calling freopen on stdout.—- cplusplus.com就是说不要混用cout和wcout进行输出，因此下面的例子中都是单独使用cout或者wcout。cout测试下面的测试在Visual Studio 2013中进行。MSVC，默认编码GB2312（可以在 文件–高级保存选项 中查看和修改）&lt;!-- lang: cpp --&gt; #include &lt;iostream&gt; int main() { using namespace std; const char *code = &quot;abc中文def&quot;; cout &lt;&lt; &quot;abc中文def&quot; &lt;&lt; endl; cout &lt;&lt; code &lt;&lt; endl; return 0; } 结果abc中文defabc中文def均正确输出。MSVC，改变编码为UTF8（+bom）结果abc中文defabc中文def均正确输出。MSVC，改变编码为UTF8（-bom）结果abc涓枃defabc涓枃def出现乱码。问题分析可以看到源文件的编码方式会影响最后的输出，原因在于常量文本采用了硬编码的方式，也就是说源代码里面的中文会根据当前文件的编码方式直接翻译成对应字节码放进存储空间。如“中文”二字，GB2312（Codepage 936）的编码为：D6 D0 CE C4而UTF8是：E4 B8 AD E6 96 87而控制台也有一套编码方式，对于Windows的cmd，可以查看其 属性 下面的当前代码页，笔者是ANSI(936)。当向控制台传送GB2312的字节码时，中文显示正常，当传入无签名的UTF8的字节码时，中文就不能被正确解释，出现了乱码。Q：为什么带有签名的UTF8却可以正常显示呢？A：实际上UTF8完全不需要带签名，M$自作聪明YY了一个bom头来识别文件是不是UTF8。因此带有签名的UTF8能被cmd识别为UTF8，中文才能显示正常。为了进一步证实是不是和控制台的编码有关系，并正确理解上一个例子中乱码的产生缘由，我们可以做一个重定向，将结果输出到文本文件：test.exe &gt; test.txt使用任意可以改变编码的文本编辑器（笔者使用的是everedit）查看，可以发现以UTF8解释，显示正常，以ANSI(936)解释，将得到刚才那个乱码。下面的测试在QtCreator中进行。MinGW，UTF8结果abc涓枃defabc涓枃def出现乱码。MinGW，ANSI-936结果abc中文defabc中文def显示正确。下面的测试在Linux的bash中进行。g++，UTF8结果abc中文defabc中文def显示正确。g++，gb2312结果abc▒▒▒▒defabc▒▒▒▒def出现乱码。Ubuntu查看/etc/default/locale，可以看到LANG=”en_US.UTF-8”，说明bash能解释UTF8的字节码，而gb2312的变成了乱码。小结程序的输出编码必须和”显示程序”的显示编码适配时才能得到正确的结果。简而言之就是解铃还须系铃人。宽字符使用多个字节来表示一个字符，中文可以用char来表示没问题，用wchar来表示也没有问题。wcout测试wcout输出wchar_t型的宽字符，测试代码如下：&lt;!-- lang: cpp --&gt; #include &lt;iostream&gt; int main() { using namespace std; const wchar_t *code = L&quot;abc中文def&quot;; wcout &lt;&lt; L&quot;abc中文def&quot; &lt;&lt; endl; wcout &lt;&lt; code &lt;&lt; endl; return 0; } MSVC，无论上述何种编码结果abc输出被截断，只有前几个英文字母可以被输出，传入指针输出无效。问题分析L”abc中文def” 在内存中表现为：(gb2312) 61 00 62 00 63 00 2d 4e 87 65 64 00 65 00 66 00(utf8-bom) 61 00 62 00 63 00 2d 4e 87 65 64 00 65 00 66 00(utf8+bom)61 00 62 00 63 00 93 6d 5f e1 83 67 64 00 65 00 66 00wcout 在处理L”abc中文def”时，按宽字节依次遍历，前面的abc没问题（小端序第一个字节是00），遇到中文，识别不了，无输出，间接导致后续&lt;&lt;都没有输出了。也就是说wcout不能用来处理中文输出。第二个传入wchar_t指针，发现没有任何输出，为了验证是不是由于上一条输出语句中中文的影响，单独测试如下：&lt;!-- lang: cpp --&gt; #include &lt;iostream&gt; int main() { using namespace std; const wchar_t *code = L&quot;abc中文def&quot;; wcout &lt;&lt; code &lt;&lt; endl; return 0; } 结果abc说明传入wchar_t指针是可以正常输出宽字节英文的，一旦遇到非00字节间隔，后续所有输出将无效。MinGW的结果同样如此，无论编码与否，只要wcout遇到中文立马跪。有博主称可以在输出前执行下面的函数或者进行全局设置来让wcout认识中文：&lt;!-- lang: cpp --&gt; std::wcout.imbue(std::locale(&quot;chs&quot;)); std::locale::global(std::locale(&quot;&quot;));//全局设置 MSVC下，没有问题，可以达到预期结果。MinGW下，第一条语句会抛出一个runtime_error异常崩溃掉，第二条语句无效。Linux g++下，没问题。可见MinGW的libstdc++对locale的实现不理想，有传闻使用stlport可以避免这个问题。总结认清你的代码处在何种编码的环境认清放在你字符串里面的数据是何种编码认清你要向具有何种编码的屏幕传送数据解铃还须系铃人非特殊情况下不建议使用wchar_t来存放中文字符很多时候中文并不是硬编码进程序的，例如一段中文来自网络，以gb2312编码，而”屏幕”只认UTF8，这个时候就要进行必要的编码转换。boost库的boost::locale::conv中提供了很多常用的转换模板函数，来实现宽窄字符、ansi和utf之间的相互转换。]]></content>
      <tags>
        <tag>tech</tag>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++使用Boost实现Network Time Protocol(NTP)客户端]]></title>
    <url>%2F2014%2F10%2F01%2Fcpp-ntp-client-using-boost%2F</url>
    <content type="text"><![CDATA[引言笔者机器上安装了两个系统，一个Linux Ubuntu，一个Windows8.1。让人感到郁闷的是，每次从Ubuntu重启进入Windows时，系统时间总是少了8个小时，每次都要用Windows的时间程序进行同步，也就是下面这个东西：这个东西其实就是一个NTP Client，从Internet上选择一台NTP Server，获取UTC时间，然后设置本地时间。于是我想自己实现一个这样的程序，先百度一下吧，网上有很多关于NTP的资料和实现代码，大多是单一平台的，不能跨平台，下面给几个参考：http://blog.csdn.net/loongee/article/details/24271129http://blog.csdn.net/chexlong/article/details/6963541http://www.cnblogs.com/TianFang/archive/2011/12/20/2294603.html本文使用boost的Asio来跨平台实现NTP Client.准备最新的boost库，本文使用的是1.56.0版本要用到里面的ASIO网络库IDE是Visual Studio 2013 with Update3笔者是版本帝WireShark也是最新的1.12.1版本用来分析Windows自带的NTP ClientNTP Packet分析这里我们分析的正是上图那个程序，点击立即更新，会发送NTP的请求包，下面是Wireshark的抓包结果：可以得到下面一些信息：NTP时间同步分两个过程，一个Request，一个Response这里的NTP Server的IP地址是129.6.15.28程序没有进行DNS解析，可能是直接保存了IP地址NTP服务的端口号是123，Client也使用了123端口，后来发现Client不是一定要使用123端口的NTP协议是构建在UDP传输协议上的应用协议这里使用V3版的NTP协议，目前还有v4好了，有了关于NTP协议的一些基本信息，我们再来看看应用层的详细信息：Response包：分了很多字段，关于每个字段的含义请参考上面给出的链接，本文主要讲实现。这里Reference Timestamp就是Request包发送的Timestamp，而Origin,Receive,Transmit都是从Server返回回来的时间，后三个时间都相差非常小，因此方便一点，我们取最后一个Transmit Timestamp作为结果。编码boost里面相关库的编译可以参考官方的文档，里面有非常简单的例子。1. 需要的头文件和名字空间123456#include &lt;iostream&gt;#include "boost/asio.hpp"#include "boost/date_time/posix_time/posix_time.hpp"using namespace boost::posix_time;using namespace boost::asio::ip; 2. NtpPacket的构造123456789101112131415161718192021222324252627282930313233343536373839404142434445class NtpPacket &#123;public: NtpPacket() &#123; _rep._flags = 0xdb; // 11.. .... Leap Indicator: unknown // ..01 1... NTP Version 3 // .... .011 Mode: client _rep._pcs = 0x00;//unspecified _rep._ppt = 0x01; _rep._pcp = 0x01; _rep._rdy = 0x01000000;//big-endian _rep._rdn = 0x01000000; _rep._rid = 0x00000000; _rep._ret = 0x0; _rep._ort = 0x0; _rep._rct = 0x0; _rep._trt = 0x0; &#125; friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const NtpPacket&amp; ntpacket) &#123; return os.write(reinterpret_cast&lt;const char *&gt;(&amp;ntpacket._rep), sizeof(ntpacket._rep)); &#125; friend std::istream&amp; operator&gt;&gt;(std::istream&amp; is, NtpPacket&amp; ntpacket) &#123; return is.read(reinterpret_cast&lt;char*&gt;(&amp;ntpacket._rep), sizeof(ntpacket._rep)); &#125;public:#pragma pack(1) struct NtpHeader &#123; uint8_t _flags;//Flags uint8_t _pcs;//Peer Clock Stratum uint8_t _ppt;//Peer Polling Interval uint8_t _pcp;//Peer Clock Precision uint32_t _rdy;//Root Delay uint32_t _rdn;//Root Dispersion uint32_t _rid;//Reference ID uint64_t _ret;//Reference Timestamp uint64_t _ort;//Origin Timestamp uint64_t _rct;//Receive Timestamp uint64_t _trt;//Transmit Timestamp &#125;;#pragma pack() NtpHeader _rep;&#125;; 这里为了方便存取就没有把struct放到private中，需要注意的是结构体各个字段的顺序和需要进行内存1字节对齐，即使用： 1#pragma pack(1) 内存对齐在网络编程中十分重要，他会直接影响Packet的内容，关于内存对齐可以参考： http://www.cppblog.com/cc/archive/2006/08/01/10765.html NTP请求包中最重要的是flags，里面存有版本信息等直接影响协议工作的内容，因此不能搞错了。 两个operator重载用来方便读写Packet数据。 再来看看Client类的实现，Client类的主要任务就是发送和接受NTP包，并返回最后那个64bit的Timestamp。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class NtpClient &#123;public: NtpClient(const std::string&amp; serverIp) :_socket(io), _serverIp(serverIp) &#123; &#125; time_t getTime() &#123; if (_socket.is_open()) &#123; _socket.shutdown(udp::socket::shutdown_both, _ec); if (_ec) &#123; std::cout &lt;&lt; _ec.message() &lt;&lt; std::endl; _socket.close(); return 0; &#125; _socket.close(); &#125; udp::endpoint ep(boost::asio::ip::address_v4::from_string(_serverIp), NTP_PORT); NtpPacket request; std::stringstream ss; std::string buf; ss &lt;&lt; request; ss &gt;&gt; buf; _socket.open(udp::v4()); _socket.send_to(boost::asio::buffer(buf), ep); std::array&lt;uint8_t, 128&gt; recv; size_t len = _socket.receive_from(boost::asio::buffer(recv), ep); uint8_t* pBytes = recv.data(); /****dump hex data for (size_t i = 0; i &lt; len; i++) &#123; if (i % 16 == 0) &#123; std::cout &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; std::setw(2) &lt;&lt; std::setfill('0') &lt;&lt; std::hex &lt;&lt; (uint32_t) pBytes[i]; std::cout &lt;&lt; ' '; &#125; &#125; ****/ time_t tt; uint64_t last; uint32_t seconds; /****get the last 8 bytes(Transmit Timestamp) from received packet. std::memcpy(&amp;last, pBytes + len - 8, sizeof(last)); ****create a NtpPacket*/ NtpPacket resonpse; std::stringstream rss; rss.write(reinterpret_cast&lt;const char*&gt;(pBytes), len); rss &gt;&gt; resonpse; last = resonpse._rep._trt; // reverseByteOrder(last); seconds = (last &amp; 0x7FFFFFFF00000000) &gt;&gt; 32; tt = seconds + 8 * 3600 * 2 - 61533950; return tt; &#125;private: const uint16_t NTP_PORT = 123; udp::socket _socket; std::string _serverIp; boost::system::error_code _ec;&#125;; 注意几个地方： 1. udp::socket是boost里面使用udp协议的套接字，他的构造需要一个io_service，io_service可以直接在全局区进行声明：1boost::asio::io_service io; 2. 创建一个endpoint用来表示NTP Server的地址：1udp::endpoint ep(boost::asio::ip::address_v4::from_string(_serverIp), NTP_PORT); 向这个ep send_to，并从这个ep receive_from数据包。 3. time_t的定义如下：12typedef __time64_t time_t; /* time value */typedef __int64 __time64_t; /* 64-bit time value */ 也就是说这个time_t其实就是一个64bit的int，我们可以用uint64_t这个类型与之互换，他可以用来表示一个Timestamp。 获取最后8字节内容有两种方式，一种是直接复制pBytes的内存，一种是构造NtpPacket，然后取成员，这里选择后者易于理解。 字节序的问题 网络字节序都是大端模式，需要进行转换，由于仅仅需要最后那个uint64_t所以我写了一个针对64bit的字节序转换函数： 12345678910static void reverseByteOrder(uint64_t &amp;in) &#123; uint64_t rs = 0; int len = sizeof(uint64_t); for (int i = 0; i &lt; len; i++) &#123; std::memset(reinterpret_cast&lt;uint8_t*&gt;(&amp;rs) + len - 1 - i , static_cast&lt;uint8_t&gt; ((in &amp; 0xFFLL &lt;&lt; (i * 8)) &gt;&gt; i * 8) , 1); &#125; in = rs;&#125; 最后一个64bit内容的高32位存了UTC秒数，所以需要取出来，然后再转换为本地时区的秒数。 1seconds = (last &amp; 0x7FFFFFFF00000000) &gt;&gt; 32; 注意最高位是不能取的，尽管是unsigned，至于为什么要- 61533950这个是笔者在自己电脑上尝试出来的，找了很多资料不知是哪里的问题，还请各位知道的读者告诉我哈。 再来看看主函数： 1234567891011int main(int argc, char* agrv[]) &#123; NtpClient ntp("129.6.15.28"); int n = 5; while (n--) &#123; time_t tt = ntp.getTime(); boost::posix_time::ptime utc = from_time_t(tt); std::cout &lt;&lt; "Local Timestamp:" &lt;&lt; time(0) &lt;&lt; '\t' &lt;&lt; "NTP Server:" &lt;&lt; tt &lt;&lt; "(" &lt;&lt; to_simple_string(utc) &lt;&lt; ")" &lt;&lt; std::endl; Sleep(10); &#125; return 0;&#125; 这里进行5次NTP请求，并使用boost的to_simple_string转换UTC时间打印结果。 大概是这种效果： 收尾同步时间一般都会想到找一个http api接口，本文主要是用了NTP协议。为了跨平台，上面的代码尽可能避免使用平台相关的宏和函数，只要稍作修改就能在各种平台下执行，也得益于boost这个强悍的准标准库给开发者带来的便利。]]></content>
      <tags>
        <tag>tech</tag>
        <tag>cpp</tag>
        <tag>net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++我也来写个工厂模式]]></title>
    <url>%2F2014%2F08%2F28%2Fcpp-factory-design-pattern%2F</url>
    <content type="text"><![CDATA[工厂方法模式（Factory method pattern）是一种实现了“工厂”概念的面向对象设计模式。就像其他创建型模式一样，它也是处理在不指定对象具体类型的情况下创建对象的问题。工厂方法模式的实质是“定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。以前是没有实现过工厂模式，这里我用到了template来创建类型不同的Products，内存管理这块没想到更好的办法来cleanup，打算是利用析构自动release，不过貌似到模版里就捉禁见肘了。。大家有什么高见？1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;iostream&gt;#include &lt;vector&gt;// ProductAclass ProductA&#123;public: void name();&#125;;void ProductA::name()&#123; std::cout &lt;&lt; "I'm Product A." &lt;&lt; std::endl;&#125;// ProductBclass ProductB&#123;public: void name();&#125;;void ProductB::name()&#123; std::cout &lt;&lt; "I'm Product B." &lt;&lt; std::endl;&#125;// Factorytemplate&lt;typename T&gt;class Factory&#123;public: static T* create(); static void cleanup();private: Factory(); static std::vector&lt;T*&gt; objs_;&#125;;template&lt;typename T&gt;std::vector&lt;T*&gt; Factory&lt;T&gt;::objs_;template&lt;typename T&gt;Factory&lt;T&gt;::Factory()&#123;&#125;template&lt;typename T&gt;void Factory&lt;T&gt;::cleanup()&#123; for each (T* obj in objs_) if (obj) &#123; std::cout &lt;&lt; "release " &lt;&lt; obj &lt;&lt; std::endl; delete obj; obj = nullptr; &#125; objs_.clear();&#125;template&lt;typename T&gt;T* Factory&lt;T&gt;::create()&#123; T * obj = new T; objs_.push_back(obj); return obj;&#125;int main(int argc, char *argv[])&#123; //create 10 ProductAs for (size_t i = 1; i &lt;= 10; i++) &#123; auto pa = Factory&lt;ProductA&gt;::create(); pa-&gt;name(); &#125; //create 10 ProductBs for (size_t i = 1; i &lt;= 10; i++) &#123; auto pb = Factory&lt;ProductB&gt;::create(); pb-&gt;name(); &#125; //free memory Factory&lt;ProductA&gt;::cleanup(); Factory&lt;ProductB&gt;::cleanup(); return 0;]]></content>
      <tags>
        <tag>tech</tag>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Golang实现简单Ping过程]]></title>
    <url>%2F2014%2F08%2F11%2Fgolang-ping-implememt%2F</url>
    <content type="text"><![CDATA[引言关于各种语言实现Ping已经是大家喜闻乐见的事情了，网络上利用Golang实现Ping已经有比较详细的代码示例，但大多是仅仅是实现了Request过程，而对Response的回显内容并没有做接收。而Ping程序不仅仅是发送一个ICMP，更重要的是如何接收并进行统计。下面是网络上几篇关于Ping的实现代码：https://github.com/paulstuart/ping/blob/master/ping.gohttp://blog.csdn.net/gophers/article/details/21481447http://blog.csdn.net/laputa73/article/details/17226337本文借鉴了第二个链接里面的部分代码。准备安装最新的Go由于Google被墙的原因，如果没有VPN的话，就到这里下载：http://www.golangtc.com/download使用任意文本编辑器，或者LiteIDE会比较方便编译和调试，下面是LiteIDE的下载地址https://github.com/visualfc/liteide编码要用到的package：123456789import ( "bytes" "container/list" "encoding/binary" "fmt" "net" "os" "time") 使用Golang提供的net包中的相关函数可以快速构造一个IP包并自定义其中一些关键参数，而不需要再自己手动填充IP报文。 使用encoding/binary包可以轻松获取结构体struct的内存数据并且可以规定字节序（这里要用网络字节序BigEndian），而不需要自己去转换字节序。之前的一片文中使用boost，还要自己去实现转换过程，详见：关于蹭网检查的原理及实现 使用container/list包，方便进行结果统计 使用time包实现耗时和超时处理 ICMP报文struct： 1234567type ICMP struct &#123; Type uint8 Code uint8 Checksum uint16 Identifier uint16 SequenceNum uint16&#125; Usage提示： 123456789101112arg_num := len(os.Args) if arg_num &lt; 2 &#123; fmt.Print( "Please runAs [super user] in [terminal].\n", "Usage:\n", "\tgoping url\n", "\texample: goping www.baidu.com", ) time.Sleep(5e9) return &#125; 注意这个ping程序，包括之前的ARP程序都必须使用系统最高权限执行，所以这里先给出提示，使用time.Sleep(5e9)，暂停5秒，是为了使双击执行者看到提示，避免控制台一闪而过。 关键net对象的创建和初始化： 1234567891011121314var ( icmp ICMP laddr = net.IPAddr&#123;IP: net.ParseIP("0.0.0.0")&#125; raddr, _ = net.ResolveIPAddr("ip", os.Args[1]) ) conn, err := net.DialIP("ip4:icmp", &amp;laddr, raddr) if err != nil &#123; fmt.Println(err.Error()) return &#125; defer conn.Close() net.DialIP表示生成一个IP报文，版本号是v4，协议是ICMP（这里字符串ip4:icmp会把IP报文的协议字段设为1表示ICMP协议）， 源地址laddr可以是0.0.0.0也可以是自己的ip，这个并不影响ICMP的工作。 目的地址raddr是一个URL，这里使用Resolve进行DNS解析，注意返回值是一个指针，所以下面的DialIP方法中参数表示没有取地址符。 这样一个完整的IP报文就装配好了，我们并没有去操心IP中的其他一些字段，Go已经为我们处理好了。 通过返回的conn *net.IPConn对象可以进行后续操作。 defer conn.Close() 表示该函数将在Return时被执行，确保不会忘记关闭。 下面需要构造ICMP报文了： 1234567891011icmp.Type = 8 icmp.Code = 0 icmp.Checksum = 0 icmp.Identifier = 0 icmp.SequenceNum = 0 var buffer bytes.Buffer binary.Write(&amp;buffer, binary.BigEndian, icmp) icmp.Checksum = CheckSum(buffer.Bytes()) buffer.Reset() binary.Write(&amp;buffer, binary.BigEndian, icmp) 仍然非常简单，利用binary可以把一个结构体数据按照指定的字节序读到缓冲区里面，计算校验和后，再读进去。 检验和算法参考上面给出的URL中的实现： 123456789101112131415161718func CheckSum(data []byte) uint16 &#123; var ( sum uint32 length int = len(data) index int ) for length &gt; 1 &#123; sum += uint32(data[index])&lt;&lt;8 + uint32(data[index+1]) index += 2 length -= 2 &#125; if length &gt; 0 &#123; sum += uint32(data[index]) &#125; sum += (sum &gt;&gt; 16) return uint16(^sum)&#125; 下面是Ping的Request过程，这里仿照Windows的ping，默认只进行4次： 12345678910111213141516171819202122232425262728293031323334353637383940fmt.Printf("\n正在 Ping %s 具有 0 字节的数据:\n", raddr.String()) recv := make([]byte, 1024) statistic := list.New() sended_packets := 0 for i := 4; i &gt; 0; i-- &#123; if _, err := conn.Write(buffer.Bytes()); err != nil &#123; fmt.Println(err.Error()) return &#125; sended_packets++ t_start := time.Now() conn.SetReadDeadline((time.Now().Add(time.Second * 5))) _, err := conn.Read(recv) if err != nil &#123; fmt.Println("请求超时") continue &#125; t_end := time.Now() dur := t_end.Sub(t_start).Nanoseconds() / 1e6 fmt.Printf("来自 %s 的回复: 时间 = %dms\n", raddr.String(), dur) statistic.PushBack(dur) //for i := 0; i &lt; recvsize; i++ &#123; // if i%16 == 0 &#123; // fmt.Println("") // &#125; // fmt.Printf("%.2x ", recv[i]) //&#125; //fmt.Println("") &#125; “具有0字节的数据”表示ICMP报文中没有数据字段，这和Windows里面32字节的数据的略有不同。 conn.Write方法执行之后也就发送了一条ICMP请求，同时进行计时和计次。 conn.SetReadDeadline可以在未收到数据的指定时间内停止Read等待，并返回错误err，然后判定请求超时。否则，收到回应后，计算来回所用时间，并放入一个list方便后续统计。 注释部分内容是我在探索返回数据时的代码，读者可以试试看Read到的数据是哪个数据包的？ 统计工作将在循环结束时进行，这里使用了defer其实是希望按了Ctrl+C之后能return执行，但是控制台确实不给力，直接给杀掉了。。 123456789101112131415161718192021222324252627282930defer func() &#123; fmt.Println("") //信息统计 var min, max, sum int64 if statistic.Len() == 0 &#123; min, max, sum = 0, 0, 0 &#125; else &#123; min, max, sum = statistic.Front().Value.(int64), statistic.Front().Value.(int64), int64(0) &#125; for v := statistic.Front(); v != nil; v = v.Next() &#123; val := v.Value.(int64) switch &#123; case val &lt; min: min = val case val &gt; max: max = val &#125; sum = sum + val &#125; recved, losted := statistic.Len(), sended_packets-statistic.Len() fmt.Printf("%s 的 Ping 统计信息：\n 数据包：已发送 = %d，已接收 = %d，丢失 = %d (%.1f%% 丢失)，\n往返行程的估计时间(以毫秒为单位)：\n 最短 = %dms，最长 = %dms，平均 = %.0fms\n", raddr.String(), sended_packets, recved, losted, float32(losted)/float32(sended_packets)*100, min, max, float32(sum)/float32(recved), ) &#125;() 统计过程注意类型的转换和格式化就行了。 全部代码就这些，执行结果大概是这个样子的： 注意每次Ping后都没有”休息”，不像Windows或者Linux的会停顿几秒再Ping下一轮。 收尾Golang实现整个Ping比我想象中的还要简单很多，静态编译速度是十分快速，相比C而言，你需要更多得了解底层，甚至要从链路层开始，你需要写更多更复杂的代码来完成相同的工作，但究其根本，C语言仍然是鼻祖，功不可没，很多原理和思想都要继承和发展，这一点Golang做的很好。]]></content>
      <tags>
        <tag>tech</tag>
        <tag>net</tag>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于蹭网检查的原理及实现]]></title>
    <url>%2F2014%2F08%2F02%2Fnetwork-rub-inspection%2F</url>
    <content type="text"><![CDATA[引言网络十分普及的现在,几乎每家每户都用上了无线局域网, 但也时常因为路由器密码泄露或破解被别人蹭网,加之WiFi 万能钥匙等软件的流行, 越来越多人加入了蹭网大军, 也给不少小型局域网用户带来了烦恼. 目前许多安全软件厂商都在推出检查蹭网的小程序, 通过这样的程序可以十分便捷的看到哪些设备在使用局域网, 从而及时发现和采取应对措施, 为广大用户弥补了损失.准备笔者手里正好有一款由nisoft发布的检查蹭网的小程序, 叫做Wireless Network Watcher, 软件免费试用, 文末将给出下载地址. 本文将针对该款软件做分析. 其次是WireShark协议分析工具, 这个软件很常见, 感兴趣的话可以百度下载.笔者的系统仍然是Windows8.1 Pro.操作步骤1.打开Wireless Network Watcher, 在Advanced Options中设置合适的Network adapter(可能含有其他网络设备的网段), 笔者主机所在网段是192.168.199.*2.打开WireShark,选择合适的网卡然后启动监控3.启动Wireless Network Watcher的扫描4.等待扫描结束,然后停止两个软件5.在WireShark中进行分析分析从Wireless Network Watcher的扫描结果来看,除了Router之外还发现了3个设备,一个是我的主机(Your Computer),一个是我的安卓手机,还有一个是HyFi智能无线路由器.此外,包括MAC地址在内的IP地址, 设备名称Device Name等等都获取到了.从Wireshark的抓包结果来看, 大多数是ARP协议, 在ARP应答报文中可以得到对应在线主机的MAC地址, 程序在收到应答后有一个DNS反向解析动作, 在DNS应答中又可以得到设备的Device Name,而这个Device Name应该是存在Router中的. 过滤其他干扰协议保留ARP和DNS. 可以十分明显的发现ARP请求报文的 Target IP address是从网段中0开始,一直到255, 也就是说软件扫描了整个网段, 发送了256个ARP广播用来查找在线的主机, 然后通过得到的IP地址向路由器发送DNS反向解析请求,用来获取设备的名称. 如图所示:这里先借一段关于ARP协议的百科:地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。其功能是：主机将ARP请求广播到网络上的所有主机，并接收返回消息，确定目标IP地址的物理地址，同时将IP地址和硬件地址存入本机ARP缓存中，下次请求时直接查询ARP缓存。地址解析协议是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记录在本地的ARP缓存中，这样攻击者就可以向目标主机发送伪ARP应答报文，使目标主机发送的信息无法到达相应的主机或到达错误的主机，构成一个ARP欺骗。ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等。—- 百度百科通过这段引用可以了解到ARP协议的Request是一个广播,发送到网络上所有主机,然后接收应答.关于DNS的工作原理可以参考我的另一篇文: 《利用WireShark进行DNS协议分析》现在让我们来分析一个ARP的请求和应答,以及一个DNS的请求和应答.以第一个ARP为例:第一个包是ARP请求,第二个是ARP应答,第三个是DNS请求,第四个是DNS应答,下面依次分析:1. ARP请求ARP请求的关键在于目标MAC尚未知道,因此全0,注意上层协议中的目标MAC是全f, 表示一个广播, 由于不同层的协议不同, 因此含义也不同. 请求解析的地址是192.168.199.1, opcode为 0x0001代表该ARP是一个Request.ARP报文格式不在本文的讨论范围, 其本身也比较简单. 请读者自行百度.2. ARP应答当ARP请求广播后, 收到请求的主机检查Target IP address是否和自己相同,相同就回应一个ARP, 注意此时不再是一个广播了,而是定向的回应发送者. Sender MAC address字段里放有我们希望得到的目标MAC地址.主机得到来自192.168.199.1的应答后, 取出MAC并记下IP地址, 为后面的DNS反向解析做准备.其实到此为止, 就探测到了一个在线的主机, 完成了关键的侦测任务, 下面的DNS是软件本身为了优化用户体验, 向路由器查询一下设备名称而已. 此外,如果广播出去的ARP一定时间内没有收到回应,说明所探测的主机不在线.3. DNS请求主机收到ARP回应后, 利用IP地址进行DNS反向解析, 注意查询IP字段在报文中是逆序存放的. 目的地是路由器.4. DNS应答DNS应答报文中指出Domain Name是 Hiwifi.lan 这和软件上的Device Name一致.实现之前直接打算用boost的asio网络库来实现ARP的收发,搞了半天发现asio的rawsocket不能自定义实现这样的底层协议,网络上关于boost实现ARP的资料几乎没有,因此考虑了windows平台下的winpcap.首先需要自己定义好arp以及ethernet报文(帧)的标准格式,为了简便起见,成员函数全部使用inline方式, 下面两个hpp分别定义了这两种格式:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//ethernet_header.hpp#ifndef ETHERNET_HEADER_HPP#define ETHERNET_HEADER_HPP#include &lt;istream&gt;#include &lt;ostream&gt;#include "mac_address.hpp"// Ethernet header //// The wire format of an Ethernet header is:// 0 5 11 13// +-----------------+-----------------+-----+// |destination mac |source mac |type |// |XX:XX:XX:XX:XX:XX|YY:YY:YY:YY:YY:YY|ZZ:ZZ|// +-----------------+-----------------+-----+class ethernet_header&#123;public: ethernet_header() &#123; std::fill(rep_, rep_ + sizeof(rep_), 0); &#125; void dst(const MacAddr &amp;mac_address) &#123; for (size_t i = 0; i &lt; mac_address.size(); ++i) &#123; rep_[0 + i] = mac_address[i]; &#125; &#125; void src(const MacAddr &amp;mac_address) &#123; for (size_t i = 0; i &lt; mac_address.size(); ++i) &#123; rep_[6 + i] = mac_address[i]; &#125; &#125; void type(unsigned short n) &#123; encode(12, 13, n); &#125; MacAddr dst() const &#123; MacAddr mac_address; for (int i = 0; i &lt; 6; ++i) &#123; mac_address.push_back(rep_[0 + i]); &#125; return mac_address; &#125; MacAddr src() const &#123; MacAddr mac_address; for (int i = 0; i &lt; 6; ++i) &#123; mac_address.push_back(rep_[6 + i]); &#125; return mac_address; &#125; unsigned short type() const &#123; return decode(12, 13); &#125; friend std::istream&amp; operator&gt;&gt;(std::istream&amp; is, ethernet_header&amp; header) &#123; return is.read(reinterpret_cast&lt;char*&gt;(header.rep_), 14); &#125; friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const ethernet_header&amp; header) &#123; return os.write(reinterpret_cast&lt;const char*&gt;(header.rep_), 14); &#125;private: unsigned short decode(int a, int b) const &#123; return (rep_[a] &lt;&lt; 8) + rep_[b]; &#125; void encode(int a, int b, unsigned short n) &#123; rep_[a] = static_cast&lt;unsigned char&gt;(n &gt;&gt; 8); rep_[b] = static_cast&lt;unsigned char&gt;(n &amp; 0xFF); &#125; unsigned char rep_[14];&#125;;#endif // ETHERNET_HEADER_HPP 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158//arp_header.hpp#ifndef ARP_HEADER_HPP#define ARP_HEADER_HPP#include &lt;istream&gt;#include &lt;vector&gt;#include &lt;boost/asio.hpp&gt;#include "mac_address.hpp"// ARP header//// The wire format of an ARP header is:// // 0 8 16 31// +-------------------------------+------------------------------+ ---// | | | ^// | Hardware type (HTYPE) | Protocol type (PTYPE) | |// | | | |// +---------------+---------------+------------------------------+ 4 bytes// | | | | ^// | Hard. len. | Proto. len. | Operation (OPER) | |// | (HLEN) | (PLEN) | | |// +-------------------------------+------------------------------+ 8 bytes// | | ^// | Sender hardware address (SHA) | |// | | |// +--------------------------------------------------------------+ 14 bytes// | | ^// | Sender protocol address (SPA) | |// | | |// +--------------------------------------------------------------+ 18 bytes// | | ^// | Target hardware address (THA) | |// | | |// +--------------------------------------------------------------+ 24 bytes// | | ^// | Target protocol address (TPA) | |// | | |// +--------------------------------------------------------------+ 28 bytesclass arp_header&#123;public: arp_header()&#123; std::fill(rep_, rep_ + sizeof(rep_), 0); &#125; //setter void htype(unsigned short n)&#123; encode(0, 1, n); &#125; void ptype(unsigned short n)&#123; encode(2, 3, n); &#125; void hsize(unsigned char n)&#123; rep_[4] = n; &#125; void psize(unsigned char n)&#123; rep_[5] = n; &#125; void opcode(unsigned short n)&#123; encode(6, 7, n); &#125; void sha(const MacAddr &amp; mac)&#123; for (size_t i = 0; i &lt; mac.size(); ++i) rep_[8 + i] = mac[i]; &#125; void spa(const boost::asio::ip::address_v4 &amp;address)&#123; auto bytes = address.to_bytes(); rep_[14] = bytes[0]; rep_[15] = bytes[1]; rep_[16] = bytes[2]; rep_[17] = bytes[3]; &#125; void tha(const MacAddr&amp; mac)&#123; for (size_t i = 0; i &lt; mac.size(); ++i) rep_[18 + i] = mac[i]; &#125; void tpa(const boost::asio::ip::address_v4 &amp;address)&#123; auto bytes = address.to_bytes(); rep_[24] = bytes[0]; rep_[25] = bytes[1]; rep_[26] = bytes[2]; rep_[27] = bytes[3]; &#125; //getter unsigned short htype() const &#123; return decode(0, 1); &#125; unsigned short ptype() const &#123; return decode(2, 3); &#125; unsigned char hsize() const &#123; return rep_[4]; &#125; unsigned char psize() const &#123; return rep_[5]; &#125; unsigned short opcode() const &#123; return decode(6, 7); &#125; MacAddr sha()const &#123; MacAddr mac; for (size_t i = 0; i &lt; 6; i++) mac.push_back(rep_[8 + i]); return mac; &#125; boost::asio::ip::address_v4 spa() const &#123; boost::asio::ip::address_v4::bytes_type bytes = &#123;rep_[14], rep_[15], rep_[16], rep_[17]&#125;; return boost::asio::ip::address_v4(bytes); &#125; MacAddr tha()const&#123; MacAddr mac; for (int i = 0; i &lt; 6; ++i) mac.push_back(rep_[18 + i]); return mac; &#125; boost::asio::ip::address_v4 tpa() const &#123; boost::asio::ip::address_v4::bytes_type bytes = &#123;rep_[24], rep_[25], rep_[26], rep_[27]&#125;; return boost::asio::ip::address_v4(bytes); &#125; //overloads friend std::istream&amp; operator&gt;&gt;(std::istream&amp; is, arp_header&amp; header) &#123; return is.read(reinterpret_cast&lt;char*&gt;(header.rep_), 28); &#125; friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const arp_header&amp; header) &#123; return os.write(reinterpret_cast&lt;const char*&gt;(header.rep_), 28); &#125;private: void encode(int a, int b, unsigned short n) &#123; rep_[a] = static_cast&lt;unsigned char&gt;(n &gt;&gt; 8);//取出高8位 rep_[b] = static_cast&lt;unsigned char&gt;(n &amp; 0xff);//取出低8位 //相当于转换字节序,把小端格式转换为网络字节序 //例如 数 0x1234 在小端模式(Little-endian)中表示为: //低地址----&gt;高地址 //34 12 //网络序,大端模式(Big-endian)应该是: //12 34 //该函数实现这个功能 &#125; unsigned short decode(int a, int b) const &#123; return (rep_[a] &lt;&lt; 8) + rep_[b]; //这个就是encode的反函数,把两个字节倒过来返回 &#125; unsigned char rep_[28];&#125;;#endif // ARP_HEADER_HPP 关于主机字节序(本例为小端)和网络字节序(大端)的转换过程可以参考上面代码中的注释. 实在贴不下这么多代码了,主函数代码包括所有本文涉及的hpp源代码请见下面的代码分享链接. 由于时间仓促,代码仅供学习交流,有很多遗留的问题尚未解决,但并不影响大家对整个实现过程的理解 运行结果 程序将扫描定义好的整个ip区段,发送ARP广播,然后接收响应,列出目标的MAC地址.具体实现请看下面的代码分享. 代码分享http://www.oschina.net/code/snippet_580940_37722 相关下载Wireless Network Watcher]]></content>
      <tags>
        <tag>tech</tag>
        <tag>cpp</tag>
        <tag>net</tag>
        <tag>wireshark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用WireShark分析由Ping产生的Internet 控制报文协议(ICMP)]]></title>
    <url>%2F2014%2F07%2F15%2Fwireshark-ping-icmp%2F</url>
    <content type="text"><![CDATA[ICMP是（Internet Control Message Protocol）Internet控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用CMP为TCP/IP协议簇中的成员,工作在网络层,作用是在主机和路由器之间传递控制信息.上文中Ping命令完成DNS域名解析任务后,随即利用得到的第一条主机资源记录(A记录)中的IP地址发送ICMP请求报文:图中可以看到ICMP报文格式:Type(类型)以及Code(代码)合起来说明ICMP报文类型.–这里ICMP的类型是:请求(0x8)表示ping请求; 响应(0x0)表示ping响应Checksum(校验和)包含整个ICMP报文数据的校验.ID(标识符)和Seq(序列号)由发送端任意设置,响应报文返回相同的值,用于配对请求和响应.–比如,在这个例子中,ID字段和Seq有两种表示方式:大端和小端,在请求和响应报文中,ID值始终不变;但是每发送一次请求,Seq就被加一.随后的Data数据段长度不固定,ping命令的发送的Echo请求数据是32bytes的a~i字符序列,且没有终止0,刚好印证了为什么Ping时会显示: “Ping xxx 具有32字节的数据:” 这里32字节的数据就是a~i字符序列.ICMP响应报文中:Type值是0x0,表示 ping reply,这一点显而易见的.ID和Seq值和请求报文中的相同.Data也是相同的.在接收到响应之后同时计算出报文往返的时间,这里是Response time: 47.360ms这样就完成了一次Ping之后的三个Ping其实是重复上述操作,只不过Seq序号字段要自增.今天就到这里,欢迎大家学习交流,其实我更希望得到大家的意见,谢谢点赞~]]></content>
      <tags>
        <tag>tech</tag>
        <tag>net</tag>
        <tag>wireshark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用WireShark进行DNS协议分析]]></title>
    <url>%2F2014%2F07%2F15%2Fwireshark-dns%2F</url>
    <content type="text"><![CDATA[准备工作系统是Windows 8.1Pro分析工具是WireShark1.10.8 Stable Version使用系统Ping命令发送ICMP报文.开始工作打开CMD.exe键入:ping www.oschina.net将自动进行域名解析,默认发送4个ICMP报文.启动Wireshark,选择一个有效网卡,启动抓包.在控制台回车执行完毕后停止监控.分析阶段截获的所有报文如下:总得来看有两个DNS包(一次域名解析),和8个ICMP包(四次ping)下面开始分析DNS的工作过程:打开第一个包:可以发现DNS为应用层协议,下层传输层采用UDP,再下层网络层是IP协议,然后是数据链路层的以太网帧.需要关注的是应用层的实现也即DNS协议本身.在此之前,可以从下层获得一些必要信息:UDP(User Datagram Protocol)报文中: DNS的目的端口(Dst Port)是53IPv4(Internet Protocol Version 4)报文中目的IP是192.168.1.1(局域网路由器)由于IP报文在网络层进行路由选择,他会依次送给路由器而不是直接送给DNS服务器,这一点也十分容易理解,第一个包是请求包,不可能直接包含DNS服务器地址.展开DNS数据:第一个是Transaction ID为标识字段,2字节,用于辨别DNS应答报文是哪个请求报文的响应.第二个是Flags标志字段,2字节,每一位的含义不同,具体可以参考上面那个图,也可以看下面这个图:QR: 查询/响应,1为响应,0为查询Opcode: 查询或响应类型,这里0表示标准,1表示反向,2表示服务器状态请求AA: 授权回答,在响应报文中有效,待会儿再看TC: 截断,1表示超过512字节并已被截断,0表示没有发生截断RD: 是否希望得到递归回答RA: 响应报文中为1表示得到递归响应zero: 全0保留字段rcode: 返回码,在响应报文中,各取值的含义:0 - 无差错 1 - 格式错误 2 - 域名服务器出现错误 3 - 域参照问题 4 - 查询类型不支持 5 - 被禁止 6 ~ 15 保留 紧接着标志位的是Quetions(问题数),2字节,通常为1Answer RRs(资源记录数),Authority RRs(授权资源记录数),Additional RRs(额外资源记录数)通常为0字段Queries为查询或者响应的正文部分,分为Name Type ClassName(查询名称):这里是ping后的参数,不定长度以0结束Type(查询类型):2字节,这里是主机A记录.其各个取值的含义如下:值 助记符 说明 1 A IPv4地址。 2 NS 名字服务器。 5 CNAME 规范名称。定义主机的正式名字的别名。 6 SOA 开始授权。标记一个区的开始。 11 WKS 熟知服务。定义主机提供的网络服务。 12 PTR 指针。把IP地址转化为域名。 13 HINFO 主机信息。给出主机使用的硬件和操作系统的表述。 15 MX 邮件交换。把邮件改变路由送到邮件服务器。 28 AAAA IPv6地址。 252 AXFR 传送整个区的请求。 255 ANY 对所有记录的请求。 Class(类):2字节,IN表示Internet数据,通常为1下面是截获的第二个DNS包:可以看到和第一个请求包相比,响应包多出了一个Answers字段,同时Flags字段每一位都有定义.关注一下Flags中Answer RRs 为4 说明对应的Answers字段中将会出现4项解析结果.Answers字段可以看成一个List,集合中每项为一个资源记录,除了上面提到过的Name,Type,Class之外,还有Time toLive,Data length,Addr.Time to Live(生存时间TTL):表示该资源记录的生命周期,从取出记录到抹掉记录缓存的时间,以秒为单位.这里是0x00 00 00 fd 合计253s.Data length(资源数据长度):以字节为单位,这里的4表示IP地址的长度为4字节.也就是下面Addr字段的长度.Addr(资源数据): 返回的IP地址,就是我们想要的结果.可以发现有4条资源记录,4个不同的IP地址,说明域名 www.oschina.net 对应有4个IP地址,分别是:112.124.5.74219.136.249.19461.145.122.155121.9.213.124CMD中显示的是第一条IP地址.我试了下直接访问上面各个地址的80端口(http),第一个和第二个显示403 Forbidden第三个和第四个显示404 Not Found还有每个地址哦Server都不一样oscali,oscdb,liubc,ep2,第一个像阿里云服务器,第二个看起来像数据库的服务器,其他就不知道了…Web服务器貌似是Tengine,不知道为什么通过IP地址无法直接访问web站点,以后感兴趣再研究下哈哈关于ICMP协议的报文分析将在之后的文章中给出.今天先到这吧.最后,欢迎大家评论交流~特别是OSC在搞什么鬼.]]></content>
      <tags>
        <tag>tech</tag>
        <tag>net</tag>
        <tag>wireshark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实战利用WireShark对Telnet协议进行抓包分析]]></title>
    <url>%2F2014%2F07%2F14%2Fwireshark-telnet%2F</url>
    <content type="text"><![CDATA[Telnet协议是TCP/IP协议族中的一员，是Internet远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。在终端使用者的电脑上使用telnet程序，用它连接到服务器。终端使用者可以在telnet程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。可以在本地就能控制服务器。要开始一个telnet会话，必须输入用户名和密码来登录服务器。Telnet是常用的远程控制Web服务器的方法。准备工作虚拟机Virtual Box(Telnet服务端)安装Windows XP SP3操作系统开启了Telnet服务添加了一个账户用于远程登录,用户名和密码都是micooz宿主机Windows 8.1 Pro(Telnet客户端)安装了分析工具Wireshark1.11.2安装了Telnet客户端程序PS:虚拟机网卡选用桥接模式操作流程开启虚拟机和Wireshark查看XP获得的ip地址,这里是192.168.199.134;网卡MAC地址:08:00:27:a0:9f:f8宿主机IP地址是192.168.199.154;网卡MAC地址:00:26:4d:a1:59:de客户端主机启动cmd键入命令telnet 192.168.199.134 回车显示是否发送密码回车显示login:键入micooz回车显示password:键入micooz回车进入telnet客户端主界面命令行键入net user回车显示结果关闭cmd结束开始分析①建立连接(TCP三次握手)步骤3执行后,telnet客户端开始工作,首先是与虚拟机中的服务端程序建立TCP连接,从抓取的数据包来看,首先关于本次分析的数据包是典型的TCP三次握手,如图所示:由于是我第一次搞网络协议分析,就TCP的三次握手过程也做一个分析吧.主机(192.168.199.154)发送一个连接请求到虚拟机(192.168.199.134),第一个TCP包的格式如图所示:|以太网v2头|ipv4报文|TCP报文|其中以太网v2头是由数据链路层加上去的:1-6bytes是目的地址,也即虚拟机的网卡MAC,7-12bytes是源地址,也即宿主机MAC.13-14(0x0800)是上层协议,这里是IP第二段是ipv4的报文,网际协议IP是工作在网络层,也就是数据链路层的上层,上图数据区选中部分就是ipv4数据,其格式为:可以非常清楚的看到那些教科书上讲到的IPv4报文格式在实际中式如何表现出来的.值得注意的是,IPv4报文中的源地址和目的地址是ip地址,版本号TCP是6,标志字段是010就是禁止下层分段,且是完整的报文第三段是TCP报文,从上面两个可以知道,这个TCP包被层层包装,经过下面一层就相应的包装一层,第三段是经过传输层的数据,TCP报文的格式为:和书本上讲的格式基本一致,这里说明了TCP的源端口52456也就是宿主机建立连接开出来的端口,目的端口23显然是telnet服务默认端口.Sequence number同步序号4bytes,这里是0xa1 21 e2 42,但这里显示的是相对值0.Acknowledgment number确认序号4bytes,为0,因为还是第一个握手包.Header Length头长度32字节,滑动窗口大小8192字节(8MB),校验和,紧急指针为0.Options选项12字节,其中包含最大传输单元MTU默认是1460bytes.再来看看第二个TCP数据包,它是一个来自虚拟机的应答,按照三次握手的原则,这个数据包中TCP报文确认序号应该等于上一个请求包中的同步序号+1,我们来看一下是不是:Pack1. Seq = 0xa1 21 e2 42 Ack = 0x00 00 00 00Pack2. Seq = 0x97 0f 37 11 Ack = 0xa1 21 e2 43看下图更清楚:显然如TCP规定的那样工作. Flags字段中也显示出两个包的标志位.第一个是SYN,第二个是SYN,ACK.那么显然第三个包应该这样工作:Pack1. Seq = 0xa1 21 e2 42 [Ack = 0x00 00 00 00]Pack2. Seq = 0x97 0f 37 11 Ack = 0xa1 21 e2 43Pack3. [Seq = 0xa1 21 e2 43] Ack = 0x97 0f 37 12主机收到Pack2,取出其中Seq+1赋给Ack,然后给虚拟机做出应答. Pack1中的Ack和Pack3中的Seq在一次完整的三次握手中似乎没起到什么作用,如果发生丢失可能会起作用吧,这里没条件去测试.那么,虽然还没正式进入Telnet的核心,但是TCP三次握手的流程基本清晰了.下面小结一下:1.TCP连接的建立通过三次握手完成.2.TCP连接建立从传输层出发,TCP报文包装一个IP报头后形成一个IPv4报文经过网络层,然后再包装一个以太网帧头形成一个Ethernet帧通过数据链路层.3.传输层的TCP报文含有Port端口地址; 网络层的IP报文中含有IP地址; 数据链路层中Ethernet帧含有MAC地址.可见层层地址的不同之处,以及服务对象的不同之处.4.三次握手规则就不再阐述了.②身份确认TCP连接建立后,主机和虚拟机相互交换一些信息,包括服务端的配置信息,主机的应答,是否需要登录等等,并且间断使用TCP包保持连接.当双方信息得到确认后,虚拟机发送欢迎信息(Welcome to Microsoft Telnet Service \r\n),主机做出应答,随后又发送(\n\rlogin:),主机做出应答,然后同步一次,主机在CMD发生中断,接收用户输入,虚拟机等待用户输入.主机输入一个字符就发送一个Telnet报文,然后远程返回一个应答,之后主机发送一个TCP报文.三个一组:Telnet Telnet TCP当然最后还有一个回车符\r\n也要产生三个数据包.回车符发送之后,远端立即回送一个\n\rpassword:要求输入密码.密码输入过程略有不同,一个字符产生两个包,一个是Telnet,一个是TCP.密码明文传输.③命令执行和响应完成密码输入后,服务端验证成功后发送一个Telnet报文询问是否Do Terminal Type开始执行命令行,主机客户端回应Will Terminal Type,将要执行,然后双方发送Suboption End消息,之后服务端放送欢迎消息,如图:那么之后就可以开始输入命令了,我输入的是net user\r\n和之前输入用户名的传输方法基本一样.两个Telnet一个TCP同步.完成输入后回车,服务端执行命令并作出回应:可以看到Administrator Guest HelpAssistant等字样,说明正确返回了执行结果.关闭CMD窗口时,产生了4个TCP包,第一个TCP包设置标志位FIN告知本次通信结束,服务端回应一个TCP,表示做好准备关闭连接,随后又发送一个TCP包设置FIN告知客户端要准备断开连接并断开,客户端应答一个表示已断开.通信结束.这是典型的关闭TCP连接的过程.总结Telnet服务是建立在TCP基础之上的,保证数据的准确性.建立连接后,每键入一个字符就要发送和应答,产生至少2个数据包,开销很大.传统的Telnet由于密码明文传输的问题,帐号和密码等敏感资料容易会被窃听,因此很多服务器都会封锁Telnet服务,改用更安全的SSH.PS:本文是博主第一次尝试使用Wireshark进行网络协议分析,今后可能还会分析互联网其它一些协议,计算机网络也是闲来无事自学的,本身非计算机专业,所以文中难免有专业术语或者概念性错误,还请批评指正!谢谢.]]></content>
      <tags>
        <tag>tech</tag>
        <tag>net</tag>
        <tag>wireshark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++11新特性中的匿名函数Lambda表达式的汇编实现分析（二）]]></title>
    <url>%2F2014%2F06%2F10%2Fcpp-lambda-expression-asm-2%2F</url>
    <content type="text"><![CDATA[C++11新特性中的匿名函数Lambda表达式的汇编实现分析（一）首先，让我们来看看以&amp;方式进行变量捕获，同样没有参数和返回。123456789int main()&#123; int a = 0xB; auto lambda = [&amp;]&#123; a = 0xA; &#125;; lambda(); return 0;&#125; 闭包中将main中a变量改写为0xA。 main中的关键汇编代码： 12345678910111213int a = 0xB; mov dword ptr [ebp-8],0Bh auto lambda = [&amp;]&#123; a = 0xA; &#125;; lea eax,[ebp-8] push eax lea ecx,[ebp-14h] call 002D1BE0 lambda(); lea ecx,[ebp-14h] call 002D1C20 return 0; 同样的，进入闭包前要调用一个拷贝函数。 002D1BE0 内： 123456789101112pop ecx mov dword ptr [ebp-8],ecx mov eax,dword ptr [ebp-8] mov ecx,dword ptr [ebp+8] mov dword ptr [eax],ecx mov eax,dword ptr [ebp-8] pop edi pop esi pop ebx mov esp,ebp pop ebp ret 4 和前面一篇文章中的代码基本一致，但是有两个地方不同， 上文写到： 1234567pop ecx mov dword ptr [ebp-8],ecx mov eax,dword ptr [ebp-8] mov ecx,dword ptr [ebp+8] mov edx,dword ptr [ecx] mov dword ptr [eax],edx mov eax,dword ptr [ebp-8] 注意黑体部分，若采用[=]的捕获方式，那么将通过寄存器edx拷贝原变量的值； 若采用[&amp;]方式，则直接通过ecx拷贝原变量的地址，而不取出值。 闭包内：12345678910111213pop ecx mov dword ptr [ebp-8],ecx a = 0xA;mov eax,dword ptr [ebp-8] mov ecx,dword ptr [eax] mov dword ptr [ecx],0Ah &#125;;pop edi pop esi pop ebx mov esp,ebp pop ebp ret 对a进行赋值，直接是： *this = 0xA; 因为事先this就取到了a的地址。 可以发现，按引用捕获实际上就如同函数参数传递引用，传递的是一个地址值，而不创建对象副本（可以和上一篇文中的内容比较）。 C++11标准中对Lambda表达式的捕获内容还有一些特定支持，比如可以以指定的方式捕获指定的变量： 12345678910int main()&#123; int a = 0xB; bool b = true; auto lambda = [&amp;a,b]&#123; a = b; &#125;; lambda(); return 0;&#125; 上面的代码对a进行引用捕获，对b按值捕获。根据前面分析的结果，可以预见，a的地址和b的值将被拷贝以供闭包函数使用。 123456789101112131415161718int a = 0xB; mov dword ptr [ebp-8],0Bh bool b = true; mov byte ptr [ebp-11h],1 auto lambda = [&amp;a,b]&#123; a = b; &#125;; lea eax,[ebp-11h] push eax lea ecx,[ebp-8] push ecx lea ecx,[ebp-24h] call 00222060 lambda(); lea ecx,[ebp-24h] lambda(); call 00221C20 return 0; 调用Lambda之前，先调用复制函数，传入两个参数，&amp;a和&amp;b，而this被放在main的[ebp-24h]中。 复制函数或者叫准备函数： 12345678910111213141516pop ecx mov dword ptr [ebp-8],ecx mov eax,dword ptr [ebp-8] mov ecx,dword ptr [ebp+8] mov dword ptr [eax],ecx mov eax,dword ptr [ebp-8] mov ecx,dword ptr [ebp+0Ch] mov dl,byte ptr [ecx] mov byte ptr [eax+4],dl mov eax,dword ptr [ebp-8] pop edi pop esi pop ebx mov esp,ebp pop ebp ret 8 [eax] 就是 *this，也即a [eax+4] 就是 *(this+4)，也即b 从内存图可以清楚的看到，a的地址被记录，b的值被复制 闭包函数内： 123456789pop ecx mov dword ptr [ebp-8],ecx a = b;mov eax,dword ptr [ebp-8] movzx ecx,byte ptr [eax+4] mov edx,dword ptr [ebp-8] mov eax,dword ptr [edx] mov dword ptr [eax],ecx b的值是从[eax+4]也即this+4中取出，而a在this中，其实就是： (this) = (this+4); 可以看到闭包内通过this作为基址，对闭包外的变量进行偏移访问。 下一篇中，我将对具有参数和返回值的Lambda表达式进行分析。]]></content>
      <tags>
        <tag>tech</tag>
        <tag>cpp</tag>
        <tag>asm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++11新特性中的匿名函数Lambda表达式的汇编实现分析（三）]]></title>
    <url>%2F2014%2F06%2F10%2Fcpp-lambda-expression-asm-3%2F</url>
    <content type="text"><![CDATA[C++11新特性中的匿名函数Lambda表达式的汇编实现分析（一）C++11新特性中的匿名函数Lambda表达式的汇编实现分析（二）Lambda表达式中较复杂的形式如下：1[ capture ] ( params ) -&gt; ret &#123; body &#125; 现在我们构造一个简单的Lambda闭包函数进行分析： 12345678910int main()&#123; int c = 10; auto lambda = [&amp;] (int a, int b)-&gt;int&#123; return a + b - c; &#125;; int r = lambda(1, 2); return 0;&#125; 上面的代码中，lambda表达式要求传递两个参数a和b，并按引用捕获c，计算后的结果返回给r。 相应的汇编码如下： 123456789101112131415161718int c = 10; mov dword ptr [ebp-8],0Ah auto lambda = [&amp;] (int a, int b)-&gt;int&#123; return a + b - c; &#125;; lea eax,[ebp-8] push eax lea ecx,[ebp-14h] call 010E13B0 int r = lambda(1, 2); push 2 push 1 lea ecx,[ebp-14h] call 010E1400 mov dword ptr [ebp-20h],eax return 0; xor eax,eax 显而易见的，和前面两篇文中的一样，这里仅作简要说明： 由于Lambda表达式中捕获了c，因此这里第一个lea指令，向复制函数传递了c的地址，第二条lea指令向复制函数传递了this用于记录捕获对象的地址， 发生调用时，两个push按照stdcall的方式，从右向左压栈。并向表达式传入了this用于寻址。 lambda调用完毕的返回值默认放在eax中，因此，这里最后一个mov意思是将闭包的函数返回值写入r中。 那么，再看看闭包内如何处理传入参数的以及如何返回的？其实就像普通函数一样的原理，以前的博文也说到过函数调用的汇编原理，这里再简单说说吧。 123456789pop ecx mov dword ptr [ebp-8],ecx return a + b - c;mov eax,dword ptr [ebp+8] add eax,dword ptr [ebp+0Ch] mov ecx,dword ptr [ebp-8] mov edx,dword ptr [ecx] sub eax,dword ptr [edx] 参数[ebp+8] = a ；[ebp+0Ch] = b eax往往是放临时量，edx往往是放地址，按照这个经验，很容易看出，后面两个mov取出this（得到的是&amp;c）然后从a+b中减去(&amp;c)，结果放在eax中，ret返回后供主函数中的r获取之。 三篇博文的总结： C++11中lambda表达式在形式上改变了函数的书写，使函数调用更加简洁灵活，闭包函数也是许多高级语言的特性之一。 Lambda表达式并不是一个神奇的东西，万变不离其宗，他仍然是以一个函数的形式存在于汇编中，底层处理和普通函数基本一样。 Lambda表达式和普通函数在源程序的实现上有不同： Lambda表达式通常被作为参数传递给另一个函数，它本身作为callback，以此避免在其他地方写出完整函数或使用函数指针。 Lambda表达式和普通函数在汇编层上的实现基本相同： 最特殊的地方是，当闭包中要使用本身作用域外的变量时，需要进行“捕获”，而捕获其实是通过另一个隐藏的(源代码不可见)，我叫它复制函数（或者叫准备函数吧）来实现的，具体实现根据捕获方式的不同而不同，大体上是一系列赋值语句。 闭包中通过传入的this指针（不能直接使用）对捕获的变量或者对象进行操作。 关于捕获方式中的按值或者按引用的概念，和普通函数一致。 好了，说到这里，Lambda表达式的底层实现基本说到，本系列博文均属原创，感谢开源中国OSChina提供这样一个学习交流的平台，读者如有其它见解，欢迎评论！]]></content>
      <tags>
        <tag>tech</tag>
        <tag>cpp</tag>
        <tag>asm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++11新特性中的匿名函数Lambda表达式的汇编实现分析（一）]]></title>
    <url>%2F2014%2F06%2F09%2Fcpp-lambda-expression-asm-1%2F</url>
    <content type="text"><![CDATA[Constructs a closure: an unnamed function object capable of capturing variables in scope.—— Lambda functions (since C++11) [cppreference.com]按照C++11标准的说法，lambda表达式的标准格式如下：123456789101112[ capture ] ( params ) mutable exception attribute -&gt; ret &#123; body &#125; // (1) 完整的声明[ capture ] ( params ) -&gt; ret &#123; body &#125; //(2) 一个常lambda的声明：按副本捕获的对象不能被修改。[ capture ] ( params ) &#123; body &#125; // (3) 省略后缀返回值类型：闭包的operator()的返回值类型是根据以下规则推导出的：如果body仅包含单一的return语句，那么返回值类型是返回表达式的类型（在此隐式转换之后的类型：右值到左值、数组与指针、函数到指针）否则，返回类型是void[ capture ] &#123; body &#125;//(4) 省略参数列表：函数没有参数，即参数列表是() capture - 指定哪些在函数声明处的作用域中可见的符号将在函数体内可见。 符号表可按如下规则传入： [a,&amp;b]，按值捕获a，并按引用捕获b [this]，按值捕获了this指针 [&amp;] 按引用捕获在lambda表达式所在函数的函数体中提及的全部自动储存持续性变量 [=] 按值捕获在lambda表达式所在函数的函数体中提及的全部自动储存持续性变量 [] 什么也没有捕获 params - 参数列表，与命名函数一样 ret - 返回值类型。如果不存在，它由该函数的return语句来隐式决定（或者是void，例如当它不返回任何值的时候） body - 函数体 下面，我将从最简单的形式开始逐步对各种形式的lambda表达式进行汇编分析。 首先是最简单的类型（4）： 和普通表达式一样，若单纯的一个表达式将被编译器忽略，这里将lambda表达式赋值给一个栈变量进行分析。 123456int main()&#123; auto lambda = []&#123; &#125;; return 0;&#125; IntelliSense显示这里的lambda变量其实是一个 void lambda()，编译后被解析是main::__l3::void(void)类型，debug查看汇编代码，发现本句并没有在main函数里产生任何汇编代码，但并不代表这个表达式没有意义， 1234567...省略... auto lambda = []&#123; &#125;; return 0; xor eax,eax &#125;...省略... 若使用sizeof(lambda)计算其所占字节数将得到1，稍微在main代码上面一点，可以发现[]{}是作为一个函数被编译： 12345678910111213141516171819202122push ebp mov ebp,esp sub esp,0CCh push ebx push esi push edi push ecx lea edi,[ebp-0CCh] mov ecx,33h mov eax,0CCCCCCCCh rep stos dword ptr es:[edi] pop ecx mov dword ptr [this],ecx pop edi pop esi pop ebx mov esp,ebp pop ebp ret int 3 int 3 可见，就像普通函数一样，[]{}表达式内部被编译为一个函数，该函数内有一个this指针作为栈变量，它指向调用函数时的寄存器ecx。 下面我们执行这个lambda表达式，进入闭包内部分析，同时，为了好说明，在函数内增加一条赋值语句。 12345678int main()&#123; auto lambda = []&#123; int s = 0xA; &#125;; lambda(); return 0;&#125; 对应有汇编代码： 1234567auto lambda = []&#123; int s = 0xA; &#125;; lambda(); lea ecx,[ebp-5] call 001E1570 return 0; 可以看到，有一个地址传送，[ebp-5]的地址送给ecx，然后直接调用闭包函数。 [ebp-5]是main的一个栈变量，占用4字节，他的值没有被初始化，debug版本默认是(0xcccccccc)。 将其地址&amp;[ebp-5]送入ecx究竟有什么含义，不妨先进入闭包函数内部看看： 12345678910111213141516171819202122push ebp mov ebp,esp sub esp,0D8h push ebx push esi push edi push ecx lea edi,[ebp+FFFFFF28h] mov ecx,36h mov eax,0CCCCCCCCh rep stos dword ptr es:[edi] pop ecx mov dword ptr [ebp-8],ecx int s = 0xA;mov dword ptr [ebp-14h],0Ah &#125;;pop edi pop esi pop ebx mov esp,ebp pop ebp ret 可见，刚才的ecx被push保存，然后又在函数初始化栈完成后(rep stos后)，被弹出并写入局部变量[ebp-8]中，而这个[ebp-8]其实就是上面说到的this指针。也就是说，这个this指针指向main中的一个局部变量。 那么，为了进一步研究这个机制，我们设法让这个闭包使用this。不妨猜想一下，this既然是指向main里面的变量，那么他可能是一个base address用来“捕获”（lambda中的概念）闭包外层作用域内的某些变量。“捕获”方式在上面有说到，若将上面的[]改为[=]，让lambda按值捕获main中的int变量s，再看看有什么变化： 123456789int main()&#123; int a = 0xB; auto lambda = [=]&#123; int s = a; &#125;; lambda(); return 0;&#125; 闭包内对应汇编代码： 1234567pop ecx mov dword ptr [ebp-8],ecx int s = a;mov eax,dword ptr [ebp-8] mov ecx,dword ptr [eax] mov dword ptr [ebp-14h],ecx &#125;; 同样的，先放置this指针，然后下面比较关键： 把this临时放到eax 然后再取eax地址对应的值放到临时ecx寄存器中，这里就是a 然后赋值给[ebp-14h]就是s 那么绕了半天做了什么事，其实就是相当于下面的代码： s = *this; 那么这个this确实是指向了main里面的a，如何办到的？ 查看main栈内存发现，传给闭包的this是指向下图中选中部分，而红框中是变量a： 可见，a在main的栈空间被复制了一次，而不是闭包的栈空间，那么复制发生在哪个时候，为什么this恰好就指向了a的副本？ 再调用闭包函数之前，还做了一些事情： 12345678910111213int a = 0xB; mov dword ptr [ebp-8],0Bh auto lambda = [=]&#123; int s = a; &#125;; lea eax,[ebp-8] push eax lea ecx,[ebp-14h] call 010E1BE0 lambda(); lea ecx,[ebp-14h] call 010E1C20 return 0; 发现还call了一个带参函数： 将a的地址送入eax并压栈，相当于给下面的函数传参&amp;a 将给后面闭包用的this保存在ecx中，可能会给下面的一个call使用 上面的操作相当于下面的伪代码： call 010E1BE0(&amp;a , this); //当然，this并不是作为参数传入的，这里只是方便理解 可以预见，010E1BE0函数的作用应该是拷贝a，并让this指向a，空口无凭，进去看看： 1234567891011121314151617181920212223242526push ebp mov ebp,esp sub esp,0CCh push ebx push esi push edi push ecx lea edi,[ebp+FFFFFF34h] mov ecx,33h mov eax,0CCCCCCCCh rep stos dword ptr es:[edi] pop ecx mov dword ptr [ebp-8],ecx mov eax,dword ptr [ebp-8] mov ecx,dword ptr [ebp+8] mov edx,dword ptr [ecx] mov dword ptr [eax],edx mov eax,dword ptr [ebp-8] pop edi pop esi pop ebx mov esp,ebp pop ebp ret 4 前后的代码按部就班，主要是中间： ecx是this不用说了。 先把this保存到该函数的栈空间再说 this放进eax，预见下面的[eax]就是*this，和上面说到的一样 然后是[ebp+8]这块，送给ecx临时保存，然后取值，送入edx临时保存，可见[ebp+8]里面应该是一个地址 edx送给*this 最后那个mov eax，[ebp-8] ，又把this作为返回值 关于[ebp+8]：还记得传入该函数的参数&amp;a吗？没错，[ebp+8]保存的是就是&amp;a。 简单翻译一下这个函数的意思： 1234567fun(&amp;a,this);int* fun(int* in,int* this)&#123; *this = *in; return this;&#125; 注意这里的this传递其实是通过寄存器的方式。 好了，说了半天，刚才那个问题，差不多也知道答案了。 调用闭包函数前，“捕获者”this指针被放在main中，并对其指向的内存块拷贝闭包中要用到的变量值，调用时，this通过寄存器送入闭包中，闭包通过this访问外层作用域(这里是main)的已捕获对象(这里是a)。 可见，如果闭包要按值捕获main中多个变量，那么事先要调用一个复制函数，依次复制所有要用的变量，然后通过this寻址访问main中变量的副本，而不是把所有变量拷贝到闭包的栈空间内。 上面说的都是最简单的形式，也即：[=]{ }，之后的文章将分析更复杂的lambda表达式。今天先说到这。 C++11新特性中的匿名函数Lambda表达式的汇编实现分析（二） 参考资料： C++11中的匿名函数(lambda函数,lambda表达式)Lambda函数]]></content>
      <tags>
        <tag>tech</tag>
        <tag>cpp</tag>
        <tag>asm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQLite3.8.4.2在Windows平台下的编译和使用]]></title>
    <url>%2F2014%2F03%2F30%2Fsqlite-compile-on-windows%2F</url>
    <content type="text"><![CDATA[SQLite is a software library that implements a self-contained, serverless, zero-configuration, transactional SQL database engine. SQLite is the most widely deployed SQL database engine in the world. The source code for SQLite is in thepublic domain.下载源代码可以在下面的链接中找到“Source Code”一栏：http://www.sqlite.org/download.html当前提供了两个下载源，我们选择第一个sqlite-amalgamation-3080402.zip这个是将代码整合过的，解压后应该有下面几个文件：shell.csqlite3.csqlite3ext.hsqlite3.h其中sqlite3.c源文件很大。可以看得出确实是整合在一起的，不过不影响我们编译。编译源代码这里使用Visual Studio 2013进行编译，启动VS2013，选择从现有代码创建项目，如图：项目类型为Visual C++，项目文件位置选择解压的源代码目录，项目名称随便打一个，其他选项默认，下一步。项目类型选择静态库lib(如果你以后要直接把SQLite库打包进exe)，或者选择动态链接库(会独立一个SQLite.dll)，这里就选择静态库lib。然后下一步，下一步，完成就行了。进入项目后，可以在解决方案资源管理器中查看添加进入的头文件和源文件。选择Debug或者Release模式进行编译，这个过程很快就完成了，编译成功会得到响应的lib文件。12345678910111&gt;------ 已启动生成: 项目: test, 配置: Debug Win32 ------1&gt; sqlite3.c1&gt; shell.c1&gt; 正在生成代码...1&gt; test.vcxproj -&gt; xxx \sqlite-amalgamation-3080402\sqlite-amalgamation-3080402\Debug\test.lib========== 生成: 成功 1 个，失败 0 个，最新 0 个，跳过 0 个 ========== 创建项目为了方便操作，我们可以直接在当前解决方案中添加一个项目（这里选择Win32控制台应用程序），如图： 进入新建项目的属性页，添加引用，因为同在一个解决方案下，会找到SQLite的库引用，就不用再去用预处理导入lib文件了。 然后需要包含sqlite的头文件，这里图方便就直接把sqlite项目的头文件Copy过来，注意不要在VS中复制粘贴，因为那是虚链接，我们直接在磁盘进行拷贝，然后在VS中添加现有项就OK。 然后按照官方的演示，直接照抄示例代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445// ConsoleApplication1.cpp : 定义控制台应用程序的入口点。//#include "stdafx.h"#include "sqlite3.h"static int callback(void *NotUsed, int argc, char **argv, char **azColName)&#123; int i; for (i = 0; i &lt; argc; i++) &#123; printf("%s = %s\n", azColName[i], argv[i] ? argv[i] : "NULL"); &#125; printf("\n"); return 0;&#125;int _tmain(int argc, char* argv[])&#123; sqlite3 *db; char *zErrMsg = 0; int rc; if (argc != 3)&#123; fprintf(stderr, "Usage: %s DATABASE SQL-STATEMENT\n", argv[0]); return(1); &#125; rc = sqlite3_open(argv[1], &amp;db); if (rc)&#123; fprintf(stderr, "Can't open database: %s\n", sqlite3_errmsg(db)); sqlite3_close(db); return(1); &#125; rc = sqlite3_exec(db, argv[2], callback, 0, &amp;zErrMsg); if (rc != SQLITE_OK)&#123; fprintf(stderr, "SQL error: %s\n", zErrMsg); sqlite3_free(zErrMsg); &#125; sqlite3_close(db); return 0;&#125; 编译运行，输入参数，然后查看效果。 下面是官方提供的API参考文档： http://www.sqlite.org/c3ref/intro.html 这里就不一一演示了。]]></content>
      <tags>
        <tag>tech</tag>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【cocos2d-x】对CCSprite进行高斯模糊]]></title>
    <url>%2F2014%2F01%2F12%2Fcocos2dx-ccsprite-gaussian-blur%2F</url>
    <content type="text"><![CDATA[你可以从下面的目录找到示例的源代码：cocos2d-x-2.2.1\samples\Cpp\TestCpp\Classes\ShaderTestSpriteBlur类用于实现高斯模糊，但并没有定义在ShaderTest.h中，打开ShaderTest.cpp，大概在488行有这个类的定义和实现：1234567891011121314151617181920// ShaderBlurclass SpriteBlur : public CCSprite&#123;public: ~SpriteBlur(); void setBlurSize(float f); bool initWithTexture(CCTexture2D* texture, const CCRect&amp; rect); void draw(); void initProgram(); void listenBackToForeground(CCObject *obj); static SpriteBlur* create(const char *pszFileName); CCPoint blur_; GLfloat sub_[4]; GLuint blurLocation; GLuint subLocation;&#125;; 实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123SpriteBlur::~SpriteBlur()&#123; CCNotificationCenter::sharedNotificationCenter()-&gt;removeObserver(this, EVENT_COME_TO_FOREGROUND);&#125;SpriteBlur* SpriteBlur::create(const char *pszFileName)&#123; SpriteBlur* pRet = new SpriteBlur(); if (pRet &amp;&amp; pRet-&gt;initWithFile(pszFileName)) &#123; pRet-&gt;autorelease(); &#125; else &#123; CC_SAFE_DELETE(pRet); &#125; return pRet;&#125;void SpriteBlur::listenBackToForeground(CCObject *obj)&#123; setShaderProgram(NULL); initProgram();&#125;bool SpriteBlur::initWithTexture(CCTexture2D* texture, const CCRect&amp; rect)&#123; if( CCSprite::initWithTexture(texture, rect) ) &#123; CCNotificationCenter::sharedNotificationCenter()-&gt;addObserver(this, callfuncO_selector(SpriteBlur::listenBackToForeground), EVENT_COME_TO_FOREGROUND, NULL); CCSize s = getTexture()-&gt;getContentSizeInPixels(); blur_ = ccp(1/s.width, 1/s.height); sub_[0] = sub_[1] = sub_[2] = sub_[3] = 0; this-&gt;initProgram(); return true; &#125; return false;&#125;void SpriteBlur::initProgram()&#123; GLchar * fragSource = (GLchar*) CCString::createWithContentsOfFile( CCFileUtils::sharedFileUtils()-&gt;fullPathForFilename("Shaders/example_Blur.fsh").c_str())-&gt;getCString(); CCGLProgram* pProgram = new CCGLProgram(); pProgram-&gt;initWithVertexShaderByteArray(ccPositionTextureColor_vert, fragSource); setShaderProgram(pProgram); pProgram-&gt;release(); CHECK_GL_ERROR_DEBUG(); getShaderProgram()-&gt;addAttribute(kCCAttributeNamePosition, kCCVertexAttrib_Position); getShaderProgram()-&gt;addAttribute(kCCAttributeNameColor, kCCVertexAttrib_Color); getShaderProgram()-&gt;addAttribute(kCCAttributeNameTexCoord, kCCVertexAttrib_TexCoords); CHECK_GL_ERROR_DEBUG(); getShaderProgram()-&gt;link(); CHECK_GL_ERROR_DEBUG(); getShaderProgram()-&gt;updateUniforms(); CHECK_GL_ERROR_DEBUG(); subLocation = glGetUniformLocation( getShaderProgram()-&gt;getProgram(), "substract"); blurLocation = glGetUniformLocation( getShaderProgram()-&gt;getProgram(), "blurSize"); CHECK_GL_ERROR_DEBUG();&#125;void SpriteBlur::draw()&#123; ccGLEnableVertexAttribs(kCCVertexAttribFlag_PosColorTex ); ccBlendFunc blend = getBlendFunc(); ccGLBlendFunc(blend.src, blend.dst); getShaderProgram()-&gt;use(); getShaderProgram()-&gt;setUniformsForBuiltins(); getShaderProgram()-&gt;setUniformLocationWith2f(blurLocation, blur_.x, blur_.y); getShaderProgram()-&gt;setUniformLocationWith4fv(subLocation, sub_, 1); ccGLBindTexture2D( getTexture()-&gt;getName()); // // Attributes //#define kQuadSize sizeof(m_sQuad.bl) long offset = (long)&amp;m_sQuad; // vertex int diff = offsetof( ccV3F_C4B_T2F, vertices); glVertexAttribPointer(kCCVertexAttrib_Position, 3, GL_FLOAT, GL_FALSE, kQuadSize, (void*) (offset + diff)); // texCoods diff = offsetof( ccV3F_C4B_T2F, texCoords); glVertexAttribPointer(kCCVertexAttrib_TexCoords, 2, GL_FLOAT, GL_FALSE, kQuadSize, (void*)(offset + diff)); // color diff = offsetof( ccV3F_C4B_T2F, colors); glVertexAttribPointer(kCCVertexAttrib_Color, 4, GL_UNSIGNED_BYTE, GL_TRUE, kQuadSize, (void*)(offset + diff)); glDrawArrays(GL_TRIANGLE_STRIP, 0, 4); CC_INCREMENT_GL_DRAWS(1);&#125;void SpriteBlur::setBlurSize(float f)&#123; CCSize s = getTexture()-&gt;getContentSizeInPixels(); blur_ = ccp(1/s.width, 1/s.height); blur_ = ccpMult(blur_,f);&#125; 好了，直接copy到你的program里面，不过有一点需要注意，就是他这个只能用一个文件(图片)create，如果需要用一个Texture初始化(因为有时候需要模糊即时的sprite)，可以稍微改装一下，加一个函数： 1static SpriteBlur* createWithTexture(CCTexture2D *pTexture); 实现： 12345678910111213141516171819SpriteBlur* SpriteBlur::createWithTexture(CCTexture2D *pTexture)&#123; CCAssert(pTexture != NULL, "Invalid texture for sprite"); CCRect rect = CCRectZero; rect.size = pTexture-&gt;getContentSize(); SpriteBlur* pRet = new SpriteBlur(); if (pRet &amp;&amp; pRet-&gt;initWithTexture(pTexture,rect)) &#123; pRet-&gt;autorelease(); &#125; else &#123; CC_SAFE_DELETE(pRet); &#125; return pRet;&#125; 用法： 1234SpriteBlur *bluredSpr = SpriteBlur::createWithTexture(tex);bluredSpr-&gt;setPosition(ccp(sz.width/2,sz.height/2));bluredSpr-&gt;setBlurSize(0.9f); // 这里稍微设小一点addChild(bluredSpr); 效果： 注意： 他需要一个fsh文件（具体看它的实现），似乎是叠texture用的，找到example_Blur.fsh放到你的Resources\Shaders目录下]]></content>
      <tags>
        <tag>tech</tag>
        <tag>cpp</tag>
        <tag>cocos2dx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【C++&汇编】try-catch异常处理机制的汇编实现]]></title>
    <url>%2F2013%2F12%2F21%2Fcpp-try-catch-asm%2F</url>
    <content type="text"><![CDATA[C++中支持使用try-catch的语法处理异常，防止程序崩溃。那么编译器是如何实现的呢？有如下测试代码：1234567891011int main(int argc,char** argv)&#123; try&#123; throw "error"; &#125; catch (char* err)&#123; err = nullptr; &#125; return 0;&#125; 这里直接在try中抛出异常，程序捕获这个异常将错误信息传给err，为了使catch块不被编译器忽略，这里随便附一个值，顺便看看这个nullptr是什么。 编译出的汇编代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465int main(int argc,char** argv)&#123;//ebp用于定位函数局部变量，先保存ebp，然后移动到栈顶00A91410 push ebp 00A91411 mov ebp,esp //数0xFFFFFFFF和地址0A94EF0压栈，这个其实是一个函数的地址(后面有说明)00A91413 push 0FFFFFFFFh 00A91415 push 0A94EF0h //这里出现了一个fs寄存器，取fs的0偏移，即得到“指向SEH链指针”(后面说明)//SEH链指针压栈，ecx压栈00A9141A mov eax,dword ptr fs:[00000000h] 00A91420 push eax 00A91421 push ecx //分配栈空间00A91422 sub esp,0D8h //保护现场00A91428 push ebx 00A91429 push esi 00A9142A push edi 00A9142B lea edi,[ebp-0E8h] //清理栈00A91431 mov ecx,36h 00A91436 mov eax,0CCCCCCCCh 00A9143B rep stos dword ptr es:[edi] //这里把ds:0xA99000(0x6DAAB763,应该是某dword型的标志)的数据和ebp(栈顶)做异或，将结果保存00A9143D mov eax,dword ptr ds:[00A99000h] 00A91442 xor eax,ebp 00A91444 push eax //这里ebp-0c显然是一个SEH链指针，因为它被保存到fs:000A91445 lea eax,[ebp-0Ch] 00A91448 mov dword ptr fs:[00000000h],eax //保存esp是为了什么？00A9144E mov dword ptr [ebp-10h],esp try&#123;//ebp-4这个变量的值很关键，进入try就被清000A91451 mov dword ptr [ebp-4],0 throw "error";//直接一个地址0A96858是静态存储区"error"字符串的首地址，保存到栈空间，临时变量无疑00A91458 mov dword ptr [ebp-0E4h],0A96858h //参数 0A98078 -- 第二个参数比较奇怪00A91462 push 0A98078h //参数 &amp;"error"00A91467 lea eax,[ebp-0E4h] 00A9146D push eax //调用函数 相当于 __CxxThrowException("error",0x0A98078);//该函数从名字上可以略知一二，由于多次调用比较复杂，所以就不分析里面了00A9146E call __CxxThrowException@8 (0A910FAh) &#125; catch (char* err)&#123; err = nullptr;//可以看到nullptr就是000A91473 mov dword ptr [ebp-18h],0 &#125;//标签$LN7位置的指令地址做返回值，返回处理后可能会再次跳到$LN7，而将ebp-4这个变量取反//可能意味着出现错误00A9147A mov eax,0A91489h 00A9147F ret 00A91480 mov dword ptr [ebp-4],0FFFFFFFFh //去return00A91487 jmp $LN7+7h (0A91490h) $LN7:00A91489 mov dword ptr [ebp-4],0FFFFFFFFh return 0;00A91490 xor eax,eax 这里省略最后一个括弧的编译结果，把重点放在try-catch块。 下面对上面的一些地方进行详细说明： 1. 地址0A94EF0 1234567891011__ehhandler$_main:00A94EF0 mov edx,dword ptr [esp+8] 00A94EF4 lea eax,[edx+0Ch] 00A94EF7 mov ecx,dword ptr [edx-0ECh] 00A94EFD xor ecx,eax 00A94EFF call @__security_check_cookie@4 (0A9101Eh) 00A94F04 mov eax,0A9804Ch 00A94F09 jmp ___CxxFrameHandler3 (0A91190h) 00A94F0E int 3 00A94F0F int 3 00A94F10 int 3 2. fs寄存器和SEH链 关于fs寄存器的作用引用一个博客里面的： 123456789101112131415161718192021222324252627FS寄存器指向当前活动线程的TEB结构（线程结构）偏移 说明 000 指向SEH链指针 004 线程堆栈顶部 008 线程堆栈底部 00C SubSystemTib 010 FiberData 014 ArbitraryUserPointer 018 FS段寄存器在内存中的镜像地址 020 进程PID 024 线程ID 02C 指向线程局部存储指针 030 PEB结构地址（进程结构） 034 上个错误号 http://blog.sina.com.cn/s/blog_a5ece79401016os9.html SEH链： (structured exception handling) 是一种处理程序异常的机制，当程序异常 (例如除零异常，非法存取异常，等等) 发生的时候，系统便会把执行位置切换到thread 的 exception handler。 更多关于SEH机制可以参考： http://blog.csdn.net/pofante/article/details/7044028]]></content>
      <tags>
        <tag>tech</tag>
        <tag>cpp</tag>
        <tag>asm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【C#算法实现】QQ小游戏天天连萌(连连看)算法。]]></title>
    <url>%2F2013%2F08%2F22%2Fcsharp-qq-game-ttlm-algorithm%2F</url>
    <content type="text"><![CDATA[算法是程序的灵魂，优秀的算法可以高效率解决实际问题。继腾讯安卓游戏天天爱消除之后又一款十分好玩的游戏——天天连萌，其实就是以前的连连看，在实现算法之前博主从来没有玩过这类游戏，只是看别人玩过，因此在实现之前必须清楚游戏的规则，必须注意许多细节，否则将严重影响算法的准确性，甚至实现了一个完全错误的算法。游戏规则可以总结出来：1.两相消元素必须是同种，这里的同种包括被赋予了某些特殊功能的元素。2.相消元素之间的连线的直角拐角必须小于等于2个。如图所示，红线相连的即可消除，灰线则不符合规则。天天连萌是一个10*5的固定矩阵，每个不同元素可以简记为1,2,3,4…由于含有空白元素，这里约定空格记为0，因此上图中是这样一个数字化的矩阵：现在要解决的问题的办法有两种：1.直接查找，即取任意一个元素，向四个方向进行查找，0代表着”路”可以沿着”路”进行查找同种元素，遇到不同元素还要”拐弯”，三个方向，然后继续沿着0查找，只能拐两次弯。这种方法最容易想到，但是复杂度可想而知， 同时还要判断边界条件。2.找两个相同元素，通过某种方法验证这两个是否可以相消。本文采用的是第二种方法，具体方法是对元素作扩展，这里的扩展是指包括自己在内的上下左右空白区域。再判断扩展区域是否可以连通。现在将该矩阵四周填充路径0，因为连线可以经过整个矩阵外围。为了更好说明，将0用空白代替。任取两个相同元素，比如上面用蓝色标记的两个6，对两个点分别作水平扩展，如下图：再将扩展区域进行垂直投影，找出公共(重叠)部分，比如上图用黑框标注的单元格，再判断他们是否可以直线连通 ，如果可以直线连通那么这两个6就满足规则顺利消除(显然上图中的两个6可以消除 )。如果不能直线连通，那么再作垂直扩展：如上图的两个1的垂直扩展区域可以直线连通，但水平扩展区域不能，满足两者之一即可消除。实现代码如下：将数据放进二维数组：12345678m_data = new int[5, 10]&#123; &#123;1,0,1,0,2,1,0,3,0,4&#125;, &#123;0,5,0,0,4,6,0,0,7,0&#125;, &#123;5,2,7,0,0,0,0,8,2,5&#125;, &#123;0,8,0,0,4,5,0,0,6,0&#125;, &#123;4,0,8,0,2,3,0,1,0,8&#125;&#125;; 考虑到算法的时间复杂度，这里事先将所有相同元素的坐标放进动态数组。 这里采用ArrayList现成的动态数组进行存放坐标点 123456789101112m_same = new ArrayList[10];//假定只有10种for (int x = 0; x &lt; 5; ++x)&#123; for (int y = 0; y &lt; 10; ++y) &#123; int index = m_data[x, y]; if (m_same[index] == null) m_same[index] = new ArrayList(); m_same[index].Add(new point(x, y)); &#125;&#125; 下标代表种类，比如是0的格子放在m_same[0] 中，以此类推… 算法最重要的一步是计算扩展点位： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687private void findEx(ref point pt, out ArrayList rowEx, out ArrayList colEx)&#123; colEx = new ArrayList(); colEx.Add(pt); //纵向 int k = 1; int x = pt.m_x; int y = pt.m_y; bool flag1 = true, flag2 = true;//两个方向是否非空 while (true) &#123; //flag1-&gt;上 flag2-&gt;下 //边界路径 if (x - k == -1 || x + k == 5) &#123; if (x - k == -1 &amp;&amp; flag1 != false) &#123; colEx.Add(new point(x - k, y)); flag1 = false; &#125; if (x + k == 5 &amp;&amp; flag2 != false) &#123; colEx.Add(new point(x + k, y)); flag2 = false; &#125; &#125; if (x - k &gt;= 0 &amp;&amp; x - k &lt;= 4 &amp;&amp; flag1 != false) &#123; if (m_data[x - k, y] == 0) colEx.Add(new point(x - k, y)); else flag1 = false; &#125; if (x + k &gt;= 0 &amp;&amp; x + k &lt;= 4 &amp;&amp; flag2 != false) &#123; if (m_data[x + k, y] == 0) colEx.Add(new point(x + k, y)); else flag2 = false; &#125; if (!flag1 &amp;&amp; !flag2) break; k++; &#125; //横向 rowEx = new ArrayList(); rowEx.Add(pt); k = 1; flag1 = true; flag2 = true; while (true) &#123; //flag1-&gt;左 flag2-&gt;右 //边界路径 if (y - k == -1 || y + k == 10) &#123; if (y - k == -1 &amp;&amp; flag1 != false) &#123; rowEx.Add(new point(x, y - k)); flag1 = false; &#125; if (y + k == 10 &amp;&amp; flag2 != false) &#123; rowEx.Add(new point(x, y + k)); flag2 = false; &#125; &#125; if (y - k &gt;= 0 &amp;&amp; y - k &lt;= 9 &amp;&amp; flag1 != false) &#123; if (m_data[x, y - k] == 0) rowEx.Add(new point(x, y - k)); else flag1 = false; &#125; if (y + k &gt;= 0 &amp;&amp; y + k &lt;= 9 &amp;&amp; flag2 != false) &#123; if (m_data[x, y + k] == 0) rowEx.Add(new point(x, y + k)); else flag2 = false; &#125; if (!flag1 &amp;&amp; !flag2) break; k++; &#125;&#125; 为了简化代码，将竖直方向和水平方向的遍历通过一个k变量来作偏移，通过flag1,flag2标记是否到了”头”. 下面将扩展点位进行连通判断： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364private bool Available(ref point[] pt)&#123; ArrayList[] rowEx, colEx;//建立横纵扩展位 rowEx = new ArrayList[2]; colEx = new ArrayList[2]; //分别计算两点的扩展位置(包括本身) findEx(ref pt[0],out rowEx[0],out colEx[0]); findEx(ref pt[1],out rowEx[1],out colEx[1]); //rowEx[] for (int i = 0; i &lt; rowEx[0].Count; ++i) &#123; for (int j = 0; j &lt; rowEx[1].Count; ++j) &#123; int y1 = ((point)rowEx[0][i]).m_y; int x1 = ((point)rowEx[0][i]).m_x; int y2 = ((point)rowEx[1][j]).m_y; int x2 = ((point)rowEx[1][j]).m_x; if (y1 == y2) &#123; bool flag = true; //公共部分,检查是否连通 for (int k = Math.Min(x1, x2)+1; k &lt; Math.Max(x1, x2); ++k) &#123; if (y1 != -1 &amp;&amp; y1 != 10 &amp;&amp; m_data[k, y1] != 0) &#123; flag = false; break; &#125; &#125; if (y1 == -1 || y1 == 10 || flag) return true; &#125; &#125; &#125; //colEx[] for (int i = 0; i &lt; colEx[0].Count; ++i) &#123; for (int j = 0; j &lt; colEx[1].Count; ++j) &#123; int y1 = ((point)colEx[0][i]).m_y; int x1 = ((point)colEx[0][i]).m_x; int y2 = ((point)colEx[1][j]).m_y; int x2 = ((point)colEx[1][j]).m_x; if (x1 == x2) &#123; bool flag = true; //公共部分,检查是否连通 for (int k = Math.Min(y1, y2) + 1; k &lt; Math.Max(y1, y2); ++k) &#123; if (x1 != -1 &amp;&amp; x1 != 5 &amp;&amp; m_data[x1, k] != 0) &#123; flag = false; break; &#125; &#125; if (x1 == -1 || x1 == 5 || flag) return true; &#125; &#125; &#125; return false;&#125; 之后再将m_same中的元素求组合数，通过上面的函数进行验证就行了。 1234567891011121314151617181920point[] pt = new point[2];for (int i = 1; i &lt; m_same.GetLength(0); ++i)&#123;//遍历ArrayList[] if (m_same[i] != null) &#123; for (int j = 0; j &lt; m_same[i].Count - 1; ++j) &#123;//遍历相同元素集合 for (int k = j + 1; k &lt; m_same[i].Count; ++k) &#123;//取组合数C(n,2) pt[0] = (point)m_same[i][j]; pt[1] = (point)m_same[i][k]; if (Available(ref pt)) m_results.Add(new point[2] &#123; pt[0], pt[1] &#125;); //return pt; &#125; &#125; &#125;&#125;return m_results; 实际运算结果如下图，这里采用了高精度计时器进行算法计时：]]></content>
      <tags>
        <tag>tech</tag>
        <tag>csharp</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【C#算法实现】安卓QQ小游戏天天爱消除辅助。]]></title>
    <url>%2F2013%2F08%2F18%2Fcsharp-qq-game-ttaxc%2F</url>
    <content type="text"><![CDATA[近期腾讯在安卓手机客户端出了个小游戏——天天爱消除。初次玩这款游戏真是觉得自己脑残，玩了半天也只能靠提示进行下去。小伙伴们个个几十万让我几万的情何以堪？！之后想了想如何自动消除，于是有了这篇文。注意这里仅仅是在Windows平台实现了算法，没有应用于android环境，所以想拿现成的辅助程序请出门左拐。算法的实现比较容易，主要是数据结构需要注意，也是一下午就搞定了，初期为了快速开发选用了C#作为实现语言。本文的示例代码将以C#给出。首先分析游戏，消除界面是一个7*7固定的棋盘，有有限种基本棋子(蓝，紫，红，白，咖啡，绿，橘黄)，还有一些特殊功能棋子暂不考虑，下面是一张游戏截图：连成三个通常有几种情况可以考虑，大家在玩的时候应该能体会到，下面的6个图(注意颜色区分)是以32为分析单元的所有情况，对于23其实同理，只不过要转换一下。下面有两个图是14的所有情况(41同理)：在消除的时候通常就是按照上述规律进行的，所以我们只要对棋盘数据进行分割，然后对应上面几种情况，判断固定位置是否是相同的棋子，那么就可以直接知道应该交换哪两个位置了。不同棋子可以用1234..这样简单表示，棋盘数据是一个7*7的二维数组，假设上图是这样一个二维数组：12345678910new int[7, 7] &#123; &#123;4,0,0,4,1,5,3&#125;, &#123;1,2,1,0,1,0,5&#125;, &#123;5,4,6,2,0,4,3&#125;, &#123;2,4,6,5,1,3,5&#125;, &#123;1,5,3,1,0,0,5&#125;, &#123;6,5,3,2,2,1,2&#125;, &#123;1,0,5,2,0,2,2&#125;&#125;; 下面对数据进行23、14划分，由于划分之后要进行判断并返回所在棋盘数组的位置，因此需要定义一个含有位置字段和数据段的一个数据结构 ，位置是通过x、y坐标来定位，也就是数组下标： 123456789101112/// &lt;summary&gt;/// 定义棋子坐标(从0开始)/// &lt;/summary&gt;public struct point&#123; public int m_x; public int m_y; public point(int x, int y) &#123; m_x = x; m_y = y; &#125;&#125;; 为了能够简单初始化，所以给了一个构造函数来初始化成员。 12345678/// &lt;summary&gt;/// 每个棋子都记录一个位置/// &lt;/summary&gt;private struct ele&#123; public point m_pIndex; public int m_data;&#125;; 下面的函数将棋盘数据转化为含有位置信息的新数组,通过成员refData进行存储： 12345678910111213141516/// &lt;summary&gt;/// 将原始数据进行转化/// &lt;/summary&gt;private void ConvertData() &#123; refData = new ele[7, 7]; for (int i = 0; i &lt; 7; ++i) &#123; for (int j = 0; j &lt; 7; ++j) &#123; refData[i, j].m_data = chessData[i, j]; refData[i, j].m_pIndex = new point(i, j); &#125; &#125;&#125; 最重要的就是分析单元的提取，在进行提取之前，我们首先需要定义几个标志位： 123456789//行列计次int s_x = 0;int s_y = 0;//遍历标识bool is_2x3 = true;bool is_3x2 = false;bool is_1x4 = false;bool is_4x1 = false;bool m_bFinished = false; s_x,s_y 是用于定位棋子的变量，因为取32和23的时候需要紧挨着取，保证不能漏掉。 下面4个bool变量标志当前正在取哪种类型的区域。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137/// &lt;summary&gt;/// 返回下一个分析单元/// &lt;/summary&gt;/// &lt;returns&gt;&lt;/returns&gt;private ele[,] GetNextSection()&#123; ele[,] sec = null; //纵向(2*3)遍历 if (s_x &lt;= 5 &amp;&amp; s_y &lt;= 4 &amp;&amp; is_2x3) &#123; sec = new ele[2, 3]&#123; &#123;refData[s_x,s_y],refData[s_x,s_y+1],refData[s_x,s_y+2]&#125;, &#123;refData[s_x+1,s_y],refData[s_x+1,s_y+1],refData[s_x+1,s_y+2]&#125; &#125;; s_x++; //纵向到底 if (s_x == 6) &#123; //右移一个单位 s_x = 0; s_y++; if (s_y == 5) &#123; //遍历完毕 s_x = 0; s_y = 0; is_2x3 = false; is_3x2 = true; is_1x4 = false; is_4x1 = false; &#125; &#125; return sec; &#125; //纵向(3*2)遍历 if (s_x &lt;= 4 &amp;&amp; s_y &lt;= 5 &amp;&amp; is_3x2) &#123; sec = new ele[3, 2]&#123; &#123;refData[s_x,s_y] ,refData[s_x,s_y+1] &#125;, &#123;refData[s_x+1,s_y],refData[s_x+1,s_y+1]&#125;, &#123;refData[s_x+2,s_y],refData[s_x+2,s_y+1]&#125; &#125;; //为简化代码，对3*2的section进行矩阵变换 sec = new ele[2, 3] &#123; &#123;sec[2,0],sec[1,0],sec[0,0]&#125;, &#123;sec[2,1],sec[1,1],sec[0,1]&#125; &#125;; s_x++; //纵向到底 if (s_x == 5) &#123; //右移一个单位 s_x = 0; s_y++; if (s_y == 6) &#123; //遍历完毕 s_x = 0; s_y = 0; is_2x3 = false; is_3x2 = false; is_1x4 = true; is_4x1 = false; &#125; &#125; return sec; &#125; //1*4遍历 if (s_x &lt;= 6 &amp;&amp; s_y &lt;= 3 &amp;&amp; is_1x4) &#123; sec = new ele[1, 4]&#123; &#123;refData[s_x,s_y],refData[s_x,s_y+1],refData[s_x,s_y+2],refData[s_x,s_y+3]&#125; &#125;; s_y++; if (s_y == 4) &#123; //下移一个单位 s_y = 0; s_x++; if (s_x == 7) &#123; //遍历完毕 s_x = 0; s_y = 0; is_2x3 = false; is_3x2 = false; is_1x4 = false; is_4x1 = true; &#125; &#125; return sec; &#125; //4*1遍历 if (s_x &lt;= 3 &amp;&amp; s_y &lt;= 6 &amp;&amp; is_4x1) &#123; sec = new ele[4, 1]&#123; &#123;refData[s_x,s_y]&#125;, &#123;refData[s_x+1,s_y]&#125;, &#123;refData[s_x+2,s_y]&#125;, &#123;refData[s_x+3,s_y]&#125; &#125;; //对4*1的section进行矩阵变换 sec = new ele[1, 4]&#123; &#123;sec[3,0],sec[2,0],sec[1,0],sec[0,0]&#125; &#125;; s_x++; if (s_x == 4) &#123; //下移一个单位 s_x = 0; s_y++; if (s_y == 7) &#123; //遍历完毕 s_x = 0; s_y = 0; is_2x3 = true; is_3x2 = false; is_1x4 = false; is_4x1 = false; m_bFinished = true; //return null; &#125; &#125; return sec; &#125; return sec;&#125; 每次调用函数将返回下一个区域，这就靠自己领悟了。我觉得我写的稍微有点复杂，不过应该比较容易理解，效率上也是相当快的。取一个区域进行分析，这里是连续分析，直到找到一个含有可交换棋子的区域 ： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/// &lt;summary&gt;/// 返回一个可交换位置/// &lt;/summary&gt;/// &lt;returns&gt;&lt;/returns&gt;public point[] GetNextPoints()&#123; point[] pt=null; ele[,] sec; while (pt == null &amp;&amp; !m_bFinished) &#123; sec = GetNextSection(); if (sec == null) return null; if (sec.GetLength(0) == 1) &#123; //有两种情况 if (sec[0, 0].m_data == sec[0, 1].m_data &amp;&amp; sec[0, 0].m_data == sec[0, 3].m_data) &#123; pt = new point[2]&#123; sec[0,2].m_pIndex, sec[0,3].m_pIndex &#125;; &#125; else if (sec[0, 0].m_data == sec[0, 2].m_data &amp;&amp; sec[0, 0].m_data == sec[0, 3].m_data) &#123; pt = new point[2]&#123; sec[0,0].m_pIndex, sec[0,1].m_pIndex &#125;; &#125; &#125; else if (sec.GetLength(0) == 2) &#123; //只有6种可消除情况 if (sec[0, 0].m_data == sec[0, 2].m_data &amp;&amp; sec[0, 0].m_data == sec[1, 1].m_data || sec[0, 1].m_data == sec[1, 0].m_data &amp;&amp; sec[0, 1].m_data == sec[1, 2].m_data) &#123; pt = new point[2]&#123; sec[0,1].m_pIndex, sec[1,1].m_pIndex &#125;; &#125; else if (sec[0, 0].m_data == sec[1, 1].m_data &amp;&amp; sec[0, 0].m_data == sec[1, 2].m_data || sec[1, 0].m_data == sec[0, 1].m_data &amp;&amp; sec[1, 0].m_data == sec[0, 2].m_data) &#123; pt = new point[2]&#123; sec[0,0].m_pIndex, sec[1,0].m_pIndex &#125;; &#125; else if (sec[0, 0].m_data == sec[0, 1].m_data &amp;&amp; sec[0, 0].m_data == sec[1, 2].m_data || sec[1, 0].m_data == sec[1, 1].m_data &amp;&amp; sec[1, 0].m_data == sec[0, 2].m_data) &#123; pt = new point[2]&#123; sec[0,2].m_pIndex, sec[1,2].m_pIndex &#125;; &#125; &#125; &#125;//while return pt;&#125; 这个没什么技术含量，按部就班。现在道德我们想要的两个point了，实际测试情况请看图，为了方便查看，下标进行了+1处理： 算法速度上没有严格测试，但都是瞬间完成的。]]></content>
      <tags>
        <tag>tech</tag>
        <tag>csharp</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【汇编】C++递归调用实现]]></title>
    <url>%2F2013%2F07%2F30%2Fcpp-recursive-call-asm%2F</url>
    <content type="text"><![CDATA[程序调用自身的编程技巧称为递归（ recursion）。一般来说，递归需要有边界条件、递归前进段和递归返回段。当边界条件不满足时，递归前进；当边界条件满足时，递归返回。有一递归算法计算较小整数的阶乘:12345678910111213141516171819int factorial(int x)&#123; int t; if(x==0) t=1; else t=x*factorial(x-1); return t;&#125;int main(int argc,char *argv[])&#123; int x; x=factorial(5); return 0;&#125; 对应有汇编码： 调用时： 123456789101112131415161718192021222324252627282930313233int x; x=factorial(5);00071CAE push 5 00071CB0 call 000711D6 00071CB5 add esp,4 00071CB8 mov dword ptr [ebp-8],eax //和普通函数一样，将参数5压栈，调用完成后恢复堆栈，然后把返回值eax放进变量x递归函数：int t; if(x==0) 000717CE cmp dword ptr [ebp+8],0 000717D2 jne 000717DD //x不为0则跳到else的下一条 t=1; 000717D4 mov dword ptr [ebp-8],1 else000717DB jmp 000717F3 t=x*factorial(x-1);000717DD mov eax,dword ptr [ebp+8] 000717E0 sub eax,1 000717E3 push eax //上面三条指令是计算表达式x-1，其值作为调用本身的参数压入栈内000717E4 call 000711D6 //调用函数000717E9 add esp,4 //恢复堆栈000717EC imul eax,dword ptr [ebp+8] //累乘000717F0 mov dword ptr [ebp-8],eax //给t赋值 return t;000717F3 mov eax,dword ptr [ebp-8] //设置返回值 关键在调用自身时的call 000711D6 这里先call跳转表，然后call该函数。由于是调用本身，再遇到ret指令之前，函数不会返回，因此会不断有压栈操作，每当调用一次函数就会分配一次栈内存，可以预见内存会消耗很快。下面是递归3次的栈内存表现： 除了压栈参数3,4,5（不在同一个栈空间内）之外，还有一些函数创建的数据，可以看到大多”空白”(0xcc)的内存浪费掉了，随着递归次数的增加，内存消耗也越多。 因此当你不到万不得已之前，尽量避免使用递归。]]></content>
      <tags>
        <tag>tech</tag>
        <tag>cpp</tag>
        <tag>asm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【汇编】C++ 数组寻址实现]]></title>
    <url>%2F2013%2F07%2F29%2Fcpp-array-addressing-asm%2F</url>
    <content type="text"><![CDATA[上一节探究C++数组的初始化问题，编译器做了很多事。这一节再来看看数组的寻址问题，数组元素的读取，写入，元素之间的内容传送。有测试代码：123456789101112int main(int argc,char *argv[])&#123; int s[5]=&#123;0&#125;; s[3]=3; int x=s[2]; s[0]=s[1]; return 0;&#125; 第一行是数组的初始化， 第二行是写入值， 第三行读取值， 第四行是数组元素之间的值传递。 下面看看汇编代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546int s[5]=&#123;0&#125;;//数组元素初始化在上一节介绍过，这里不再说明008633D8 mov dword ptr [ebp-1Ch],0 008633DF xor eax,eax 008633E1 mov dword ptr [ebp-18h],eax 008633E4 mov dword ptr [ebp-14h],eax 008633E7 mov dword ptr [ebp-10h],eax 008633EA mov dword ptr [ebp-0Ch],eax s[3]=3;008633ED mov eax,4 008633F2 imul eax,eax,3 008633F5 mov dword ptr [ebp+eax-1Ch],3 /*对数组元素的改写相对容易，注意指令imul为有符号乘法，就是eax=eax*3内存单元[ebp+eax-1Ch]显然表示的是第四个元素s[3]，这里如何算的？ebp是当前main函数的栈底基址，使用ebp加减一个数来访问栈变量；ebp-1Ch是数组s的首地址，eax赋值为sizeof(int),因此s[3]就应该是 [ &amp;s+3*sizeof(int) ] 就是从首地址开始偏移3个元素所占内存大小(字节)*/ int x=s[2];008633FD mov eax,4 00863402 shl eax,1 00863404 mov ecx,dword ptr [ebp+eax-1Ch] 00863408 mov dword ptr [ebp-28h],ecx /*这里指令shl是左移操作，将eax左移1相当于 eax*=2这里的寻址方式和上面有所不同，通过ecx转存给xs[2]=[&amp;s+2*sizeof(int)]这里也可以向上面一样写成：### 008633ED mov eax,4 ### 008633F2 imul eax,eax,2编译器使用shl位操作应该是提升效率，因为位操作的速度非常快*/ s[0]=s[1];0086340B mov eax,4 00863410 shl eax,0 00863413 mov ecx,4 00863418 imul ecx,ecx,0 0086341B mov edx,dword ptr [ebp+eax-1Ch] 0086341F mov dword ptr [ebp+ecx-1Ch],edx/*经过上面的变化，eax=4，ecx=0，其中正如上面一样，ecx是用来寻s[0]，eax是寻s[1]使用edx作为桥梁，实现内存单元之间的赋值*/ 可见C++对于数组元素的引用最重要的一点是数组基址(首地址)，和偏移量，首地址在编译期就可以确定不变，偏移量通过数组元素所占内存大小sizeof(type)和数组索引 [index] 算出，从而找到里面的元素。]]></content>
      <tags>
        <tag>tech</tag>
        <tag>cpp</tag>
        <tag>asm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【汇编】C++ 结构体实现]]></title>
    <url>%2F2013%2F07%2F29%2Fcpp-struct-asm%2F</url>
    <content type="text"><![CDATA[C语言允许用户自己指定这样一种数据结构，它由不同类型的数据组合成一个整体，以便引用，这些组合在一个整体中的数据是互相联系的，这样的数据结构称为结构体。C++结构体中可以使用函数，有下面的测试代码：1234567891011121314151617181920int main(int argc,char *argv[])&#123; struct MyStruct &#123; char *name; int income; int expenses; int profit()&#123; return income-expenses; &#125; &#125;; MyStruct person; person.name="Mike"; person.income=3600; person.expenses=1200; int x=person.profit(); return 0;&#125; 有一个名为MyStruct的结构体，有三个数据成员，有一个函数成员，下面声明一个这样的结构体变量，对其进行赋值，然后调用函数取得返回值。 对应汇编代码如下： 12345678910111213141516171819202122232425262728struct MyStruct &#123; char *name; int income; int expenses; int profit()&#123; return income-expenses; &#125; &#125;;//可以看到上面的声明中并没有编译出任何汇编码，包括函数，只是告诉编译器有这么一个数据结构 MyStruct person; person.name="Mike";00E43A58 mov dword ptr [ebp-14h],0E458A8h //将字符串"Mike"的首地址放进第一个成员char*name指针,这个地址在内存中的表现见下图//通过查看&amp;person和&amp;name可以发现是同一个位置， person.income=3600;00E43A5F mov dword ptr [ebp-10h],0E10h //这里是第二个成员的赋值 person.expenses=1200;00E43A66 mov dword ptr [ebp-0Ch],4B0h //第三个赋值 int x=person.profit();//第四个调用函数00E43A6D lea ecx,[ebp-14h] 00E43A70 call 00E433B0 00E43A75 mov dword ptr [ebp-20h],eax //可以看到先是把这个结构的首地址放进ecx，由于无参数所以没有压栈操作//函数计算结果同样是放在了eax中 字符串”Mike”(0E458A8h): 注意这个Mike周围还有许多英文单词，而且每个字母之间都是00隔开的，这就是所谓的宽字符WCHAR，在Windows编程中常常看到。 再来看看结构体里面的函数编译到哪里去了？ 123456789101112131415161718192021222324252627282930313233343536struct MyStruct &#123; char *name; int income; int expenses; int profit()&#123;//作为函数同样是要分配栈空间00E433B0 push ebp 00E433B1 mov ebp,esp 00E433B3 sub esp,0CCh 00E433B9 push ebx 00E433BA push esi 00E433BB push edi 00E433BC push ecx //由于下面必须要用ecx，这里先压入栈内保存00E433BD lea edi,[ebp+FFFFFF34h] 00E433C3 mov ecx,33h 00E433C8 mov eax,0CCCCCCCCh 00E433CD rep stos dword ptr es:[edi] 00E433CF pop ecx //这里恢复出来00E433D0 mov dword ptr [ebp-8],ecx //把传进来的该结构体地址(相当于this指针)放进栈 return income-expenses;00E433D3 mov eax,dword ptr [ebp-8] 00E433D6 mov ecx,dword ptr [ebp-8] //把this放进eax和ecx，因为下面要用它来寻址00E433D9 mov eax,dword ptr [eax+4] 00E433DC sub eax,dword ptr [ecx+8] //[this+4]就是变量income，[this+8]就是变量expenses，这里用[eax+8]应该也可以//作差后返回 &#125;00E433DF pop edi 00E433E0 pop esi 00E433E1 pop ebx 00E433E2 mov esp,ebp 00E433E4 pop ebp 00E433E5 ret 小结：结构体最关键的还是首地址，或者叫做结构体的this指针，用它可以访问结构体中的每个成员，是通过[this+偏移]来实现的，这个偏移不同所访问到的成员就不同，偏移具体是多少是在编译期分析成员类型决定的。]]></content>
      <tags>
        <tag>tech</tag>
        <tag>cpp</tag>
        <tag>asm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【汇编】C++ 函数调用之——有参有返回调用]]></title>
    <url>%2F2013%2F07%2F27%2Fcpp-function-call-5%2F</url>
    <content type="text"><![CDATA[大多数函数都通过return语句返回一个值，那么被调函数是如何返回的，主调函数又是如何接受的呢？下面让我们来一探究竟。有测试代码：1234567891011int func(int a)&#123; return a+1;&#125;int main(int argc,char *argv[])&#123; //call func int x; x=func(10); return 0;&#125; 这段代码很简单，调用函数func向其传递参数10，然后函数返回10+1=11，并保存到变量x中。 对应有汇编代码： 1234567//call func int x; x=func(10);001A142E push 0Ah 001A1430 call 001A11F4 001A1435 add esp,4 001A1438 mov dword ptr [ebp-8],eax 正如前几篇所讲的函数调用，这里的汇编流程几乎和前面一样，只是这里要接受一个返回值。 重点在最后一个mov指令，他将寄存器eax的内容传送进内存单元[ebp-8]，这个内存单元在main的栈内，其实就是变量x，这个mov显然是为x赋值，赋的是eax。 可以猜测，函数func的返回值是放在了寄存器eax中。 下面为了验证上面的猜想，我们看看func的汇编实现： 123return a+1;001A13EE mov eax,dword ptr [ebp+8] 001A13F1 add eax,1 内存单元[ebp+8]在函数func参数表中，即是参数a，mov指令将参数a传送到eax中add指令将eax的内容加1，似乎并没有所谓的return返回，其实真正意义上的返回是通过ret指令实现的，ret指令将进行一个pop ip；执行之后就返回到了调用func的下一条指令的地方。 现在应该容易理解了，自定义函数的返回值一般是放在eax中的，其实早在【汇编】C++ Win32ConsoleApp main函数的构造分析的时候就提到过： 123 return 0;//将返回值eax清空00B413BE xor eax,eax 函数通过return语句只能返回一个值，这个值大多数情况下放在eax中。所以在调用别的函数时，只要调用完成之后及时把eax的内容取出来就行了。]]></content>
      <tags>
        <tag>tech</tag>
        <tag>cpp</tag>
        <tag>asm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【汇编】C++ 中的数组初始化的实现]]></title>
    <url>%2F2013%2F07%2F27%2Fcpp-array-initialization%2F</url>
    <content type="text"><![CDATA[我们已经知道，数组存放一组数据类型相同的变量，各个变量连续存放，地址由低到高。如整形数组：1int s[5]=&#123;1,2,3,4,5&#125;; 有5个元素。 对应有汇编码： 123456int s[5]=&#123;1,2,3,4,5&#125;;00B917BE mov dword ptr [ebp-18h],1 00B917C5 mov dword ptr [ebp-14h],2 00B917CC mov dword ptr [ebp-10h],3 00B917D3 mov dword ptr [ebp-0Ch],4 00B917DA mov dword ptr [ebp-8],5 可以看到5个元素有5条mov指令对每个元素进行初始化，地址从低到高，其中ebp是main的栈底，查看内存如下： 可以看到确实是连续存放的。 如果这样初始化呢？ 123456789101112131415161718192021222324252627282930313233343536373839int s[5]=&#123;0&#125;;00EA17BE mov dword ptr [ebp-18h],0 00EA17C5 xor eax,eax 00EA17C7 mov dword ptr [ebp-14h],eax 00EA17CA mov dword ptr [ebp-10h],eax 00EA17CD mov dword ptr [ebp-0Ch],eax 00EA17D0 mov dword ptr [ebp-8],eax比较有意思的是先把第一个元素清0，然后再用eax去初始化其他元素，这样做可能是为了效率吧。有另一个问题，就是我们常常要用到一个比较大的缓冲区，比如：char buffer[1024]; 这样的话难道会像上面一样有 1024个mov吗？答案肯定否定的。int s[100]=&#123;0&#125;;000717BE mov dword ptr [ebp+FFFFFE6Ch],0 //首先将s的第一个元素清0000717C8 push 18Ch //再将18c压栈，这个 18c = (100-1)*sizeof(int)，就是数组的字节长度少4//因为第一个元素已经初始化过了000717CD push 0 //将0压栈000717CF lea eax,[ebp+FFFFFE70h] 000717D5 push eax //把地址ebp+FFFFFE70h压栈//上面的三个push应该是为这个call做准备，可以知道这个call有三个参数，那这个call究竟是是什么呢？000717D6 call 000711E0 //找到跳转表看看：################_memset:000711E0 jmp 000713FA 000711E5 int 3 000711E6 int 3 实际上那个call调用了memset函数，但是我们并没有引入任何头文件，我猜想是编译器自动引入了string头文件。还记得上面的push吗？push 396push 0push &amp;s[0]换成高级语言就是 memset(&amp;s[0],0,396)，很明显是一个初始化一段内存的操作################000717DB add esp,0Ch //三个参数，三个DWORD=Ch 看来编译器很是聪明，知道这个时候调用函数来完成初始化操作。当然如果不在声明时初始化数组，那么我们自己也可以直接： memset(s,0,sizeof(s))]]></content>
      <tags>
        <tag>tech</tag>
        <tag>cpp</tag>
        <tag>asm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【汇编】C++ 函数调用之——有参无返回调用（传引用）]]></title>
    <url>%2F2013%2F07%2F27%2Fcpp-function-call-4%2F</url>
    <content type="text"><![CDATA[【汇编】C++ 函数调用之——有参无返回调用（传值）【汇编】C++ 函数调用之——有参无返回调用（传指针）传引用调用函数，就是向被调函数传递的是一个引用类型，而引用是作为变量的别名存在，本质上同样是一个地址。有源代码：1234567891011void func(int &amp;b)&#123; b=10;&#125;int main(int argc,char *argv[])&#123; //call func int a; func(a); return 0;&#125; 此代码向func函数传递一个局部变量a的引用，从而修改这个a的值。 对应有汇编码： main中， 1234567//call func int a; func(a);00931438 lea eax,[ebp-0Ch] 0093143B push eax 0093143C call 009311E5 00931441 add esp,4 可见和传递指针一样，push进去的是a的地址&amp;a func中， 123b=10;009313EE mov eax,dword ptr [ebp+8] 009313F1 mov dword ptr [eax],0Ah 同样，和指针实现并没有任何区别。 小结：传递引用其实是通过指针实现的，传递的是地址，而不是对象的拷贝。]]></content>
      <tags>
        <tag>tech</tag>
        <tag>cpp</tag>
        <tag>asm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【汇编】C++ 函数调用之——有参无返回调用（传指针）]]></title>
    <url>%2F2013%2F07%2F26%2Fcpp-function-call-3%2F</url>
    <content type="text"><![CDATA[【汇编】C++ 函数调用之——有参无返回调用（传值）传地址调用函数顾名思义，就是向被调函数传递的是一个地址值，而不是数据内容，这个地址通常是一个32位无符号整数，表示为十六进制就是形如：0x???? ????，在实际内存中是以(DWORD)形式存放 ，这就是指针类型在内存中通常占用4字节的原因。有源代码：1234567891011void func(int *b)&#123; *b=10;&#125;int main(int argc,char *argv[])&#123; //call func int a; func(&amp;a); return 0;&#125; 这段代码就是通过func函数修改main函数的一个局部变量a。 main函数中对应的汇编码如下所示： 12345678910//call funcint a;func(&amp;a);00911438 lea eax,[ebp-0Ch] 0091143B push eax 0091143C call 009111D1 00911441 add esp,4 //可以看到，传指针时，有一个lea指令，该指令是将局部变量a的地址也就是ebp-0ch传送给寄存器eax//然后将eax压栈，换句话说压栈的内容是&amp;a(ebp-0ch)//后续操作和之前介绍的传值调用一致 为了更直观一些，我们在内存窗口查看这个地址放在哪儿了。然后由这个地址找到a所在内存单元，看是不是0xCCCCCCCC(请参考) &amp;a=0x0109FEE0 PUSH &amp;a 再看看func函数： 12345*b=10;009113EE mov eax,dword ptr [ebp+8] //从栈底偏移+8处取出调用时push的&amp;a，从内存中也可以看出正好是放在那里的009113F1 mov dword ptr [eax],0Ah//注意这里eax存的是&amp;a，作为地址然后找到对应的内存单元，向里面传送10，就是实现了*b=10 内存中是怎么样的呢？ 0x0109FEE0处： 可以看到确实变成了0a 和传值调用唯一的不同就是参数压栈时压的是地址而已。 如果需要向函数传一个对象，而这个对象占用很大的一块内存，如果使用传值方式，则需要在被调函数栈底下面(参数表)push一个对象，相当于完全拷贝这个对象，占用同样的内存空间。 而如果使用传指针，那么仅仅需要push一个4字节的地址值而已，对象没有发生拷贝，大大节省了内存和时间。这就是使用指针的高效处。]]></content>
      <tags>
        <tag>tech</tag>
        <tag>cpp</tag>
        <tag>asm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【汇编】C++ 函数调用之——有参无返回调用（传值）]]></title>
    <url>%2F2013%2F07%2F26%2Fcpp-function-call-2%2F</url>
    <content type="text"><![CDATA[C++函数有参调用有几种传参方式：传值传指针（地址）传引用其中参数可被const修饰，也可以有默认值。下面分情况讨论：为了简洁，省略main函数的汇编码而直接给出func函数的汇编码。有源代码：1234567891011void func(int a,char b)&#123; int c; c=a+b;&#125;int main(int argc,char *argv[])&#123; //call func func(10,'a'); return 0;&#125; 下面看看汇编码： 调用发生时： 12345678//call func func(10,'a');//进行参数压栈操作，首先是'a'压入栈，然后是10压栈，然后call跳转表，再由调转表call函数00F1141E push 61h 00F11420 push 0Ah 00F11422 call 00F1113B //函数调用完成后，栈减小8字节，两个dword，因为CPU对栈的操作都是双字操作，这里两个参数就是两个双字00F11427 add esp,8 具体内存中的表现是这样的（先让func把栈初始化）： 显然不在func的stack内，注意两个参数前面还有两个DWORD， 一个是00f1 1427,另一个是00dd f794；这两个DWORD的产生应该是在PUSH两个参数之后， 又有的两个PUSH，显然，第一个PUSH 00f1 1427是在call 时将ip压栈导致的： 这个ip是当前这条call 指令的下一条指令(add)的地址，请参考上面的main函数。 第二个PUSH是在 func函数中完成的，可以参考func函数的汇编码： 123456789101112131415161718192021222324252627282930void func(int a,char b)&#123;00F113D0 push ebp //这里第二个PUSH，压入ebp，显然这个ebp的值可以在main函数里面看到，//有两条：//## 00F11401 mov ebp,esp //## 00F11403 sub esp,0C0h //那么ebp就是main的栈底00F113D1 mov ebp,esp 00F113D3 sub esp,0CCh 00F113D9 push ebx 00F113DA push esi 00F113DB push edi 00F113DC lea edi,[ebp+FFFFFF34h] 00F113E2 mov ecx,33h 00F113E7 mov eax,0CCCCCCCCh 00F113EC rep stos dword ptr es:[edi] int c; c=a+b;00F113EE movsx eax,byte ptr [ebp+0Ch] 00F113F2 add eax,dword ptr [ebp+8] 00F113F5 mov dword ptr [ebp-8],eax &#125;00F113F8 pop edi 00F113F9 pop esi 00F113FA pop ebx 00F113FB mov esp,ebp 00F113FD pop ebp 00F113FE ret 调用发生时，压入两个参数后，必须再保存下一条指令的位置，因此有一个压栈操作，这个操作是有call指令来完成的。 其次，func函数将ebp压栈是为了为恢复堆栈做准备。因为CPU只有两个寄存器用于堆栈操作：SS:SP，为了调用func函数完成时能进入main的堆栈，必须先保存(push ebp)再恢复(pop ebp),这一点从func函数末尾也看得出。 此外，更直观一点，从内存中看得出：第二个push 00ddf794和func的stack靠的很近: 恰好是指向了main的栈底。 再来看看func里面: 1234567891011int c; c=a+b;00F113EE movsx eax,byte ptr [ebp+0Ch] 00F113F2 add eax,dword ptr [ebp+8] 00F113F5 mov dword ptr [ebp-8],eax //经过分析可以知道：//&amp;b = ebp+0ch//&amp;a = ebp+8//&amp;c = ebp-8//在上面的分析中我们知道这个ebp是指向栈底的，局部变量c在栈内，参数a 和 b 是之前push进来的 经过上述分析，可以得出一些结论： 有参函数调用发生时： 1.先将参数从右向左依次压栈2.将下一条指令的地址压栈3.被调函数将主调函数的栈底位置压栈4.被调函数初始化自己的栈5.取出参数进行运算(并不是pop)6.恢复栈指针7.执行ret恢复(pop)ip，此时程序转到call的下一条add esp8.向下移动栈顶指针sp，所谓的释放局部变量。 可以看到局部变量的”释放”其实是在主调函数中完成的，而不是在被调用函数末尾。 “释放”不是清除内存，而是修改栈指针使局部变量不能访问。]]></content>
      <tags>
        <tag>tech</tag>
        <tag>cpp</tag>
        <tag>asm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【汇编】C++ 函数调用之——局部变量]]></title>
    <url>%2F2013%2F07%2F26%2Fcpp-function-call-1%2F</url>
    <content type="text"><![CDATA[我们知道，栈作为一种数据结构，是一种只能在一端进行插入和删除操作的特殊线性表。它按照后进先出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一个数据被第一个读出来）。C++函数内的参数和局部变量都是存放在栈空间内，那么具体是如何存放和利用的呢？让我们来一探究竟。有如下测试代码：12345678910111213141516void func()&#123; int a; char b; double c; a=97; b=a; c=7.2;&#125;int main(int argc,char *argv[])&#123; //call func func(); return 0;&#125; func函数内有三个类型不相同的变量a,b,c 然后对a,b,c分别赋值。对应的汇编码大致如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104void func()&#123;00B013D0 push ebp 00B013D1 mov ebp,esp 00B013D3 sub esp,0E8h 00B013D9 push ebx 00B013DA push esi 00B013DB push edi 00B013DC lea edi,[ebp+FFFFFF18h] 00B013E2 mov ecx,3Ah 00B013E7 mov eax,0CCCCCCCCh 00B013EC rep stos dword ptr es:[edi] //上面的指令意思同样是分配栈空间，只不过大小变成了3A*4=E8(232)字节//如果没有这三个局部变量和参数，那么分配的空间应该是192字节，232-192=40，//也就是说多分配了40字节 int a; char b; double c;//a,b,c在栈中的位置如下图所示，从汇编也可以看到：//&amp;a = ebp-8h//&amp;b = ebp-11h//&amp;c = ebp-24h//好像并不是想像中的那样相邻存放的，但是依然符合栈的存放特点：从高地址往低地址 a=97;00B013EE mov dword ptr [ebp-8],61h b=a;00B013F5 mov al,byte ptr [ebp-8] 00B013F8 mov byte ptr [ebp-11h],al c=7.2;//这里存7.2的时候是从前面某个内存区域通过双字传送指令实现的，//C语言中7.2默认是double(64位8字节)是一个32位寄存器存放不了的，//因此需要在编译期先放到内存里面，然后拷贝到栈内00B013FB movsd xmm0,mmword ptr ds:[00B058A8h] 00B01403 movsd mmword ptr [ebp-24h],xmm0 &#125;00B01408 pop edi 00B01409 pop esi 00B0140A pop ebx 00B0140B mov esp,ebp 00B0140D pop ebp 00B0140E ret --- 无源文件 -----------------------------------------------------------------------00B0140F int 3 00B01410 int 3 00B01411 int 3 00B01412 int 3 00B01413 int 3 00B01414 int 3 00B01415 int 3 00B01416 int 3 00B01417 int 3 00B01418 int 3 00B01419 int 3 00B0141A int 3 00B0141B int 3 00B0141C int 3 00B0141D int 3 00B0141E int 3 00B0141F int 3 00B01420 int 3 00B01421 int 3 00B01422 int 3 00B01423 int 3 00B01424 int 3 00B01425 int 3 00B01426 int 3 00B01427 int 3 00B01428 int 3 00B01429 int 3 00B0142A int 3 00B0142B int 3 00B0142C int 3 00B0142D int 3 00B0142E int 3 00B0142F int 3 --- f:\cpp\clr\consoleapplication1\源.cpp ---------------------------------------int main(int argc,char *argv[])&#123;00B01430 push ebp 00B01431 mov ebp,esp 00B01433 sub esp,0C0h 00B01439 push ebx 00B0143A push esi 00B0143B push edi 00B0143C lea edi,[ebp+FFFFFF40h] 00B01442 mov ecx,30h 00B01447 mov eax,0CCCCCCCCh 00B0144C rep stos dword ptr es:[edi] //call func func();00B0144E call 00B01082 return 0;00B01453 xor eax,eax &#125;00B01455 pop edi 00B01456 pop esi 00B01457 pop ebx 00B01458 add esp,0C0h 00B0145E cmp ebp,esp 00B01460 call 00B01140 00B01465 mov esp,ebp 00B01467 pop ebp 00B01468 ret func函数栈区内存分布： 其中红框部分是变量a被赋值之前， 现在a被赋值为十进制的97，换成16进制就是 0x0000 0061，和下图一致，注意存放规则！ 高八位存0000，低八位存0061 现在a,b,c都被赋值： 可以看到占用情况： a是int 占4字节；b是char占1字节；c是double占8字节；且a,b,c并未连续存放]]></content>
      <tags>
        <tag>tech</tag>
        <tag>cpp</tag>
        <tag>asm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【汇编】C++ 函数调用分析之——无参调用。]]></title>
    <url>%2F2013%2F07%2F25%2Fcpp-function-call-0%2F</url>
    <content type="text"><![CDATA[由于C++函数调用多种多样，本文将分几个章节分别讲解。首先来最简单的一个无参数调用。有如下测试代码：12345678910void func()&#123; //do nothing here&#125;int main(int argc,char *argv[])&#123; //call func func(); return 0;&#125; 在主函数中调用自定义func函数。 再看看两个函数的汇编码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182void func()&#123;//显然和之前讲过的main的实现雷同，挖一个192字节栈空间，然后填int 3中断(清cc)002F13A0 push ebp 002F13A1 mov ebp,esp 002F13A3 sub esp,0C0h 002F13A9 push ebx 002F13AA push esi 002F13AB push edi 002F13AC lea edi,[ebp+FFFFFF40h] 002F13B2 mov ecx,30h 002F13B7 mov eax,0CCCCCCCCh 002F13BC rep stos dword ptr es:[edi] //do nothing here&#125;002F13BE pop edi 002F13BF pop esi 002F13C0 pop ebx 002F13C1 mov esp,ebp 002F13C3 pop ebp 002F13C4 ret --- 无源文件 -----------------------------------------------------------------------002F13C5 int 3 002F13C6 int 3 002F13C7 int 3 002F13C8 int 3 002F13C9 int 3 002F13CA int 3 002F13CB int 3 002F13CC int 3 002F13CD int 3 002F13CE int 3 002F13CF int 3 --- f:\cpp\clr\consoleapplication1\源.cpp ---------------------------------------int main(int argc,char *argv[])&#123;002F13D0 push ebp 002F13D1 mov ebp,esp 002F13D3 sub esp,0C0h 002F13D9 push ebx 002F13DA push esi 002F13DB push edi 002F13DC lea edi,[ebp+FFFFFF40h] 002F13E2 mov ecx,30h 002F13E7 mov eax,0CCCCCCCCh 002F13EC rep stos dword ptr es:[edi] //call func func();//这里就编译出一条指令 call 002F11D1 这个地址是什么呢，在上面比较远的地方，为了简化，我只取一部分汇编码：##################################_GetLastError@0:002F11BD jmp 002F3972 _RTC_GetErrorFunc:002F11C2 jmp 002F1980 _wcscpy_s:002F11C7 jmp 002F391E @_RTC_AllocaHelper@12:002F11CC jmp 002F1410 func:002F11D1 jmp 002F13A0 ###002F11D1在这里@_RTC_CheckStackVars@8:002F11D6 jmp 002F1820 @_RTC_CheckStackVars2@12:002F11DB jmp 002F39D0 __RTC_CheckEsp:##################################//显然上面call的是一个跳转表里面的func的调转地址，而不是直接call 002F13A0(真正地址)002F13EE call 002F11D1 return 0;002F13F3 xor eax,eax &#125;002F13F5 pop edi 002F13F6 pop esi 002F13F7 pop ebx 002F13F8 add esp,0C0h 002F13FE cmp ebp,esp 002F1400 call 002F11E0 002F1405 mov esp,ebp 002F1407 pop ebp 002F1408 ret C++编译时，把函数地址放到一个跳转表里面，调用函数时，去找跳转表对应函数地址，然后再jmp一次。 可以看到，调用函数需要跳两次，同时，会产生许多指令进行栈操作，不管怎样，调用一个函数必须付出192字节(本例中)代价，不管你有没有使用局部变量。所以尽量避免调用过多无意义的函数。]]></content>
      <tags>
        <tag>tech</tag>
        <tag>cpp</tag>
        <tag>asm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【汇编】C++ Win32ConsoleApp main函数的构造分析]]></title>
    <url>%2F2013%2F07%2F25%2Fcpp-main-asm%2F</url>
    <content type="text"><![CDATA[C++控制台标准main函数的固定格式如下：1234int main(int argc,char *argv[])&#123; return 0;&#125; 有两个参数： 1.argc 整形 记录参数个数(包括路径)2.argv 字符双指针或者叫字符串数组 记录各个参数(包括路径全名) 假设使用下面的命令启动上述代码产生的可执行文件A.exe： C:>A let’s run cpp main 则argc将是5，argv[5]分别是”A”,”let’s”,”run”,”cpp”,”main”的首地址 下面看看汇编结果： 1234567891011121314151617181920212223242526272829303132int main(int argc,char *argv[])&#123;//栈指针上移，为main函数的局部变量预留0xC0的空间 -19100B413A0 push ebp 00B413A1 mov ebp,esp 00B413A3 sub esp,0C0h //注意到main末尾有对应的三个出栈操作，这里入栈是为了保护现场00B413A9 push ebx 00B413AA push esi 00B413AB push edi //之前ebp是被赋值为了esp，代表栈头，用edi记录栈尾位置 +19200B413AC lea edi,[ebp+FFFFFF40h] //重复30h(48)次，每次一个dword(4字节)，48*4恰好是192该函数栈的大小//eax放的是0x0CCCCCCCCh，即int3中断 ，下面三条指令将int 3 中断填满栈//前后内存状态参考图00B413B2 mov ecx,30h 00B413B7 mov eax,0CCCCCCCCh 00B413BC rep stos dword ptr es:[edi] return 0;//将返回值eax清空00B413BE xor eax,eax &#125;//上面push了，这里就pop，恢复现场00B413C0 pop edi 00B413C1 pop esi 00B413C2 pop ebx 00B413C3 mov esp,ebp 00B413C5 pop ebp //恢复cs:ip返回系统调用者00B413C6 ret edi是栈尾位置，下图是执行rep stos 之前： 下图是执行之后：(红色的应该就是这192字节的栈了) 这里可以看到系统调用main函数，函数先申请栈空间，只有192字节，然后将这192字节全部初始化为cc，所以但我们 int a; 之后，这个a就是0xcccc cccc，char b; 这个b就是0xcc(换成ascii码就是一个英文问号?) 所以新手没有对变量初始化打印出来就是所谓的乱码~~~ 这里由于没有使用参数的原因，所以看不到对参数的操作。]]></content>
      <tags>
        <tag>tech</tag>
        <tag>cpp</tag>
        <tag>asm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【汇编】C++条件控制语句分析]]></title>
    <url>%2F2013%2F07%2F24%2Fcpp-condition-statement-asm%2F</url>
    <content type="text"><![CDATA[【测试环境】：Visual Studio Ultimate 2012 (V110)C++中条件控制语句主要分3种：一、单条件结构if(condition){statements}二、带else条件结构if(condition){statements}else{statements}三、多条件结构if(condition1){statements1}else if(condition2){statements2}…else{statements last}本文将对这三类结构进行汇编分析，看看编译器对其的底层实现。帮助我们更好得了解高级编译性语言的实现过程。另外，文末将对简化的条件控制结构——三目运算进行汇编实现分析。首先不妨看看对空statement编译器是如何处理的？有如下代码段：12345678910int main(int argc,char *argv[])&#123; bool test; test=0; if(test) ; return 0;&#125; 编译上述代码，将得到一条警告消息： 警告1warning C4390: “;”: 找到空的受控语句；这是否是有意的? 忽略警告调试程序，将得到下面的汇编码，这里只取{}内的汇编码： 12345678910111213 bool test; test=0;//可见内存单元[ebp-5]就是test变量的位置，且test占用一个字节(byte ptr)//编译器为test随机分配的一块内存，在内存窗口查看该内存单元可以发现该单元周围都被cc (204) 填充，//因此test的准确值为0xcc也就是十进制的204，换成bool就是true//这句将test清0004013BE mov byte ptr [ebp-5],0 //达到if空语句，可见并没有编译出任何汇编码，编译器选择了直接跳过空if语句，因为这条语句本身并没有任何意义。 if(test) ;//将main函数返回值清0 return 0;004013C2 xor eax,eax 下面介绍第一种if结构： 一、单条件结构 if(condition) {statements} 有如下测试代码： 12345678910int main(int argc,char *argv[])&#123; bool test; test=0; if(test) test=1; return 0;&#125; 对应汇编代码如下： 123456789101112131415161718bool test; test=0;000313BE mov byte ptr [ebp-5],0 if(test)//使用movzx指令将一字节test传送至通用寄存器eax中临时保存，根据上述代码可以预见，//传送后eax将变为0x0000 0000000313C2 movzx eax,byte ptr [ebp-5] //将eax与自己本身作And运算 下面两条其实就是 实现了 if(test != 0) ...000313C6 test eax,eax //条件不成立则跳出这个if，执行return 0;000313C8 je 000313CE test=1;//将test置1000313CA mov byte ptr [ebp-5],1 return 0;000313CE xor eax,eax 如果将条件改为if(test==1)，这对应的汇编码变为： 123movzx eax,byte ptr [ebp-5] cmp eax,1 jne 003A13CF 应该容易理解了。 二、带else条件结构 if(condition) {statements}else {statements} 有如下测试代码： 123456789101112int main(int argc,char *argv[])&#123; bool test; test=0; if(test) test=0; else test=1; return 0;&#125; 对应汇编代码： 123456789101112131415161718192021bool test; test=0;003513BE mov byte ptr [ebp-5],0 if(test)003513C2 movzx eax,byte ptr [ebp-5] 003513C6 test eax,eax //主要是看这里，条件不成立不是跳出if，而是跳到test=1这上面了。003513C8 je 003513D0 test=0;003513CA mov byte ptr [ebp-5],0 else//这里有点不好理解，else编译出来是跳出if//如果条件成立，执行test=0;然后跳出if 是符合逻辑的，//编译器在else上下手，创造跳出if的条件，这一点很值得学习003513CE jmp 003513D4 test=1;003513D0 mov byte ptr [ebp-5],1 return 0;003513D4 xor eax,eax 三、多条件结构 if(condition1) {statements1}else if(condition2) {statements2}…else {statements last} 有如下测试代码： 12345678910111213 int main(int argc,char *argv[])&#123; int test=10; if(test==20) test=20; else if(test==30) test=30; else test=10; return 0;&#125; 更换一下test的类型为int，然后进行多条件判断。 对应的汇编代码如下： 1234567891011121314151617181920212223242526272829int test=10;//可见VC下int是双字型(DWORD)，占用4个字节001517CE mov dword ptr [ebp-8],0Ah if(test==20)//将test与20进行比较001517D5 cmp dword ptr [ebp-8],14h //不等则跳到下面一个else if001517D9 jne 001517E4 test=20;001517DB mov dword ptr [ebp-8],14h test=20;//跳出整个 if001517E2 jmp 001517FA else if(test==30)//将test与30进行比较001517E4 cmp dword ptr [ebp-8],1Eh //不等则跳到下一个else if 或else001517E8 jne 001517F3 test=30;001517EA mov dword ptr [ebp-8],1Eh else//跳出整个 if 关键还是最后这个else 上，总会有一个结束整个if的jmp指令001517F1 jmp 001517FA test=10;001517F3 mov dword ptr [ebp-8],0Ah return 0;001517FA xor eax,eax 可见多条件控制语句是依次计算条件成立与否。 最后，看看三目表达式的实现： 有如下测试是代码： 12345678int main(int argc,char *argv[])&#123; int test=10; (test==20)?1:0; return 0;&#125; 为了方便不接收三目表达式的返回值。 对应的汇编代码如下： 1234567891011121314151617 int test=10;00BE17CE mov dword ptr [ebp-8],0Ah (test==20)?1:0;//比较是不是2000BE17D5 cmp dword ptr [ebp-8],14h //不成立则跳到冒号后的语句00BE17D9 jne 00BE17E7 //成立则执行问号后的语句//这里把表达式返回值放进栈空间[ebp-208]00BE17DB mov dword ptr [ebp+FFFFFF30h],1 //跳出表达式00BE17E5 jmp 00BE17F1 00BE17E7 mov dword ptr [ebp+FFFFFF30h],0 return 0;00BE17F1 xor eax,eax 与第二类if结构比较，三目运算则显得更紧凑，逻辑性更强些。语法规则也很简单。]]></content>
      <tags>
        <tag>tech</tag>
        <tag>cpp</tag>
        <tag>asm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【汇编】C++ 循环语句分析]]></title>
    <url>%2F2013%2F07%2F24%2Fcpp-loop-statement-asm%2F</url>
    <content type="text"><![CDATA[测试环境Visual Studio Ultimate 2012 (v110)C++有三种循环控制语句：一.for循环for(initialization;condition;increase){statements;}二.while循环while (expression){statements;}三.do-while循环do{statements;}while (condition);本文将分别利用反汇编分析上述三种循环的底层实现，帮助我们更好的了解循环机制。一.for循环for(initialization;condition;increase){statements;}有如下测试代码段:1234567891011#include &lt;iostream&gt;int main(int argc,char *argv[])&#123; for (int i=0;i&lt;100;++i) &#123; std::cout&lt;&lt;i&lt;&lt;"\n"; &#125; return 0;&#125; 该代码将在控制台输出0-99。 Debug运行查看反汇编码大致如下： 1234567891011121314151617181920212223242526272829303132333435 for (int i=0;i&lt;100;++i)//容易看到内存单元[ebp-8]就是循环变量i的位置，首先将它初始化清000B54F2E mov dword ptr [ebp-8],0 //这里跳转至下面cmp指令00B54F35 jmp main+30h (0B54F40h) //将i放入eax暂存，然后自加1，然后再放回i里面，就是实现i++//内存单元不能直接进行这样的操作：add dword ptr [ebp-8],100B54F37 mov eax,dword ptr [ebp-8] 00B54F3A add eax,1 00B54F3D mov dword ptr [ebp-8],eax //验证i是不是==64h(100)了00B54F40 cmp dword ptr [ebp-8],64h //条件一旦成立，也就是i==100的时候，结束循环00B54F44 jge main+5Fh (0B54F6Fh) &#123; std::cout&lt;&lt;i&lt;&lt;"\n";//打印的实现不是本文的主题，所以略去00B54F46 push 0B5CC74h 00B54F4B mov esi,esp 00B54F4D mov eax,dword ptr [ebp-8] 00B54F50 push eax 00B54F51 mov ecx,dword ptr ds:[0B60310h] 00B54F57 call dword ptr ds:[0B60318h] 00B54F5D cmp esi,esp 00B54F5F call __RTC_CheckEsp (0B51325h) 00B54F64 push eax 00B54F65 call std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; (0B512A3h) 00B54F6A add esp,8 &#125;//这里的&#125;是for的结束位置，编译为一个jmp无条件跳转指令，跳到i++那里，//这样就实现了循环00B54F6D jmp main+27h (0B54F37h) return 0;00B54F6F xor eax,eax 经过上面的分析，可以知道，C++在实现for循环的时候，先后依次进行下面的操作： 1.执行initialization，初始化循环变量2.执行condition，检查条件表达式成立与否3.成立则进行循环，执行statements4.循环返回5.执行increase6.转到第2步，直到condition不再成立 设想：如果将i++生成的三条指令放到 } jmp main+27h (0B54F37h) 之前，是不是也可以顺利执行呢？ 二.while循环 while (expression){ statements;} 有如下测试代码: 12345678910#include &lt;iostream&gt;int main(int argc,char *argv[])&#123; int n=100; while(n--) std::cout&lt;&lt;n&lt;&lt;"\n"; return 0;&#125; 这段代码将打印99-0 对应的汇编码如下： 1234567891011121314151617181920212223242526272829303132int n=100;//显而易见[ebp-8]是n的位置00EC4F2E mov dword ptr [ebp-8],64h while(n--)//将n暂时放入eax00EC4F35 mov eax,dword ptr [ebp-8] //然后再将eax放入栈内[ebp-208]00EC4F38 mov dword ptr [ebp+FFFFFF30h],eax //然后把n放进ecx，自减1之后再放回来，类似上面的i++，这里实现的是n--00EC4F3E mov ecx,dword ptr [ebp-8] 00EC4F41 sub ecx,1 00EC4F44 mov dword ptr [ebp-8],ecx //判断刚才放进n的临时变量是不是0,是的话结束整个while00EC4F47 cmp dword ptr [ebp+FFFFFF30h],0 00EC4F4E je 00EC4F79 //打印略去 std::cout&lt;&lt;n&lt;&lt;"\n";00EC4F50 push 0ECCC74h 00EC4F55 mov esi,esp 00EC4F57 mov eax,dword ptr [ebp-8] 00EC4F5A push eax 00EC4F5B mov ecx,dword ptr ds:[00ED0310h] 00EC4F61 call dword ptr ds:[00ED0318h] 00EC4F67 cmp esi,esp 00EC4F69 call 00EC1325 00EC4F6E push eax 00EC4F6F call 00EC12A3 00EC4F74 add esp,8 00EC4F77 jmp 00EC4F35 return 0;00EC4F79 xor eax,eax 相比for循环，while循环看起来很紧凑，本身也比for简单，由于涉及到一个条件表达式n–，这里判断的时候，要将表达式的返回值放进一个临时变量里面，这里变量是编译器规定的： 1dword ptr [ebp+FFFFFF30h] 同时这里也很明显的看到表达式n–其实返回的是n，因为cmp的是sub ecx,1之前的值，但是此时n已经被减去1了。 如果改为: –n呢？ 暂时不纠结这个前减后减的问题，我们来看看do-while循环怎么样？ 三.do-while循环 do{statements;} while (condition); 同样，有如下测试代码： 123456789101112#include &lt;iostream&gt;int main(int argc,char *argv[])&#123; int n=100; do &#123; std::cout&lt;&lt;n&lt;&lt;"\n"; &#125; while (--n); return 0;&#125; 这段代码将打印100-1 为了和解决刚才遗留的一个问题，我特意写成–n。 对应的汇编代码如下： 1234567891011121314151617181920212223242526272829int n=100;00FD4F2E mov dword ptr [ebp-8],64h do &#123;//打印实现略去 std::cout&lt;&lt;n&lt;&lt;"\n";00FD4F35 push 0FDCC74h 00FD4F3A mov esi,esp 00FD4F3C mov eax,dword ptr [ebp-8] 00FD4F3F push eax 00FD4F40 mov ecx,dword ptr ds:[00FE0310h] 00FD4F46 call dword ptr ds:[00FE0318h] 00FD4F4C cmp esi,esp 00FD4F4E call 00FD1325 00FD4F53 push eax 00FD4F54 call 00FD12A3 00FD4F59 add esp,8 &#125; while (--n);//这里只有4条指令，前三条十分熟悉，实现n自减100FD4F5C mov eax,dword ptr [ebp-8] 00FD4F5F sub eax,1 00FD4F62 mov dword ptr [ebp-8],eax //如果标志位ZF=0则跳转，这个ZF是由sub的运算结果影响的，//当sub的运算结果变成0，则退出循环了。//也就是说这里其实是在看 n减少1之后的结果是不是0，而不是减少前00FD4F65 jne 00FD4F35 return 0;00FD4F67 xor eax,eax 现在将–n改成n– 看看： 结果是打印100-0，多打印了一个0 再看看汇编如何实现？ 12345678&#125; while (n--);00CC4F5C mov eax,dword ptr [ebp-8] 00CC4F5F mov dword ptr [ebp+FFFFFF30h],eax 00CC4F65 mov ecx,dword ptr [ebp-8] 00CC4F68 sub ecx,1 00CC4F6B mov dword ptr [ebp-8],ecx 00CC4F6E cmp dword ptr [ebp+FFFFFF30h],0 00CC4F75 jne 00CC4F35 同样产生一个临时变量，这和刚才while循环的情形十分相似。 这里jne检查由cmp指令影响的标志位，是检查的临时变量而不是已经被减去1的n. 经过上面的验证，可以看到： C++是通过变量的增加或减少，判断条件或者标志位，运用跳转指令来实现循环控制结构的。相比之下，while 和 do while比for更简洁，实际上书写高级语言也是如此。 此外，这里讨论了前减和后减的区别: 后减会产生一个临时变量，并对这个临时变量进行条件判断。前减不会产生临时变量，是对变量本身进行条件判断。 好了，本文到此结束，如有任何疑惑或者说的不恰当的地方还请大家批评指正。]]></content>
      <tags>
        <tag>tech</tag>
        <tag>cpp</tag>
        <tag>asm</tag>
      </tags>
  </entry>
</search>
