<!DOCTYPE html><html class="theme-next pisces" lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=6.1.0" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/uploads/apple-touch-icon.png?v=6.1.0"><link rel="icon" type="image/png" sizes="32x32" href="/uploads/favicon-32x32.png?v=6.1.0"><link rel="icon" type="image/png" sizes="16x16" href="/uploads/favicon-16x16.png?v=6.1.0"><link rel="mask-icon" href="/uploads/logo.svg?v=6.1.0" color="#222"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",version:"6.1.0",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!0,onmobile:!1},fancybox:!1,fastclick:!1,lazyload:!1,tabs:!0,motion:{enable:!1,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><meta name="description" content="FullStack JavaScript Engineer"><meta property="og:type" content="website"><meta property="og:title" content="Micooz"><meta property="og:url" content="https://apporz.com/page/2/index.html"><meta property="og:site_name" content="Micooz"><meta property="og:description" content="FullStack JavaScript Engineer"><meta property="og:locale" content="en"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Micooz"><meta name="twitter:description" content="FullStack JavaScript Engineer"><link rel="alternate" href="/atom.xml" title="Micooz" type="application/atom+xml"><link rel="canonical" href="https://apporz.com/page/2/"><script type="text/javascript" id="page.configurations">CONFIG.page={sidebar:""}</script><title>Micooz</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-72182315-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-72182315-1")</script><noscript><style type="text/css">.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="en"><div class="container sidebar-position-left page-home"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Micooz</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">Make something different!</p></div><div class="site-nav-toggle"><button aria-label="Toggle navigation bar"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>Tags</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>Archives</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>Search</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><section id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://apporz.com/2016/03/22/webpack-review/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Micooz Lee"><meta itemprop="description" content=""><meta itemprop="image" content="/uploads/master.portrait.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Micooz"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2016/03/22/webpack-review/" itemprop="url">webpack复习</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-03-22T00:00:00+08:00">2016-03-22</time> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/2016/03/22/webpack-review/#comments" itemprop="discussionUrl"><span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/03/22/webpack-review/" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><p>使用<code>ProvidePlugin</code>暴露对象到全局：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> webpack.ProvidePlugin(&#123;</span><br><span class="line">    $: <span class="string">'jquery'</span>,</span><br><span class="line">    jQuery: <span class="string">'jquery'</span>,</span><br><span class="line">    <span class="string">'window.jQuery'</span>: <span class="string">'jquery'</span></span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>自定义require返回值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"></span><br><span class="line">externals: &#123;</span><br><span class="line">  <span class="string">'data'</span>: <span class="string">'data data...'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// use in code</span></span><br><span class="line"><span class="keyword">var</span> data = <span class="built_in">require</span>(<span class="string">'data'</span>); <span class="comment">// 'data data...'</span></span><br></pre></td></tr></table></figure>
<p><strong>开启Hot Module Replacement(HMR)</strong></p>
<p>方法一：</p>
<pre><code>$ webpack --hot --inline
</code></pre><ul>
<li>–hot: 添加HotModuleReplacementPlugin</li>
<li>–inline: 在生成的js中添加websocket客户端</li>
</ul>
<p>方法二：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"></span><br><span class="line">entry: &#123;</span><br><span class="line">  <span class="string">'webpack/hot/dev-server'</span>, <span class="comment">// 仅仅是为window添加一个listener</span></span><br><span class="line">  <span class="string">'webpack-dev-server/client?http://localhost:8000'</span> <span class="comment">// websocket客户端</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://apporz.com/2016/03/17/improve-js-performance-by-using-index/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Micooz Lee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/master.portrait.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Micooz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/17/improve-js-performance-by-using-index/" itemprop="url">
                  利用索引提升js的执行效率
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
                
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-03-17T00:00:00+08:00">2016-03-17</time>
            

            
            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/03/17/improve-js-performance-by-using-index/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/03/17/improve-js-performance-by-using-index/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>问题引入：</strong></p><p>前段时间，有一个任务是需要<strong>频繁</strong>在<strong>大量的数据</strong>集合中<strong>快速定位</strong>并修改某个元素某个字段的值。</p><p>数据结构是<strong>数组</strong>，元素的结构可能相当复杂且<strong>乱序</strong>。</p><p><strong>问题分析：</strong></p><p>假定这个数据集如下：</p><pre><code>// array dataset
[{
  name: &apos;name1&apos;,
  body: {
    metadata: {
      header: {
        id: 1 // unique
      }
    }
  },
  ...
}]
</code></pre><p>实际上就是一个<strong>查找算法</strong>问题，假设要从1000条数据中查找id为1的元素，最SB做法是直接遍历整个数据集：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> ele <span class="keyword">of</span> dataset) &#123;</span><br><span class="line">  <span class="keyword">if</span> (ele.body.metadata.header.id === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ele;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最坏的情况是O(n)，当然也可以使用其他常见的查找算法减少遍历次数，但如果要<strong>频繁</strong>查找，同步操作会导致页面直接卡死。</p>
<p>如果有一张<strong>哈希表</strong>就帮大忙了，不妨先想想下面这个问题：</p>
<blockquote>
<p>在数据库里，为什么给一个字段加个索引就可以极大提升查询效率（通常情况）？</p>
</blockquote>
<p><strong>解决方案：</strong></p>
<p>首先理解索引的含义，在js中，数组是线性结构，它的下标可以当成一种索引，通过下标访问元素时间复杂度为O(1)：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> db = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, ...];</span><br><span class="line"><span class="keyword">const</span> ele = db[<span class="number">2</span>]; <span class="comment">// very quick</span></span><br></pre></td></tr></table></figure>
<p>对于一个Object，同样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  col1: <span class="number">1</span>,</span><br><span class="line">  col2: <span class="number">2</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> col2 = obj[<span class="string">'col2'</span>]; <span class="comment">// very quick</span></span><br><span class="line"><span class="keyword">const</span> col2 = obj.col2; <span class="comment">// very quick</span></span><br></pre></td></tr></table></figure>
<p>再看看最开始的那个问题，如果我们可以：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> id = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> ele = dataset[id]; <span class="comment">// very quick</span></span><br></pre></td></tr></table></figure>
<p>实现这个效果实际上就要<strong>建立索引</strong>，此时的 <code>dataset</code> 显然已经不能是最原始的数组了。当id不是数字的时候，<code>dataset</code> 也不能是数组，<br>那么Object就理所当然地充当js里的HashMap了（ES6中已经有标准的<a href="http://es6.ruanyifeng.com/#docs/set-map#Map" target="_blank" rel="noopener">Map</a>实现）。</p>
<p>编写一个通用的索引创建函数，这个函数可以为一个数组，通过传入的回调函数的返回值创建一个包含所有数据引用的索引对象（Object）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> index = <span class="function">(<span class="params">arr, fn</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> indexes = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> it <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = fn(it);</span><br><span class="line">    <span class="keyword">if</span> (!indexes[key]) &#123;</span><br><span class="line">      indexes[key] = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    indexes[key] = it;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> indexes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数只需要<strong>遍历一次数据集</strong>来建立索引。</p>
<p>用法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> our_index = _index(dataset, ele =&gt; ele.body.metadata.header.id);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  "1": &#123;</span></span><br><span class="line"><span class="comment">    name: 'name1',</span></span><br><span class="line"><span class="comment">    body: &#123;</span></span><br><span class="line"><span class="comment">      metadata: &#123;</span></span><br><span class="line"><span class="comment">        header: &#123;</span></span><br><span class="line"><span class="comment">          id: 1 // unique</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  "2": &#123;...&#125;,</span></span><br><span class="line"><span class="comment">  ...</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>有了这个索引 <code>our_index</code>，就可以愉快的以<strong>O(1)</strong>的复杂度来访问任意元素，取出的元素是引用，于是也可以直接对原存储空间的数据进行操作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ele = our_index[<span class="number">1</span>];</span><br><span class="line"><span class="comment">// operation on ele</span></span><br><span class="line">ele.name = <span class="string">'_'</span> + ele.name;</span><br></pre></td></tr></table></figure>
<p><strong>小结</strong></p>
<p>原生JavaScript不支持Map数据结构，因此可以通过对象来实现；关键在于如何根据需要建立索引，建立索引的字段必须满足<strong>唯一性</strong>。</p>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://apporz.com/2016/02/23/angular2-events-bind/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Micooz Lee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/master.portrait.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Micooz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/02/23/angular2-events-bind/" itemprop="url">
                  Angular2 事件绑定注意
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
                
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-02-23T00:00:00+08:00">2016-02-23</time>
            

            
            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/02/23/angular2-events-bind/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/02/23/angular2-events-bind/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> [(<span class="attr">ngModel</span>)]=<span class="string">"value"</span> (<span class="attr">change</span>)=<span class="string">"onSelect(value)"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onSelect(value) &#123;</span><br><span class="line">  <span class="comment">// value 还是原来的值，没来得及改变</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决办法</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">onSelect(value) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// value 绑定完成后的值</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="console-log-或者说Chrome-DevTools的坑"><a href="#console-log-或者说Chrome-DevTools的坑" class="headerlink" title="console.log 或者说Chrome DevTools的坑"></a>console.log 或者说Chrome DevTools的坑</h1><p>考虑下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: []&#125;, n = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">while</span>(n--) &#123;</span><br><span class="line">  obj.a.push(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// obj.a[50]: -100</span></span><br><span class="line"></span><br><span class="line">obj.a[<span class="number">50</span>] = <span class="number">-100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// obj.a[50]: -100</span></span><br></pre></td></tr></table></figure>
<p>浏览器里可以发现两次输出的结果中 <code>a[50]</code> 都是 <code>-100</code>。这一点如果第一次遇到的话还真是匪夷所思。</p>
<p>这里我故意把 <code>a</code> 数组的元素弄得很多，使 <code>DevTools</code> 以 <strong>折叠</strong> 方式显示：</p>
<blockquote>
<p>Object {a: Array[100]}<br>Object {a: Array[100]}</p>
</blockquote>
<p>看似友好的显示方式，实际上里面有很大的问题。</p>
<p>当我们<strong>展开第一个输出</strong>时， <code>DevTools</code> 会 <strong>及时</strong> 读取变量值，由于这是个 <strong>引用</strong> 类型，实际上它读到的是 <code>obj</code> 的最终值，及 <code>a[50]</code> 是 <code>-100</code>。</p>
<p>如果数组a只有很少的元素，<code>DevTools</code> 不启用智能显示时就不会出现这个问题。</p>
<p>也就是说，<code>console.log</code> 到 <code>DevTools</code> 里的实际上<strong>是引用而不是拷贝</strong>，<strong>展开</strong>操作会及时读取变量值。</p>
<p>如果把上面例子的两个输出改成：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj));</span><br></pre></td></tr></table></figure>
<p>结果将和预期的一致。</p>
<p><strong>因此</strong>，在浏览器中调试 <code>js</code> 程序应该以 <code>调试器</code> 下断点为主，日志为辅。</p>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://apporz.com/2016/02/19/angular2-input-bind/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Micooz Lee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/master.portrait.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Micooz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/02/19/angular2-input-bind/" itemprop="url">
                  Angular2 @Input 绑定问题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
                
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-02-19T00:00:00+08:00">2016-02-19</time>
            

            
            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/02/19/angular2-input-bind/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/02/19/angular2-input-bind/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>@Component({
  template: `&lt;child [value]=&quot;bindValue&quot;&gt;&lt;/child&gt;`
})
class HomeComponent {
  bindValue:string = &apos;hello&apos;;
}

@Component({
  selector: &apos;child&apos;,
  template: `...`
})
class ChildComponent{
  @Input() value;

  ngOnInit(){
    // 这里可以取到value的值为&apos;hello&apos;
    // 当bindValue动态改变时，此函数不会再次调用，需要在ngOnChanges中手动更新
  }

  ngOnChanges(changes) {
    // this.value = changes[&apos;value&apos;].currentValue;
    // ...
    // 但是要小心这个函数会被频繁调用，
    // 不要做复杂逻辑
  }
}
</code></pre><h1 id="Array-prototype-map-的坑"><a href="#Array-prototype-map-的坑" class="headerlink" title="Array.prototype.map 的坑"></a>Array.prototype.map 的坑</h1><p>map回调如果不给出返回值，则默认返回 <code>undefined</code>，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" target="_blank" rel="noopener">MDN文档</a>中似乎并未提到这一点。</p><pre><code>var numbers = [1, 4, 9];
var roots = numbers.map(n =&gt; {
  if (n === 4) {
    return -1;
  }
});
// [undefined, -1, undefined]
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://apporz.com/2016/02/18/float-element-z-index-problem/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Micooz Lee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/master.portrait.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Micooz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/02/18/float-element-z-index-problem/" itemprop="url">
                  浮动元素z-index无效问题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
                
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-02-18T00:00:00+08:00">2016-02-18</time>
            

            
            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/02/18/float-element-z-index-problem/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/02/18/float-element-z-index-problem/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>.view-container {
  float: right !important;
  z-index: 999; /* invalid! */

  /* position must be set */
  position: relative;
}
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://apporz.com/2016/02/17/object-assign/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Micooz Lee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/master.portrait.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Micooz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/02/17/object-assign/" itemprop="url">
                  Object.assign
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
                
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-02-17T00:00:00+08:00">2016-02-17</time>
            

            
            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/02/17/object-assign/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/02/17/object-assign/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>const _new = Object.assign(target, {...});
</code></pre><p>会改变 <code>target</code> 本身，引发问题。</p><blockquote><p>The Object.assign() method is used to copy the values of all enumerable own properties from one or more source objects <strong>to</strong> a target object. It will return the target object.</p></blockquote><p>有三个解决办法：</p><p><strong>逐个拷贝</strong></p><pre><code>const _new = {k1: target.k1, k2: target.k2, ...};
</code></pre><p><strong>ES6</strong></p><pre><code>const _new = {...target, ...{...}};
</code></pre><p><strong>（最佳）把第一个参数设成空对象</strong></p><pre><code>const _new = Object.assign({}, target, {...});
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://apporz.com/2016/02/15/angular2-routing-navigation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Micooz Lee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/master.portrait.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Micooz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/02/15/angular2-routing-navigation/" itemprop="url">
                  Angular2 - Routing & Navigation
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
                
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-02-15T00:00:00+08:00">2016-02-15</time>
            

            
            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/02/15/angular2-routing-navigation/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/02/15/angular2-routing-navigation/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><code>@routerCanActive</code> 在加载组件前执行，其回调函数有两种返回方式：</p><pre><code>@routerCanActive(function() {
  // return true; 同步
  // return Promise.resolve(true); 异步
})
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://apporz.com/2015/08/29/docker-lnmp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Micooz Lee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/master.portrait.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Micooz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/08/29/docker-lnmp/" itemprop="url">
                  使用Docker部署PHP应用的设计方案
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
                
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-08-29T00:00:00+08:00">2015-08-29</time>
            

            
            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2015/08/29/docker-lnmp/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/08/29/docker-lnmp/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-Docker"><a href="#1-Docker" class="headerlink" title="1. Docker"></a>1. Docker</h1><p>Docker的官方定义是：</p><blockquote><p>Docker allows you to package an application with all of its dependencies into a standardized unit for software development.</p><p>– <a href="https://www.docker.com/whatisdocker" target="_blank" rel="noopener">https://www.docker.com/whatisdocker</a></p></blockquote><p>毫无疑问的是，Docker解决了应用部署上一个巨大的问题：</p><p>客户: 安装好了，用不了。</p><p>发布者：我的机器上没问题。</p><p>如何解决每个应用的依赖在Docker出现之前是个头疼的问题，现在仅仅通过一次配置，Dockerfile或者image作为最终交付，就能在任何Linux上完美运行了。说起来很简单的样子，但在Docker配置过程中，又存在很多值得思考的问题：应用各个组件如何安排？一个Container解决问题还是细化Container？Container之间何如通信？等等。。下面用一个最普遍的WEB应用配置部署来说明这些问题。</p><p><strong>NOTE</strong>：本文假定读者对Docker中的一些概念有基本的认识，如果不甚了解，我推荐这篇文章：</p><p><a href="https://linux.cn/article-6074-weibo.html" target="_blank" rel="noopener">https://linux.cn/article-6074-weibo.html</a></p><h1 id="2-LNMP"><a href="#2-LNMP" class="headerlink" title="2. LNMP"></a>2. LNMP</h1><p>典型的PHP应用配置方案是LAMP或者LNMP，本文以LNMP为例。</p><p>设计方案如下图:</p><p><img src="202542_DLat_580940.png" alt=""></p><p>应用由4个组件组成，分别是Nginx，PHP-FPM(PHP)，MySQL以及WWW，4个组件运行在由各自镜像创建出来的独立的容器中。其中WWW Container只是一个存储业务代码和静态资源的容器，可以认为是”死”的。</p><p>事实上LNMP架构采用上面的设计方式应该是最容易想到的，也是最清晰的，每个组件有相对的独立性。其中除了WWW容器，其他3个容器都可以直接通过官方镜像构建出来。</p><p>然而网上很多同学并不是这样做的，不会分的这么细，通常是把Nginx和WWW放到一个容器内，或者干脆全部放到一个容器中。可以学习一下大家的Dockerfile:</p><p><a href="https://github.com/search?utf8=✓&amp;q=docker-lnmp" target="_blank" rel="noopener">https://github.com/search?utf8=✓&amp;q=docker-lnmp</a></p><p>细化Container这种设计的优缺点：</p><ol><li>容器间的耦合性增大。可以看到PHP-FPM容器和另外三个容器间有耦合关系，MySQL容器最独立。</li><li>虽然耦合性比较大，但这种端口耦合，文件系统耦合关系可以通过增加几个运行选项解决掉，后面有介绍。</li><li>由于容器对整个架构的划分，使得容器中的内容变得十分独立和安全。例如，我希望在线上更新WWW中的代码，只需要进入WWW容器做修改，不会影响到Nginx，PHP-FPM或者是MySQL。</li><li>各容器可灵活拆卸更换，比如我想把MySQL换成Mongodb，或者干脆把业务代码搬个家，不会影响到其他容器（仅仅更改相关配置文件）</li><li>由于各容器经由官方的镜像创建，因此可以随时花最少的代价使用最新的官方镜像尝鲜。</li><li>占用空间会比较大，一个简单的应用要这么做的话，四个镜像会占用大量的存储空间。</li></ol><h1 id="2-1-容器间通信问题"><a href="#2-1-容器间通信问题" class="headerlink" title="2.1 容器间通信问题"></a>2.1 容器间通信问题</h1><p>细化Container面临着另一个问题，就是如何进行容器间通信。下面简要描述一下上图中的数据流程：</p><ol><li>客户端的http请求达到server的80端口，该端口被映射到Nginx Container的80端口，因此进入Nginx处理。Nginx会分析请求资源，判定是静态资源还是php脚本，如果是静态资源，则直接从WWW中取出发回客户端；如果是脚本程序，则要告诉PHP-FPM到WWW获取相应脚本，然后通过php-cgi处理。</li><li>fast-cgi通过php执行脚本，必要时访问MySQL存取数据。</li></ol><p>这样耦合关系就出来了：</p><ol><li>Nginx需要连接PHP-FPM开放的9000端口，需要访问WWW中的文件系统。</li><li>PHP-FPM也需要访问WWW中的文件系统，还要访问MySQL的3306端口。</li></ol><h1 id="2-2-解决问题"><a href="#2-2-解决问题" class="headerlink" title="2.2 解决问题"></a>2.2 解决问题</h1><p>可以看出有两类耦合关系：端口和文件系统。</p><p>对于端口耦合，docker是通过–link选项解决的；对于文件系统耦合，docker是通过–volumes-from选项解决的。</p><p>解决第一个耦合关系：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -p 80:80 -p 443:443  <span class="comment"># 主机端口映射到容器</span></span><br><span class="line">--volumes-from WWW_CONTAINER_NAME  <span class="comment"># 把WWW容器VOLUME过的文件夹挂载到将启动的容器上</span></span><br><span class="line">--link PHP_FPM_CONTAINER_NAME:fpmservice  <span class="comment"># 冒号前是正在运行的FPM容器名称，后面是别名，别名会作为hostname在将启动的容器内可见</span></span><br><span class="line">-d  <span class="comment"># detach</span></span><br><span class="line">NGINX_IMAGE  <span class="comment"># 镜像名</span></span><br></pre></td></tr></table></figure>
<p>解决第二个耦合关系：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run --volumes-from WWW_CONTAINER_NAME</span><br><span class="line">--link MYSQL_CONTAINER_NAME:mysql</span><br><span class="line">-d</span><br><span class="line">PHP_FPM_IMAGE</span><br></pre></td></tr></table></figure>
<p>参考文档：<a href="https://docs.docker.com/reference/run/" target="_blank" rel="noopener">https://docs.docker.com/reference/run/</a></p>
<p>因此容器启动的先后顺序就出来了：</p>
<ol>
<li>MySQL Container</li>
<li>WWW Container (由于没有任何服务运行，容器run后会立即exit，可以使用 tail -f 等block命令使容器保持运行不退出)</li>
<li>PHP-FPM Container</li>
<li>Nginx Container</li>
</ol>
<p>其中1和2可以对换。</p>
<h1 id="3-Dockerfile"><a href="#3-Dockerfile" class="headerlink" title="3. Dockerfile"></a>3. Dockerfile</h1><p>Dockerfiles 请参见：</p>
<p><a href="https://github.com/micooz/dockerfile" target="_blank" rel="noopener">https://github.com/micooz/dockerfile</a></p>
<p><a href="http://git.oschina.net/micooz/dockerfile" target="_blank" rel="noopener">http://git.oschina.net/micooz/dockerfile</a></p>
<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><p>利用Docker部署Web应用可以带来很多便利，在宏观上实现应用组件化，为实现分布式系统奠定了基础。</p>
<p>可以看到实际上在Docker容器间共享数据是很方便的，搞清楚各容器的依赖关系就不难解决。</p>
<p>P.s. 本文是我学习docker两天后的心得体会，纰漏在所难免，如有错误还请斧正。</p>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://apporz.com/2015/06/02/cpp-template-class-switch-case/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Micooz Lee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/master.portrait.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Micooz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/06/02/cpp-template-class-switch-case/" itemprop="url">
                  C++使用模板类实现任意类型switch和变量case
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
                
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-06-02T00:00:00+08:00">2015-06-02</time>
            

            
            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2015/06/02/cpp-template-class-switch-case/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/06/02/cpp-template-class-switch-case/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近自己维护的一个项目<a href="https://github.com/micooz/program_options" target="_blank" rel="noopener">program_options</a>(是一个命令行生成与解析的C++库)在实际应用的时候遇到一个需求：</p><p>需要switch一个字符串来执行相应代码块，然而原生的switch-case条件选择语法针对condition有严格的限制，下面摘录一段switch的语法标准：</p><h2 id="switch-statement"><a href="#switch-statement" class="headerlink" title="switch statement"></a>switch statement</h2><p>Transfers control to one of the several statements, depending on the value of a condition.</p><p>Syntax</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">attr(optional) switch ( condition ) statement	</span><br><span class="line"></span><br><span class="line">attr(C++11)	-	any number of attributes</span><br><span class="line">condition	-	any expression of integral or enumeration type, or of a class type contextually implicitly convertible to an integral or enumeration type, or a declaration of a single non-array variable of such type with a brace-or-equals initializer.</span><br><span class="line">statement	-	any statement (typically a compound statement). case: and default: labels are permitted in statement and break; statement has special meaning.</span><br><span class="line"></span><br><span class="line">attr(optional) case constant_expression : statement	(1)	</span><br><span class="line">attr(optional) default : statement	(2)	</span><br><span class="line"></span><br><span class="line">constant_expression	-	a constant expression of the same type as the type of condition after conversions and integral promotions</span><br></pre></td></tr></table></figure>
<h3 id="condition"><a href="#condition" class="headerlink" title="condition"></a>condition</h3><p>原生switch语法的condition支持整数，枚举或者根据上下文能够隐式转换为整数或者枚举的类，再或者是非数组类型的=或{}初始化语句，举例来说就是如下四类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(<span class="number">100</span>)</span><br><span class="line"><span class="keyword">enum</span> color &#123;r, g, b&#125;</span><br><span class="line"><span class="keyword">switch</span>(r)</span><br><span class="line"><span class="keyword">switch</span>(<span class="keyword">int</span> n = <span class="number">1</span>)</span><br><span class="line"><span class="keyword">switch</span>(<span class="keyword">int</span> n = &#123;<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="case"><a href="#case" class="headerlink" title="case"></a>case</h3><p>必须是常量，这样一来就无法做变量与变量之间的比较。</p>
<h3 id="statement"><a href="#statement" class="headerlink" title="statement"></a>statement</h3><p>当statement没有被{}包围的时候，在其内使用声明语句会导致编译错误。比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(num)&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>; <span class="comment">// error: jump bypasses variable initialization</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然我的需求不能用原生的switch来实现，得老老实实if-elseif-elseif…来分别判断，导致代码又长又臭，if越套越多，逐条判断效率也让人心塞。</p>
<p>有需求就有想法，有想法就有创新，相信这样的需求早就有人实现过了，比如：</p>
<ul>
<li>为C++添加短字符串的switch-case支持<br>将字符串通过#@转换为整形再进行case</li>
<li>使用C++11新特性，实现用字符串作为switch的case子句<br>利用C++11的constexpr，计算字符串的hash值再进行case</li>
</ul>
<p>想法很不错，但是我想要更灵活的解决方案，我希望新的switch支持switch(object)，case(object)，还希望statement对变量声明没有限制，何不完全抛开原生switch的枷锁，自己利用标准库造一个switch来解决问题呢。</p>
<h2 id="蓝图"><a href="#蓝图" class="headerlink" title="蓝图"></a>蓝图</h2><p>我希望利用C++强大的<strong>template</strong>来兼容任意类型，用C++11的<strong>lambda</strong>匿名函数实现statement，用<strong>操作符重载</strong>operator==来匹配条件，用<strong>hash表</strong>来提升匹配效率，看起来很容易不是吗？</p>
<p>开始Coding之前我先拟定好蓝图：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 蓝图1</span></span><br><span class="line">select(condition, &#123;</span><br><span class="line">  &#123;<span class="string">"case1"</span>, []() &#123;</span><br><span class="line">    <span class="comment">// code goes here</span></span><br><span class="line">  &#125;&#125;,</span><br><span class="line">  &#123;<span class="string">"case2"</span>, []() &#123;</span><br><span class="line">    <span class="comment">// code goes here</span></span><br><span class="line">  &#125;&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 蓝图2</span></span><br><span class="line">select(condition)</span><br><span class="line">  .found(<span class="string">"case1"</span>, []() &#123;</span><br><span class="line">    <span class="comment">// code goes here</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .found(<span class="string">"case2"</span>, []() &#123;</span><br><span class="line">    <span class="comment">// code goes here</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .others([]() &#123;</span><br><span class="line">    <span class="comment">// default</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>我承认我是受到了javascript的影响，我一直以为C++越来越像是一种高级的脚本语言，或许也是它未来的发展趋势。</p>
<p>蓝图的设计首先符合C++的语法规范，没有语法错误，其次力求语义明确，简洁。</p>
<p>蓝图1的大括号太多，书写时容易出错。</p>
<p>蓝图2语法简洁明了，我相信任何会闭包的Coder都能理解。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>有了蓝图后我们就可以照着这个模样来写代码了，首先分析一下蓝图2。</p>
<ul>
<li>存在链式操作，显然select函数要返回一个对象，该对象有found和others方法，并且，found方法要返回实例本身。</li>
<li>condition和found的第一个参数类型必须一致，但不一定是string，也可以是int，Object，可用template实现</li>
<li>found第二个参数是lambda表达式，类型是std::function&lt;…&gt;，类似C里面的函数指针，可定义为回调函数。</li>
<li>每个found块对应于switch里的case，是一个kv关系，可用std::map来存储关联。</li>
</ul>
<p>C++建议模板类的声明和定义必须写在同一个文件里，因此起一个<strong>switch.hpp</strong>文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Ty&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Switch</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Switch()&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Switch</span><span class="params">(<span class="keyword">const</span> Ty&amp; target)</span></span></span><br><span class="line">      : target_(target) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  Switch&amp; found(const Ty&amp; _case, const std::function&lt;void(void)&gt;&amp; callback) &#123;</span><br><span class="line">    reflections_[_case] = callback;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">const</span> Ty&amp; target_;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">const</span> Ty, <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">void</span>)&gt;&gt; reflections_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Ty&gt;</span><br><span class="line">Switch&lt;Ty&gt; select(<span class="keyword">const</span> Ty&amp; expression) &#123;</span><br><span class="line">  <span class="keyword">return</span> Switch&lt;Ty&gt;(expression);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这么一来就实现了found得链式操作，存储了kv对，全局(也可以在某个命名空间内)select函数是一个简化书写的帮助函数，创建对象后返回该对象的拷贝，实现了如下调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select(<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"condition"</span>))</span><br><span class="line">  .found ...</span><br></pre></td></tr></table></figure>
<p>接下来我需要实现查找到对应的target，然后调用它的callback。</p>
<p>增加一个done()方法，该方法被调用意味着结束整个Switch，开始匹配found块，如果没找到，调用others函数(对应default块)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> kv = reflections_.find(target_);</span><br><span class="line">  <span class="keyword">if</span> (kv != reflections_.end()) &#123;</span><br><span class="line">    <span class="comment">// found</span></span><br><span class="line">    <span class="keyword">auto</span> scope = kv-&gt;second;</span><br><span class="line">    scope();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (has_others_scope_) &#123;</span><br><span class="line">    <span class="comment">// not found, call others</span></span><br><span class="line">    others_();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>std::map的find方法时间复杂度是O(logN)，而原生switch匹配时间复杂度是O(1)，肯定是有很大差距的，但是为了实现switch没有的功能，这点损失也是十分值得的。</p>
<p>others方法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">others</span><span class="params">(<span class="keyword">const</span> Scope&amp; callback)</span> </span>&#123;</span><br><span class="line">  has_others_scope_ = <span class="literal">true</span>;</span><br><span class="line">  others_ = callback;</span><br><span class="line">  <span class="keyword">this</span>-&gt;done();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当用户调用others方法定义了default块之后，就没必要再调用done了，又可以减少7个字符的书写。</p>
<p>这里has_others_scope_为bool成员；others_是单独存放的lambda表达式成员，为了简化查找，不宜放在reflections_中。</p>
<p>再简化书写，用typedef缩短类型，然后替换原类中相应类型为短类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">void</span>)&gt; Scope;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">const</span> Ty, Scope&gt; Reflections;</span><br></pre></td></tr></table></figure>
<p>这么一来几乎很完美了，全新的Switch如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> printl(<span class="meta-keyword">line</span>) printf((<span class="meta-keyword">line</span>)); printf(<span class="meta-string">"\n"</span>)</span></span><br><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">condition</span><span class="params">(<span class="string">"windows"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// match std::string</span></span><br><span class="line">select(condition)</span><br><span class="line">  .found(<span class="string">"apple"</span>, []() &#123;</span><br><span class="line">    printl(<span class="string">"it's apple"</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .found(<span class="string">"windows"</span>, []() &#123;</span><br><span class="line">    printl(<span class="string">"it's windows"</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .found(<span class="string">"linux"</span>, []() &#123;</span><br><span class="line">    printl(<span class="string">"it's linux"</span>);</span><br><span class="line">  &#125;).done();</span><br><span class="line"></span><br><span class="line"><span class="comment">// match int</span></span><br><span class="line">select(<span class="number">100</span>)</span><br><span class="line">  .found(<span class="number">10</span>, []() &#123;</span><br><span class="line">    printl(<span class="string">"it's 10"</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .found(<span class="number">20</span>, []() &#123;</span><br><span class="line">    printl(<span class="string">"it's 20"</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .others([]() &#123;</span><br><span class="line">    printl(<span class="string">"nothing found"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="comment">// it's windows</span></span><br><span class="line"><span class="comment">// nothing found</span></span><br></pre></td></tr></table></figure>
<p>我想进一步实现<strong>自定义class</strong>的case，定义一个User类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  explicit User(int age) : age_(age) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> User&amp; user) <span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;age_ &lt; user.age(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> age_; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> age_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Switch如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">User u1(20), u2(22), ux(20);</span><br><span class="line">  select(ux)</span><br><span class="line">    .found(u1, []() &#123;</span><br><span class="line">      printl(<span class="string">"it's u1"</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .found(u2, []() &#123;</span><br><span class="line">      printl(<span class="string">"it's u2"</span>);</span><br><span class="line">    &#125;).done();</span><br><span class="line">  <span class="comment">// it's u2</span></span><br></pre></td></tr></table></figure>
<p>非常有必要说明的是这个重载：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> User&amp; user) <span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;age_ &lt; user.age(); &#125;</span><br></pre></td></tr></table></figure>
<p>返回bool没有问题，但为什么必须是operator&lt;呢，原因在这句：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> kv = reflections_.find(target_);</span><br></pre></td></tr></table></figure>
<p>std::map&lt;&gt;::find不是通过==进行查找的，而是&lt;，因此必须重载&lt;。</p>
<p>该重载必须被const修饰，原因也是find这句里面，const对象只能调用const方法。</p>
<p>标准库里的实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">LIBCPP_TYPE_VIS_ONLY</span> <span class="title">less</span> :</span> binary_function&lt;_Tp, _Tp, <span class="keyword">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x, <span class="keyword">const</span> _Tp&amp; __y)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;<span class="keyword">return</span> __x &lt; __y;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以非常明显的看到const和&lt;。</p>
<p>此外我还实现了Switch之间的found块组合，比较简单就不阐述了。</p>
<h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><p>常量字符串的转型问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select(<span class="string">"condition"</span>)</span><br><span class="line">  .found(<span class="string">"case"</span>, ...)</span><br><span class="line">  .done();</span><br></pre></td></tr></table></figure>
<p>编译器将”condition”理解为const char[10]，数组类型有固定长度，found块的_case参数类型是const char[5]，导致编译错误。原因在于：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Switch&amp; <span class="title">found</span><span class="params">(<span class="keyword">const</span> Ty&amp; _case, <span class="keyword">const</span> Scope&amp; callback)</span></span></span><br></pre></td></tr></table></figure>
<p>这里传递const引用，因此编译器把”case”当做了const char[5]。此时Ty的类型和说好的const char[10]不一致，编译失败。</p>
<p>解决方法是通过std::string来避免数组长度不匹配问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select(<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"condition"</span>))</span><br><span class="line">  .found(<span class="string">"case"</span>, ...)</span><br><span class="line">  .done();</span><br></pre></td></tr></table></figure>
<p>希望读者有更好地解决方案。</p>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>这里直接引用我项目里面的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PROGRAM_OPTIONS_SWITCH_HPP_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROGRAM_OPTIONS_SWITCH_HPP_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> program_options &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief The Switch template class.</span></span><br><span class="line"><span class="comment">* @param Ty The target type.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Ty&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Switch</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">void</span>)&gt; Scope;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">const</span> Ty, Scope&gt; Reflections;</span><br><span class="line"></span><br><span class="line">  Switch() : has_others_scope_(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Switch</span><span class="params">(<span class="keyword">const</span> Ty&amp; target)</span></span></span><br><span class="line">      : target_(target), has_others_scope_(false) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief Create a case block with an expression and a callback function.</span></span><br><span class="line"><span class="comment">   * @param _case The case expression, variable is allowed.</span></span><br><span class="line"><span class="comment">   * @param callback The callback function, can be a lambda expression.</span></span><br><span class="line"><span class="comment">   * @return The current Switch instance.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">Switch&amp; <span class="title">found</span><span class="params">(<span class="keyword">const</span> Ty&amp; _case, <span class="keyword">const</span> Scope&amp; callback)</span> </span>&#123;</span><br><span class="line">    reflections_[_case] = callback;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief Create a default block with a callback function,</span></span><br><span class="line"><span class="comment">   *        if no cases matched, this block will be called.</span></span><br><span class="line"><span class="comment">   * @param callback</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">others</span><span class="params">(<span class="keyword">const</span> Scope&amp; callback)</span> </span>&#123;</span><br><span class="line">    has_others_scope_ = <span class="literal">true</span>;</span><br><span class="line">    others_ = callback;</span><br><span class="line">    <span class="keyword">this</span>-&gt;done();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief Finish the cases,</span></span><br><span class="line"><span class="comment">   * others() will call this method automatically.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> kv = reflections_.find(target_);</span><br><span class="line">    <span class="keyword">if</span> (kv != reflections_.end()) &#123;</span><br><span class="line">      <span class="comment">// found</span></span><br><span class="line">      <span class="keyword">auto</span> scope = kv-&gt;second;</span><br><span class="line">      scope();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (has_others_scope_) &#123;</span><br><span class="line">      <span class="comment">// not found, call others</span></span><br><span class="line">      others_();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief Combine the cases to this Switch from another Switch.</span></span><br><span class="line"><span class="comment">   *        Note that this two Switch should be the same template.</span></span><br><span class="line"><span class="comment">   * @param _switch Another Switch instance.</span></span><br><span class="line"><span class="comment">   * @return</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> Switch&amp; <span class="title">combine</span><span class="params">(<span class="keyword">const</span> Switch&amp; _switch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> kv : _switch.reflections()) &#123;</span><br><span class="line">      <span class="keyword">this</span>-&gt;reflections_[kv.first] = kv.second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief Return the case-callback pairs.</span></span><br><span class="line"><span class="comment">   * @return</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> Reflections <span class="title">reflections</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> reflections_; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">const</span> Ty&amp; target_;</span><br><span class="line">  <span class="keyword">bool</span> has_others_scope_;</span><br><span class="line">  Scope others_;</span><br><span class="line">  Reflections reflections_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Define which expression does the Switch match.</span></span><br><span class="line"><span class="comment"> * @param expression</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Ty&gt;</span><br><span class="line">Switch&lt;Ty&gt; select(<span class="keyword">const</span> Ty&amp; expression) &#123;</span><br><span class="line">  <span class="keyword">return</span> Switch&lt;Ty&gt;(expression);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// PROGRAM_OPTIONS_SWITCH_HPP_</span></span></span><br></pre></td></tr></table></figure>
<p>欢迎各位读者指正。</p>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://apporz.com/2015/02/23/google-cpp-style-guide-note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Micooz Lee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/master.portrait.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Micooz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/02/23/google-cpp-style-guide-note/" itemprop="url">
                  Google C++ Style Guide 笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
                
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-02-23T00:00:00+08:00">2015-02-23</time>
            

            
            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2015/02/23/google-cpp-style-guide-note/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/02/23/google-cpp-style-guide-note/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>英文原版: <a href="http://google-styleguide.googlecode.com/svn/trunk/cppguide.html" target="_blank" rel="noopener">http://google-styleguide.googlecode.com/svn/trunk/cppguide.html</a></p><h1 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h1><p>每个源文件都要对应一个头文件。例外：单元测试文件和仅包含main的小型源文件。</p><h2 id="独立头文件"><a href="#独立头文件" class="headerlink" title="独立头文件"></a>独立头文件</h2><p>以.h结尾的都是应该是独立的，以.inc结尾的仅用作文本包含，所有头文件都必须是独立的。</p><p>inline和template函数的声明和定义(实现)应该在同一个文件中。</p><p>Note:这里的独立是指，用户和重构工具可以无特殊限制地包含头文件。</p><h2 id="define宏保护"><a href="#define宏保护" class="headerlink" title="define宏保护"></a>define宏保护</h2><p>所有头文件都应该使用#define来防止重复包含。格式如下：</p><p>头文件路径：foo/src/bar/baz.h</p><pre><code>&lt;!-- lang: cpp --&gt;
#ifndef FOO_BAR_BAZ_H_
#define FOO_BAR_BAZ_H_

...

#endif  // FOO_BAR_BAZ_H_
</code></pre><h2 id="前置声明"><a href="#前置声明" class="headerlink" title="前置声明"></a>前置声明</h2><p>前置声明用来避免不必要的include，但有很多缺陷。</p><ul><li>当使用在一个头文件中已声明的函数时，总是include那个头文件</li><li>当使用类模板，最好include它的头文件</li><li>当使用一个一般的class时，可以进行前置声明，但是要小心它可能是不完整或不正确的，不确定时，就include合适的头文件</li><li>不要为了避免使用include而把数据成员换成指针</li></ul><h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>仅在函数少于10行时，才可以把函数定义为inline。</p><p>过度使用inline，实际上会使程序变慢。inline一个非常短的函数可以缩短代码长度，而inline一个很长的函数反而会戏剧性地增大代码长度。</p><p>小心析构函数，他们的代码通常比表面上的更长，因为存在虚函数和父析构函数调用。</p><p>虚函数和递归函数不应该被inline。</p><h2 id="参数顺序"><a href="#参数顺序" class="headerlink" title="参数顺序"></a>参数顺序</h2><p>顺序应该是：输入，输出</p><p>输入参数通常是按值，或按const引用传入。输出则是non-const的指针（引用也是指针实现的）。</p><p>当要新增一个参数时，应该按照上面顺序加入。</p><p>注意这个规则不是硬性的，可以放宽这个规则以确保一致性。</p><h2 id="includes的名称和顺序"><a href="#includes的名称和顺序" class="headerlink" title="includes的名称和顺序"></a>includes的名称和顺序</h2><p>顺序：</p><ol><li>关联的头文件 —-&gt; 确保编译当前源文件时提前报错，而不牵扯到别人的文件。</li><li>C库</li><li>C++库</li><li>第三方库</li><li>你的项目头文件</li></ol><p>每个部分再按字典顺序排列。例如：</p><pre><code>&lt;!-- lang: cpp --&gt;
#include &quot;foo/server/fooserver.h&quot;

#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
#include &lt;hash_map&gt;
#include &lt;vector&gt;

#include &quot;base/basictypes.h&quot;
#include &quot;base/commandlineflags.h&quot;
#include &quot;foo/server/bar.h&quot;
</code></pre><p>系统相关的头文件可用宏来限定，以减小代码和保持本地化。</p><pre><code>&lt;!-- lang: cpp --&gt;
#include &quot;foo/public/fooserver.h&quot;

#include &quot;base/port.h&quot;  // For LANG_CXX11.

#ifdef LANG_CXX11
#include &lt;initializer_list&gt;
#endif  // LANG_CXX11
</code></pre><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>在源文件中鼓励使用匿名命名空间（ namespace {…} ），对于非匿名命名空间则选取它的路径来命名。不要使用using namespace。不要使用inline命名空间。</p><h2 id="匿名命名空间"><a href="#匿名命名空间" class="headerlink" title="匿名命名空间"></a>匿名命名空间</h2><ol><li><p>可以避免链接期的名字冲突：</p><p>namespace { // This is in a .cc file.</p><p>// The content of a namespace is not indented.<br>//<br>// This function is guaranteed not to generate a colliding symbol<br>// with other symbols at link time, and is only visible to<br>// callers in this .cc file.<br>bool UpdateInternals(Frobber* f, int newval) {<br>…<br>}</p><p>} // namespace</p></li><li><p>不要在头文件中使用匿名命名空间。</p></li></ol><h2 id="含名称的命名空间"><a href="#含名称的命名空间" class="headerlink" title="含名称的命名空间"></a>含名称的命名空间</h2><ul><li><p>在includes，gflags声明和定义，其他命名空间中class的前置声明之后，包裹全部的代码：</p><p>// In the .h file<br>namespace mynamespace {</p><p>// All declarations are within the namespace scope.<br>// Notice the lack of indentation.<br>class MyClass {<br>public:</p><pre><code>...
void Foo();
</code></pre><p>};</p><p>} // namespace mynamespace<br>// In the .cc file<br>namespace mynamespace {</p><p>// Definition of functions is within scope of the namespace.<br>void MyClass::Foo() {</p><pre><code>...
</code></pre><p>}</p><p>} // namespace mynamespace</p></li><li><p>不要在std中声明任何东西，也不要对标准库的class进行前置声明。</p></li><li><p>不要使用using namespace</p><p>// Forbidden – This pollutes the namespace.<br>using namespace foo;</p></li><li><p>可以在源文件的任意位置，在头文件的函数，方法，class中使用using声明</p><p>// OK in .cc files.<br>// Must be in a function, method or class in .h files.<br>using ::foo::bar;</p></li><li><p>别名命名空间可以在源文件的任意位置，头文件的namespace内，函数，方法内使用。</p><p>// Shorten access to some commonly used names in .cc files.<br>namespace fbz = ::foo::bar::baz;</p><p>// Shorten access to some commonly used names (in a .h file).<br>namespace librarian {<br>// The following alias is available to all files including<br>// this header (in namespace librarian):<br>// alias names should therefore be chosen consistently<br>// within a project.<br>namespace pd_s = ::pipeline_diagnostics::sidetable;</p><p>inline void my_inline_function() {</p><pre><code>// namespace alias local to a function (or method).
namespace fbz = ::foo::bar::baz;
...
</code></pre><p>}<br>} // namespace librarian</p></li></ul><p>Note：尽量避免在公共头文件中使用别名命名空间。</p><ul><li>不要使用inline命名空间</li></ul><h2 id="成员类"><a href="#成员类" class="headerlink" title="成员类"></a>成员类</h2><pre><code>&lt;!-- lang: cpp --&gt;
class Foo {

 private:
  // Bar is a member class, nested within Foo.
  class Bar {
    ...
  };

};
</code></pre><p>不要把成员类公开，除非他们确实是这个接口的一部分。</p><h2 id="非成员，静态成员和全局函数"><a href="#非成员，静态成员和全局函数" class="headerlink" title="非成员，静态成员和全局函数"></a>非成员，静态成员和全局函数</h2><p>最好在命名空间中使用非成员函数，或使用静态成员函数，而不要或很少使用全局函数。</p><p>非成员函数不应该依赖于外部变量，并且应该总处于一个命名空间中。</p><p>那些仅仅用来集结静态成员函数，且没有共享静态数据的类，应该用命名空间取而代之。</p><p>如果必须要使用非成员函数并且只在当前这个源文件中使用，则用一个匿名命名空间或static修饰来限制它的作用域。</p><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>将一个函数中的变量放到尽可能有限的作用域内，并在声明时初始化。</p><pre><code>&lt;!-- lang: cpp --&gt;
int i;
i = f();      // Bad -- initialization separate from declaration.
int j = g();  // Good -- declaration has initialization.
vector&lt;int&gt; v;
v.push_back(1);  // Prefer initializing using brace initialization.
v.push_back(2);
vector&lt;int&gt; v = {1, 2};  // Good -- v starts initialized.
</code></pre><p>一些供if,while,for使用的变量应该在statement处声明。</p><pre><code>&lt;!-- lang: cpp --&gt;
while (const char* p = strchr(str, &apos;/&apos;)) str = p + 1;
</code></pre><p>一点注意：如果是变量是一个对象，构造函数将在每次进入作用域时被执行，析构函数将在每次离开作用域时被执行。</p><pre><code>&lt;!-- lang: cpp --&gt;
// Inefficient implementation:
for (int i = 0; i &lt; 1000000; ++i) {
  Foo f;  // My ctor and dtor get called 1000000 times each.
  f.DoSomething(i);
}
// 对象放在外面更高效
Foo f;  // My ctor and dtor get called once each.
for (int i = 0; i &lt; 1000000; ++i) {
  f.DoSomething(i);
}
</code></pre><h2 id="静态和全局变量"><a href="#静态和全局变量" class="headerlink" title="静态和全局变量"></a>静态和全局变量</h2><p>类的静态或全局变量是禁止使用的。然而constexpr的变量是被允许的，因为他们不会动态初始化或销毁。</p><p>静态存储的对象，包括全局变量，静态变量，静态类成员变量以及函数内静态变量，必须是Plain Old Data(POD)。</p><p>只有int,char,float,pointer,或者arrays/structs属于POD。</p><p>静态vector应该用C数组代替，静态string应该用const char []代替。</p><p>如果需要使用静态或全局类对象，考虑初使用它的指针类型（不会被order-of-destrctor释放掉），注意必须是一个纯的指针，而不是一个智能指针。</p><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><h2 id="构造函数该做的事"><a href="#构造函数该做的事" class="headerlink" title="构造函数该做的事"></a>构造函数该做的事</h2><p>避免在构造函数中进行复杂初始化，比如那些可能会失败或者进行虚函数调用的步骤。</p><p>构造函数不应该调用虚函数，或者试图抛出非致命性错误。如果你的对象需要进行重要的初始化工作，考虑使用一个工厂函数或init方法。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h2 id="明确构造函数"><a href="#明确构造函数" class="headerlink" title="明确构造函数"></a>明确构造函数</h2><p>在具有一个参数的构造函数上使用explicit关键字。因为构造时传入一个参数可能会被编译器当做拷贝构造进行隐式转换。</p><pre><code>&lt;!-- lang: cpp --&gt;
explicit Foo(string name);
</code></pre><p>除了构造函数的第一个参数外，其他参数都应该指定一个默认值,来防止不期望的类型转换。</p><pre><code>&lt;!-- lang: cpp --&gt;
Foo::Foo(string name, int id = 42)
</code></pre><p>拷贝构造函数，以及作为其他类的透明包装的类，不应该被explicit修饰。</p><h2 id="可拷贝和可移动类型"><a href="#可拷贝和可移动类型" class="headerlink" title="可拷贝和可移动类型"></a>可拷贝和可移动类型</h2><p>可拷贝的例子：std::string</p><p>可移动但不可拷贝的例子：std::unique_ptr<int></int></p><p>对于一些不需要拷贝操作的类型，提供拷贝操作符可能会产生混淆，无意义或者完全是不正确的。</p><p>基类的拷贝、赋值操作符是有风险的，他们会导致对象分裂。</p><p>如果要加入拷贝特性，就要同时定义拷贝构造函数和赋值操作符。</p><p>如果你的类型可拷贝，但移动操作符更高效，那么就同时定义移动操作。</p><p>避免给试图被继承的类提供赋值操作符或公开的拷贝/移动构造函数。</p><p>如果你的基类需要被拷贝，提供一个公开的虚Clone()方法，和一个保护的拷贝构造函数，来使子类能够实现它。</p><p>如果你不想支持拷贝/移动操作，使用 = delete 来明确地禁用它们。</p><h2 id="委托和继承构造函数"><a href="#委托和继承构造函数" class="headerlink" title="委托和继承构造函数"></a>委托和继承构造函数</h2><p>委托构造的例子：</p><pre><code>&lt;!-- lang: cpp --&gt;
X::X(const string&amp; name) : name_(name) {
  ...
}

X::X() : X(&quot;&quot;) { }
</code></pre><p>继承构造的例子：</p><pre><code>&lt;!-- lang: cpp --&gt;
class Base {
 public:
  Base();
  Base(int n);
  Base(const string&amp; s);
  ...
};

class Derived : public Base {
 public:
  using Base::Base;  // Base&apos;s constructors are redeclared here.
};
</code></pre><p>在能减少冗余和改善可读性的前提下使用委托和继承。</p><h2 id="结构体-vs-类"><a href="#结构体-vs-类" class="headerlink" title="结构体 vs. 类"></a>结构体 vs. 类</h2><p>struct仅在存储数据时使用，否则使用class。</p><p>struct可以直接访问字段而不通过方法调用。struct内的方法只用来设置数据成员。</p><p>如果需要更多地函数支持，class更合适，如果不确定用哪个，就用class。</p><p>注意struct和class内的成员变量具有不同的命名方式。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>组合通常比继承更合适。当使用继承时，指明为public。</p><p>实际上，继承在C++中主要应用于两个方面：</p><ul><li>实现继承（最普通意义上的继承）</li><li>接口继承（仅继承方法，实现接口）</li></ul><p>所有的继承都应当是public的，如果你需要用private继承，你就应该保存一份基类的成员实例来替代private继承（达到private的效果）。</p><p>不要过度使用实现继承，因为代码实现被分散于子类和基类。</p><p>继承应该被限定为”is-a”的关系，即”子类是基类的特例”。</p><p>如果你的类中有虚函数，那么你的析构函数也必须是virtual。</p><p>数据成员应该是private的。</p><h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><p>仅有很少的多重实现继承是有用的。你通常可以找到一个不同的，更明确地，更干净的解决方案。</p><p>多继承仅允许在父类都是纯接口的时候使用。</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>一个类是纯接口的条件：</p><ul><li>只有public的纯虚函数（= 0）和静态方法（析构函数除外）</li><li>不含非静态的数据成员</li><li>不需要构造函数，如果有，一定没有参数以及被声明为protected</li><li>如果它是子类，它的父类也必须符合这些条件</li></ul><h2 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h2><p>不要重载那些很少使用的，特殊的操作符。不要给用户字面值定义操作符。</p><p>为了使类模板函数正常工作，你或许需要定义操作符。</p><p>虽然操作符重载可以使代码更简洁，但它有以下几个缺点：</p><ul><li>它会让我们以为原本高代价的操作是划算的</li><li>不便于寻找到底调用了那个方法，例如Equals()要比==更方便查找</li><li>许多操作符对指针也有效，很容易出bug。例如：Foo + 4和 &amp;Foo + 4截然不同</li><li>用户字面值允许创造出新的句法，即使经验丰富的C++程序员也会觉得陌生</li></ul><p>重载也会出现意想不到的后果，比如，一个类重载了一元operator&amp;，它将不能安全的被前置声明。</p><p>一般而言，不要定义操作符重载。需要时你可以用普通的函数例如Equals()来替代。</p><p>不要重载operator””，即用户字面值。</p><p>当然，有些情况下可以进行重载，例如对标准C++库：</p><pre><code>&lt;!-- lang: cpp --&gt;
operator&lt;&lt;(ostream&amp;, const T&amp;) for logging
</code></pre><h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><p>使数据成员是private的，然后提供访问函数（getter/setter）来访问它们。例如：一个叫做foo_的变量有一个foo()访问函数，或者set_foo()。</p><p>例外：static const 数据成员(kFoo)不应该是private。</p><p>访问器的定义通常是内联在头文件中的。</p><h2 id="声明顺序"><a href="#声明顺序" class="headerlink" title="声明顺序"></a>声明顺序</h2><p>public: protected: private: ；方法在数据成员之前。</p><p>每个区块内的顺序：</p><ul><li>typedef &amp; enum</li><li>常量（包括静态数据成员）</li><li>构造函数</li><li>析构函数</li><li>方法（包括静态方法）</li><li>数据成员（静态数据除外）</li></ul><p>友元函数总是在private内声明。</p><p>在源文件中的方法定义应该和声明顺序尽量保持一致。</p><h2 id="写出短小的函数"><a href="#写出短小的函数" class="headerlink" title="写出短小的函数"></a>写出短小的函数</h2><p>书写短小的，清晰地函数。如果一个函数超过40行，可以考虑是否可以在不改变程序结构的前提下进行分割。</p><h1 id="Google经验技巧"><a href="#Google经验技巧" class="headerlink" title="Google经验技巧"></a>Google经验技巧</h1><h2 id="所有权和智能指针"><a href="#所有权和智能指针" class="headerlink" title="所有权和智能指针"></a>所有权和智能指针</h2><p>最好使用std::unique_ptr来使所有权传递更明确：</p><pre><code>&lt;!-- lang: cpp --&gt;
std::unique_ptr&lt;Foo&gt; FooFactory();
void FooConsumer(std::unique_ptr&lt;Foo&gt; ptr);
</code></pre><p>在没有一个非常好的理由的前提下，不要把你的代码设计为共享所有权。</p><p>不要再新的代码中使用scoped_ptr除非为了适配老版本的C++。</p><p>不要使用std::auto_ptr，用std::unique_ptr代替。</p><h2 id="cpplint"><a href="#cpplint" class="headerlink" title="cpplint"></a>cpplint</h2><p>使用cpplint.py来检查风格错误。</p><h1 id="其他C-特性"><a href="#其他C-特性" class="headerlink" title="其他C++特性"></a>其他C++特性</h1><h2 id="引用参数"><a href="#引用参数" class="headerlink" title="引用参数"></a>引用参数</h2><p>所有按引用传递的参数必须被const修饰。</p><pre><code>&lt;!-- lang: cpp --&gt;
void Foo(const string &amp;in, string *out);
</code></pre><p>有些情况下用const T* 做输入参数比const T&amp;好：</p><ul><li>要传递一个空指针</li><li>该函数将指针或引用保存到输入参数</li></ul><p>记住大多数时候输入参数都写为const T&amp;。</p><h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><p>右值引用只在move构造函数以及move赋值操作符定义时使用，不要使用std::forward。</p><ul><li>在move构造函数中应用右值引用，可以实现移动数据而不是复制数据，例如：auto v2(std::move(v1))会把v1数据移动到v2中，而不是完全复制一遍，可用于性能提升。</li><li>无论参数是否为临时对象，右值引用都可以经行参数传递。</li><li>右值引用对于没有明确定义拷贝操作，但你仍想向其传递参数的函数有很大的意义，比如向容器内存放数据而不需要copy。</li><li>std::move对高效使用一些标准库类型，例如std::unique_ptr很有必要。</li><li>右值引用作为C++11的新特性，还没有被广泛得理解和应用。</li></ul><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>如果一个函数依靠参数类型的不同来进行重载，读者可能必须理解C++的复杂匹配机制来确定接下来会发生什么。</p><p>如果你像重载一个函数，考虑给出一些信息对参数进行限定，例如使用AppendString(), AppendInt()而不仅仅是Append()。</p><h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><p>除了下面几个情形，我们不允许默认函数参数。如果合适的话，请用函数重载在替代。</p><p>当默认参数做函数指针时容易使人混淆，因为函数签名常常不会匹配调用。加入默认参数时会改变函数的类型，这样会在获取它的地址时造成一些问题。使用函数重载可以避免这个问题。</p><p>一些例外：</p><p>当一个静态函数出现在源文件中时，由于本地化的缘故上述规则不再适用。</p><p>另外，默认参数可在构造函数中使用，上述规则也不适用，因为不可能获取到构造函数的地址。</p><p>还有一个例外是默认参数用来模拟变长数组时，例如：</p><pre><code>&lt;!-- lang: cpp --&gt;
// Support up to 4 params by using a default empty AlphaNum.
string StrCat(const AlphaNum &amp;a,
              const AlphaNum &amp;b = gEmptyAlphaNum,
              const AlphaNum &amp;c = gEmptyAlphaNum,
              const AlphaNum &amp;d = gEmptyAlphaNum);
</code></pre><h2 id="变长数组和alloca"><a href="#变长数组和alloca" class="headerlink" title="变长数组和alloca()"></a>变长数组和alloca()</h2><p>我们不允许使用变长数组或者alloca()</p><p>变长数组和alloca()并不是标准C++的一部分。更重要的是，他会在栈空间中分配大量的空间，可能会触发内存覆盖的bug：在我机器上运行的好好的，在生产环境却死掉了。。</p><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>友元通常都应该被定义在同一个文件中。</p><p>通常会定义一个FooBuilder作为Foo的一个友元。</p><p>在创建一个单元测试的时候，使用友元很管用。</p><h2 id="例外"><a href="#例外" class="headerlink" title="例外"></a>例外</h2><p>我们不使用C++的exceptions。</p><h2 id="运行时类型信息（RTTI）"><a href="#运行时类型信息（RTTI）" class="headerlink" title="运行时类型信息（RTTI）"></a>运行时类型信息（RTTI）</h2><p>避免使用RTTI。</p><p>在运行时查询对象的类型可以说是一个错误的设计问题。</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>使用C++的类型转换如static_cast<int>()。而不要用C-style的int y = (int)x或者int y = int(x)。</int></p><p>使用const_cast来除去const限定，只在你知道你在做什么的情况下，使用reinterpret_cast来做不安全的指针转换。</p><h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><p>流仅用于日志。使用类似printf的形式来代替流。</p><h2 id="前加和前减"><a href="#前加和前减" class="headerlink" title="前加和前减"></a>前加和前减</h2><p>在迭代器和其他模板对象上使用前加或前减。</p><p>当表达式的返回值被忽略时，++i比i++更高效。如果i是一个迭代器，由于i++的复制，开销很大。</p><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>只要讲得通，随时随地使用const。C++11中的constexpr是更好的选择。</p><ul><li>如果一个函数不会修改按引用传递，指针传递的参数，那么这个参数应该是const。</li><li>如果可以，把方法声明为const。访问器应该总是const的。其他方法如果不修改任何数据成员，不调用任何非const方法，不返回非const指针或非const引用，也应该修饰为const。</li><li>数据成员在构造函数执行之后不会被修改，应该声明为const。</li></ul><p>const应该放在哪儿？</p><pre><code>&lt;!-- lang: cpp --&gt;
int const *foo;
const int* foo;
</code></pre><p>把const放在第一位具有更好地可读性，因为它符合英语的习惯：形容词（const），然后是名词（int）。</p><h2 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h2><p>在C++11中，可以使用constexpr来定义真实地常量或者确保常量初始化。</p><h2 id="整形"><a href="#整形" class="headerlink" title="整形"></a>整形</h2><p>&lt;stdint.h&gt;中定义了一些不同长度的整形：int16_t, uint32_t, int64_t 等等。你应该总是使用这些整形，特别是你需要保证整形的长度时。</p><p>当我们认为一个整数”比较大”时，用int64_t。</p><p>你不应该使用无符号整形，如uint32_t，除非有一个合理的原因。特别的，不要认为使用了无符号类型它就不会是负数，使用断言来检验正负。</p><p>如果你需要接收一个容器的大小，确保你的类型能够容纳这个数字，否则使用一个更大的类型。</p><p>注意整形转换、类型提升可能会导致非预期行为。</p><p>关于无符号整形</p><pre><code>&lt;!-- lang: cpp --&gt;
for (unsigned int i = foo.Length()-1; i &gt;= 0; --i) ...
</code></pre><p>这将是一个死循环，因为unsigned int 和 int 比较。因此使用断言来证明非负。不要使用无符号类型来表示非负数。</p><h2 id="预处理宏"><a href="#预处理宏" class="headerlink" title="预处理宏"></a>预处理宏</h2><p>最好使用内联函数、枚举和const量代替宏。在使用宏之前，考虑是否有非宏的解决方案。</p><p>如果你使用了宏，应该注意：</p><ul><li>不要在头文件中定义宏</li><li>使用前正确定义它，使用后undef它</li><li>不要仅仅是为了替换为自己的而undef一个宏，应该取一个唯一的新名字</li><li>最好不要用##来生成函数、类、变量名</li></ul><h2 id="0-、nullptr、NULL"><a href="#0-、nullptr、NULL" class="headerlink" title="0 、nullptr、NULL"></a>0 、nullptr、NULL</h2><p>用0表示整形，0.0表示实数、nullptr（或NULL）表示指针，’\0’表示字符。</p><p>特别在一些情况下，sizeof(NULL)和sizeof(0)不同。</p><h2 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h2><p>最好使用sizeof(varname)而非sizeof(type)。因为当var改变时，sizeof(type)不会改变而sizeof(varname)会跟着改变。</p><pre><code>&lt;!-- lang: cpp --&gt;
Struct data;
memset(&amp;data, 0, sizeof(data));
memset(&amp;data, 0, sizeof(Struct));
if (raw_size &lt; sizeof(int)) {
  LOG(ERROR) &lt;&lt; &quot;compressed record not big enough for count: &quot; &lt;&lt; raw_size;
  return false;
}
</code></pre><h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h2><p>只在类型名十分混乱时使用auto，如果能增加可读性，继续使用完整地类型声明，除了局部变量外不要到处都用auto。</p><p>不要在文件域，命名空间域，类成员中使用auto。从不对大括号初始化列表使用auto。</p><h2 id="括号初始化列表"><a href="#括号初始化列表" class="headerlink" title="括号初始化列表"></a>括号初始化列表</h2><p>一些例子：</p><pre><code>&lt;!-- lang: cpp --&gt;
// Basically the same, ignoring some small technicalities.
// You may choose to use either form.
vector&lt;string&gt; v = {&quot;foo&quot;, &quot;bar&quot;};

// Usable with &apos;new&apos; expressions.
auto p = new vector&lt;string&gt;{&quot;foo&quot;, &quot;bar&quot;};

// A map can take a list of pairs. Nested braced-init-lists work.
map&lt;int, string&gt; m = {{1, "one"}, {2, "2"}};

// A braced-init-list can be implicitly converted to a return type.
vector&lt;int&gt; test_function() { return {1, 2, 3}; }

// Iterate over a braced-init-list.
for (int i : {-1, -2, -3}) {}

// Call a function using a braced-init-list.
void TestFunction2(vector&lt;int&gt; v) {}
TestFunction2({1, 2, 3});
</code></pre><p>也可以给自己的类型定义初始化列表：</p><pre><code>&lt;!-- lang: cpp --&gt;
class MyType {
 public:
  // std::initializer_list references the underlying init list.
  // It should be passed by value.
  MyType(std::initializer_list&lt;int&gt; init_list) {
    for (int i : init_list) append(i);
  }
  MyType&amp; operator=(std::initializer_list&lt;int&gt; init_list) {
    clear();
    for (int i : init_list) append(i);
  }
};
MyType m{2, 3, 5, 7};
</code></pre><p>在没有使用std::initializer_list<t>的情况下也可以：</t></p><pre><code>&lt;!-- lang: cpp --&gt;
double d{1.23};
// Calls ordinary constructor as long as MyOtherType has no
// std::initializer_list constructor.
class MyOtherType {
 public:
  explicit MyOtherType(string);
  MyOtherType(int, string);
};
MyOtherType m = {1, &quot;b&quot;};
// If the constructor is explicit, you can&apos;t use the &quot;= {}&quot; form.
MyOtherType m{&quot;b&quot;};
</code></pre><p>不要给{}使用auto：</p><pre><code>&lt;!-- lang: cpp --&gt;
auto d = {1.23};        // d is a std::initializer_list&lt;double&gt;
auto d = double{1.23};  // Good -- d is a double, not a std::initializer_list.
</code></pre><h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p>在适当的条件下用lambda表达式，不要使用默认的lambda捕获，把所有捕获明确地写出来。</p><p>如果匿名函数超过了5行，考虑给它起一个名字或者使用一个有名函数代替lambda表达式。</p><h2 id="C-11"><a href="#C-11" class="headerlink" title="C++11"></a>C++11</h2><p>合适的时候，用C++11编写的类库。在使用C++11之前，考虑好对其他环境的可移植性。</p><h1 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h1><h2 id="普遍命名规则"><a href="#普遍命名规则" class="headerlink" title="普遍命名规则"></a>普遍命名规则</h2><p>函数名，变量名和文件名应该是具有描述性的，而不是缩略的。</p><pre><code>&lt;!-- lang: cpp --&gt;
int price_count_reader;    // No abbreviation.
int num_errors;            // &quot;num&quot; is a widespread convention.
int num_dns_connections;   // Most people know what &quot;DNS&quot; stands for.
int n;                     // Meaningless.
int nerr;                  // Ambiguous abbreviation.
int n_comp_conns;          // Ambiguous abbreviation.
int wgc_connections;       // Only your group knows what this stands for.
int pc_reader;             // Lots of things can be abbreviated &quot;pc&quot;.
int cstmr_id;              // Deletes internal letters.
</code></pre><h2 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h2><p>文件名都该是小写的，并且可以包含下划线<em>或者短划线-。如果你的项目没有约定，最好用下划线</em>。</p><p>一些例子：</p><pre><code>&lt;!-- lang: cpp --&gt;
my_useful_class.cc
my-useful-class.cc
myusefulclass.cc
myusefulclass_test.cc // _unittest and _regtest are deprecated.
</code></pre><p>不要使用在/usr/include中已近存在的文件名，例如：db.h</p><p>普遍地，明确你的文件名。例如：http_server_logs.h 比 logs.h 好很多。</p><p>如果内联函数非常短，应该直接写在头文件中。</p><h2 id="类型名"><a href="#类型名" class="headerlink" title="类型名"></a>类型名</h2><p>类型名以大写字母开头，并且每个词开头都是大写的：MyExcitingClass, MyExcitingEnum。</p><pre><code>&lt;!-- lang: cpp --&gt;
// classes and structs
class UrlTable { ...
class UrlTableTester { ...
struct UrlTableProperties { ...

// typedefs
typedef hash_map&lt;UrlTableProperties *, string&gt; PropertiesMap;

// enums
enum UrlTableErrors { ...
</code></pre><h2 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h2><p>变量和数据成员都是小写的，单词间有下划线：a_local_variable, a_struct_data_member, a_class_data_member_。</p><pre><code>&lt;!-- lang: cpp --&gt;
string table_name;  // OK - uses underscore.
string tablename;   // OK - all lowercase.

string tableName;   // Bad - mixed case.
</code></pre><p>类数据成员，末尾一个下划线：</p><pre><code>&lt;!-- lang: cpp --&gt;
class TableInfo {
  ...
 private:
  string table_name_;  // OK - underscore at end.
  string tablename_;   // OK.
  static Pool&lt;TableInfo&gt;* pool_;  // OK.
};
</code></pre><p>结构体数据成员，末尾没有下划线：</p><pre><code>&lt;!-- lang: cpp --&gt;
struct UrlTableProperties {
  string name;
  int num_entries;
  static Pool&lt;UrlTableProperties&gt;* pool;
};
</code></pre><p>全局变量，没有一个特定的规则。如果你需要一个规则，考虑给全局变量加上g_前缀，来区分局部变量。</p><h2 id="常量名"><a href="#常量名" class="headerlink" title="常量名"></a>常量名</h2><p>在常量之前加上k，例如：const int kDaysInWeek = 7。</p><h2 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h2><p>和变量命名方式相似，但可以是大小写混合：</p><pre><code>&lt;!-- lang: cpp --&gt;
MyExcitingFunction(), MyExcitingMethod(), 
my_exciting_member_variable(), set_my_exciting_member_variable().
</code></pre><p>访问器(get)和修改器(set)应该匹配要访问或修改的那个变量名：</p><pre><code>&lt;!-- lang: cpp --&gt;
class MyClass {
 public:
  ...
  int num_entries() const { return num_entries_; }
  void set_num_entries(int num_entries) { num_entries_ = num_entries; }

 private:
  int num_entries_;
};
</code></pre><h2 id="命名空间名"><a href="#命名空间名" class="headerlink" title="命名空间名"></a>命名空间名</h2><p>全为小写，并且尽可能是表示目录结构：google_awesome_project.</p><h2 id="枚举名"><a href="#枚举名" class="headerlink" title="枚举名"></a>枚举名</h2><pre><code>&lt;!-- lang: cpp --&gt;
enum UrlTableErrors {
  kOK = 0,
  kErrorOutOfMemory,
  kErrorMalformedInput,
};
enum AlternateUrlTableErrors {
  OK = 0,
  OUT_OF_MEMORY = 1,
  MALFORMED_INPUT = 2,
};
</code></pre><h2 id="宏名"><a href="#宏名" class="headerlink" title="宏名"></a>宏名</h2><p>通常情况下宏不应该被使用，然而它又绝对是需要的，宏名应该全为大写。</p><pre><code>&lt;!-- lang: cpp --&gt;
#define ROUND(x) ...
#define PI_ROUNDED 3.0
</code></pre><h2 id="命名规则的例外"><a href="#命名规则的例外" class="headerlink" title="命名规则的例外"></a>命名规则的例外</h2><p>如果你在为现存的C/C++代码工作，依据现存的命名方式，例如：</p><pre><code>&lt;!-- lang: cpp --&gt;
bigopen()
    function name, follows form of open()
uint
    typedef
bigpos
    struct or class, follows form of pos
sparse_hash_map
    STL-like entity; follows STL naming conventions
LONGLONG_MAX
    a constant, as in INT_MAX
</code></pre><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>为你的读者写注释，因为下一个读者也许就是你。</p><h2 id="注释风格"><a href="#注释风格" class="headerlink" title="注释风格"></a>注释风格</h2><p>保持//和/**/的一致性，通常//更普遍。</p><h2 id="文件注释"><a href="#文件注释" class="headerlink" title="文件注释"></a>文件注释</h2><p>以许可协议（例如：Apache 2.0, BSD, LGPL, GPL）开头，接下来是关于内容的描述。</p><p>如果你对一个已近存在作者标记的文件进行了修改，请删除作者那一行。</p><p>不要重复在头文件和源文件中书写注释。</p><h2 id="类注释"><a href="#类注释" class="headerlink" title="类注释"></a>类注释</h2><p>每个类定义都应该有一个用于描述它的作用，如何使用的注释：</p><pre><code>&lt;!-- lang: cpp --&gt;
// Iterates over the contents of a GargantuanTable.  Sample usage:
//    GargantuanTableIterator* iter = table-&gt;NewIterator();
//    for (iter-&gt;Seek(&quot;foo&quot;); !iter-&gt;done(); iter-&gt;Next()) {
//      process(iter-&gt;key(), iter-&gt;value());
//    }
//    delete iter;
class GargantuanTableIterator {
  ...
};
</code></pre><h2 id="函数注释"><a href="#函数注释" class="headerlink" title="函数注释"></a>函数注释</h2><pre><code>&lt;!-- lang: cpp --&gt;
// Returns an iterator for this table.  It is the client&apos;s
// responsibility to delete the iterator when it is done with it,
// and it must not use the iterator once the GargantuanTable object
// on which the iterator was created has been deleted.
//
// The iterator is initially positioned at the beginning of the table.
//
// This method is equivalent to:
//    Iterator* iter = table-&gt;NewIterator();
//    iter-&gt;Seek(&quot;&quot;);
//    return iter;
// If you are going to immediately seek to another place in the
// returned iterator, it will be faster to use NewIterator()
// and avoid the extra seek.
Iterator* GetIterator() const;
</code></pre><p>去掉不必要的注释：</p><pre><code>&lt;!-- lang: cpp --&gt;
// Returns true if the table cannot hold any more entries.
bool IsTableFull();
</code></pre><h2 id="变量注释"><a href="#变量注释" class="headerlink" title="变量注释"></a>变量注释</h2><p>应该说明这个变量用来干什么，在特定的情况下，需要更多的注释。例如：</p><pre><code>&lt;!-- lang: cpp --&gt;
private:
 // Keeps track of the total number of entries in the table.
 // Used to ensure we do not go over the limit. -1 means
 // that we don&apos;t yet know how many entries the table has.
 int num_total_entries_;
</code></pre><p>所有的全局变量都应该给出一个注释，来描述它用来做什么。</p><pre><code>&lt;!-- lang: cpp --&gt;
// The total number of tests cases that we run through in this regression test.
const int kNumTestCases = 6;
</code></pre><h2 id="实现注释"><a href="#实现注释" class="headerlink" title="实现注释"></a>实现注释</h2><p>一些难懂的，复杂的代码块应该被注释：</p><pre><code>&lt;!-- lang: cpp --&gt;
// Divide result by two, taking into account that x
// contains the carry from the add.
for (int i = 0; i &lt; result-&gt;size(); i++) {
  x = (x &lt;&lt; 8) + (*result)[i];
  (*result)[i] = x &gt;&gt; 1;
  x &amp;= 1;
}
</code></pre><p>意义不明显的行末应该空两个字符并给出注释：</p><pre><code>&lt;!-- lang: cpp --&gt;
// If we have enough memory, mmap the data portion too.
mmap_budget = max&lt;int64&gt;(0, mmap_budget - index_-&gt;length());
if (mmap_budget &gt;= data_size_ &amp;&amp; !MmapData(mmap_chunk_bytes, mlock))
  return;  // Error already logged.
</code></pre><p>如果接下来的几行都有注释，最好排列起来增强可读性：</p><pre><code>&lt;!-- lang: cpp --&gt;
DoSomething();                           // Comment here so the comments line up.
DoSomethingElseThatIsLonger();  // Two spaces between the code and the comment.
{ // One space before comment when opening a new scope is allowed,
  // thus the comment lines up with the following comments and code.
  DoSomethingElse();  // Two spaces before line comments normally.
}
vector&lt;string&gt; list{// Comments in braced lists describe the next element ..
                    &quot;First item&quot;,
                    // .. and should be aligned appropriately.
                    &quot;Second item&quot;};
DoSomething(); /* For trailing block comments, one space is fine. */
</code></pre><p>当你传递一个空指针，布尔值或者字面整形值时，你应该考虑添加注释来说明他们是什么，或者使你的代码自我注释：</p><pre><code>&lt;!-- lang: cpp --&gt;
bool success = CalculateSomething(interesting_value,
                                  10,
                                  false,
                                  NULL);  // What are these arguments??
versus:

bool success = CalculateSomething(interesting_value,
                                  10,     // Default base value.
                                  false,  // Not the first time we&apos;re calling this.
                                  NULL);  // No callback.
Or alternatively, constants or self-describing variables:

const int kDefaultBaseValue = 10;
const bool kFirstTimeCalling = false;
Callback *null_callback = NULL;
bool success = CalculateSomething(interesting_value,
                                  kDefaultBaseValue,
                                  kFirstTimeCalling,
                                  null_callback);
</code></pre><p>切记不要描述代码自身：</p><pre><code>&lt;!-- lang: cpp --&gt;
// Now go through the b array and make sure that if i occurs,
// the next element is i+1.
...        // Geez.  What a useless comment.
</code></pre><h2 id="标点，拼写和语法"><a href="#标点，拼写和语法" class="headerlink" title="标点，拼写和语法"></a>标点，拼写和语法</h2><p>完整的句子往往比句子片段更容易理解。</p><h2 id="TODO-注释"><a href="#TODO-注释" class="headerlink" title="TODO 注释"></a>TODO 注释</h2><p>使用TODO注释是一个临时的，短期的解决方案，很好的但不是完美的。</p><p>当你创建一个TODO时，总是给出你的名字：</p><pre><code>&lt;!-- lang: cpp --&gt;
// TODO(kl@gmail.com): Use a &quot;*&quot; here for concatenation operator.
// TODO(Zeke) change this to use relations.
</code></pre><h2 id="弃用注释"><a href="#弃用注释" class="headerlink" title="弃用注释"></a>弃用注释</h2><p>使用DEPRECATED注释标记一个弃用的接口。</p><p>在DEPRECATED之后写出你的名字，email地址或其他能标识你的信息。</p><p>弃用注释必须包含简易的，清楚的指引来帮助使用者修复他们的问题。C++中，你可以将弃用的方法放在内联函数中，然后调用新的接口。</p><h1 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h1><h2 id="行长度"><a href="#行长度" class="headerlink" title="行长度"></a>行长度</h2><p>一行最多80个字符。</p><p>一些原始字符串可能会超出80个字符，除了测试外，这样的字符串应该出现在该文件的顶部。</p><p>#include 语句可能会超过80列。</p><h2 id="非ascii字符"><a href="#非ascii字符" class="headerlink" title="非ascii字符"></a>非ascii字符</h2><p>非ascii字符很少出现，但必须使用UTF-8编码。</p><p>十六进制也可以使用，在那些需要加强可读性的地方更建议使用。</p><p>你不应该使用C++11提供的char116_t和char32_t，因为他们用于非UTF8得文本。同样的，，你也不应该使用wchar_t，除非你是在用Windows API编写程序。</p><h2 id="空格和制表符"><a href="#空格和制表符" class="headerlink" title="空格和制表符"></a>空格和制表符</h2><p>只用空格并且缩进两个字符。</p><h2 id="函数声明和定义"><a href="#函数声明和定义" class="headerlink" title="函数声明和定义"></a>函数声明和定义</h2><p>返回类型出现在函数名的同一行，如果能适应，参数也出现在同一行。如果不能适应，折行书写参数表。</p><pre><code>&lt;!-- lang: cpp --&gt;
ReturnType ClassName::FunctionName(Type par_name1, Type par_name2) {
  DoSomething();
  ...
}

If you have too much text to fit on one line:

ReturnType ClassName::ReallyLongFunctionName(Type par_name1, Type par_name2,
                                             Type par_name3) {
  DoSomething();
  ...
}

or if you cannot fit even the first parameter:

ReturnType LongClassName::ReallyReallyReallyLongFunctionName(
    Type par_name1,  // 4 space indent
    Type par_name2,
    Type par_name3) {
  DoSomething();  // 2 space indent
  ...
}
</code></pre><p>需要指出：</p><ul><li>如果不能把返回类型和函数名放在同一行，请折行</li><li>如果折行书写了返回类型，不要缩进</li><li>左圆括号始终和函数名处在同一行</li><li>括号和参数之间没有空格</li><li>左花括号始终和最后一个参数在同一行</li><li>右花括号在最后一行或者和左花括号在同一行</li><li>右小括号和左花括号之间有一个空格</li><li>所有参数都改命名，无论是在头文件，或者源文件中</li><li>如果可能，所有参数都要对齐</li><li>默认缩进2个字符</li><li>折行的参数有4个字符缩进</li></ul><p>如果一些参数未使用，在函数声明处注释出来：</p><pre><code>&lt;!-- lang: cpp --&gt;
// Always have named parameters in interfaces.
class Shape {
 public:
  virtual void Rotate(double radians) = 0;
};

// Always have named parameters in the declaration.
class Circle : public Shape {
 public:
  virtual void Rotate(double radians);
};

// Comment out unused named parameters in definitions.
void Circle::Rotate(double /*radians*/) {}
// Bad - if someone wants to implement later, it&apos;s not clear what the
// variable means.
void Circle::Rotate(double) {}
</code></pre><h2 id="lambda表达式-1"><a href="#lambda表达式-1" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p>像其他函数一样格式化参数和函数体，捕获表如其他逗号分隔的列表。</p><pre><code>&lt;!-- lang: cpp --&gt;
int x = 0;
auto add_to_x = [&amp;x](int n) { x += n; };
</code></pre><p>简短的lambda表达式应该作为函数参数内联：</p><pre><code>&lt;!-- lang: cpp --&gt;
std::set&lt;int&gt; blacklist = {7, 8, 9};
std::vector&lt;int&gt; digits = {3, 9, 1, 8, 4, 7, 1};
digits.erase(std::remove_if(digits.begin(), digits.end(), [&amp;blacklist](int i) {
               return blacklist.find(i) != blacklist.end();
             }),
             digits.end());
</code></pre><h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>将函数调用写在一行，用小括号包裹参数；或者将参数置于新行，用4个空格缩进。使用最小的行数。</p><p>如下格式：</p><pre><code>&lt;!-- lang: cpp --&gt;
bool retval = DoSomething(argument1, argument2, argument3);
</code></pre><p>如果参数太多，折行书写，括号左右不要有空格。</p><pre><code>&lt;!-- lang: cpp --&gt;
bool retval = DoSomething(averyveryveryverylongargument1,
                                        argument2, argument3);

if (...) {
  ...
  ...
  if (...) {
    DoSomething(
        argument1, argument2,  // 4 space indent
        argument3, argument4);
  }
</code></pre><h2 id="花括号初始化列表格式"><a href="#花括号初始化列表格式" class="headerlink" title="花括号初始化列表格式"></a>花括号初始化列表格式</h2><pre><code>&lt;!-- lang: cpp --&gt;
// Examples of braced init list on a single line.
return {foo, bar};
functioncall({foo, bar});
pair&lt;int, int&gt; p{foo, bar};

// When you have to wrap.
SomeFunction(
    {&quot;assume a zero-length name before {&quot;},
    some_other_function_parameter);
SomeType variable{
    some, other, values,
    {&quot;assume a zero-length name before {&quot;},
    SomeOtherType{
        &quot;Very long string requiring the surrounding breaks.&quot;,
        some, other values},
    SomeOtherType{&quot;Slightly shorter string&quot;,
                  some, other, values}};
SomeType variable{
    &quot;This is too long to fit all in one line&quot;};
MyType m = {  // Here, you could also break before {.
    superlongvariablename1,
    superlongvariablename2,
    {short, interior, list},
    {interiorwrappinglist,
     interiorwrappinglist2}};
</code></pre><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p>最好括号内无空格。if和else关键字属于分立的行中。</p><pre><code>&lt;!-- lang: cpp --&gt;
if(condition) {   // Bad - space missing after IF.
if (condition){   // Bad - space missing before {.
if(condition){    // Doubly bad.
if (condition) {  // Good - proper space after IF and before {.
</code></pre><p>简短的条件块可以写在一行，如果能强化可读性。</p><pre><code>&lt;!-- lang: cpp --&gt;
if (x == kFoo) return new Foo();
if (x == kBar) return new Bar();
</code></pre><p>如果含有else块，则不允许写在一行：</p><pre><code>&lt;!-- lang: cpp --&gt;
// Not allowed - IF statement on one line when there is an ELSE clause
if (x) DoThis();
else DoThat();
</code></pre><p>一般而言，单行条件语句不需要花括号，如果你喜欢也可以加上，特别是在循环中存在复杂的条件时，使用花括号可增加可读性。有些项目还要求if块必须含有完整地括号对。</p><p>然而，if-else一部分使用了花括号，那么所有块都必须使用：</p><pre><code>&lt;!-- lang: cpp --&gt;
// Not allowed - curly on IF but not ELSE
if (condition) {
  foo;
} else
  bar;

// Not allowed - curly on ELSE but not IF
if (condition)
  foo;
else {
  bar;
}
// Curly braces around both IF and ELSE required because
// one of the clauses used braces.
if (condition) {
  foo;
} else {
  bar;
}
</code></pre><h2 id="循环和选择语句"><a href="#循环和选择语句" class="headerlink" title="循环和选择语句"></a>循环和选择语句</h2><p>switch块必须包含default，如果default永不会被执行，则写一个assert：</p><pre><code>&lt;!-- lang: cpp --&gt;
switch (var) {
  case 0: {  // 2 space indent
    ...      // 4 space indent
    break;
  }
  case 1: {
    ...
    break;
  }
  default: {
    assert(false);
  }
}
</code></pre><p>空的case块用花括号括起来。</p><p>单语句循环，花括号可以省略，空循环用花括号括起来或者写continue，而不仅仅是分号。</p><pre><code>&lt;!-- lang: cpp --&gt;
while (condition) {
  // Repeat test until it returns false.
}
for (int i = 0; i &lt; kSomeNumber; ++i) {}  // Good - empty body.
while (condition) continue;  // Good - continue indicates no logic.
while (condition);  // Bad - looks like part of do/while loop.
</code></pre><h2 id="指针和引用表达式"><a href="#指针和引用表达式" class="headerlink" title="指针和引用表达式"></a>指针和引用表达式</h2><p>句号和箭头周围无空格：</p><pre><code>&lt;!-- lang: cpp --&gt;
x = *p;
p = &amp;x;
x = r.y;
x = r-&gt;y;
</code></pre><p>当声明一个指针类型变量时，保证星号两侧仅有一个空格：</p><pre><code>&lt;!-- lang: cpp --&gt;
// These are fine, space preceding.
char *c;
const string &amp;str;

// These are fine, space following.
char* c;    // but remember to do &quot;char* c, *d, *e, ...;&quot;!
const string&amp; str;
char * c;  // Bad - spaces on both sides of *
const string &amp; str;  // Bad - spaces on both sides of &amp;
</code></pre><h2 id="布尔表达式"><a href="#布尔表达式" class="headerlink" title="布尔表达式"></a>布尔表达式</h2><p>当一个布尔表达式超过标准行长度(80)时，保证折行书写的一致性。</p><pre><code>&lt;!-- lang: cpp --&gt;
if (this_one_thing &gt; this_other_thing &amp;&amp;
    a_third_thing == a_fourth_thing &amp;&amp;
    yet_another &amp;&amp; last_one) {
  ...
}
</code></pre><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>不要给return语句加上括号。仅在返回一个逻辑表达式的时候加括号。</p><pre><code>&lt;!-- lang: cpp --&gt;
return result;                  // No parentheses in the simple case.
// Parentheses OK to make a complex expression more readable.
return (some_long_condition &amp;&amp;
        another_condition);
return (value);                // You wouldn&apos;t write var = (value);
return(result);                // return is not a function!
</code></pre><h2 id="变量和数组初始化"><a href="#变量和数组初始化" class="headerlink" title="变量和数组初始化"></a>变量和数组初始化</h2><p>可以选择=，()或者{}。下面都是正确的：</p><pre><code>&lt;!-- lang: cpp --&gt;
int x = 3;
int x(3);
int x{3};
string name = &quot;Some Name&quot;;
string name(&quot;Some Name&quot;);
string name{&quot;Some Name&quot;};
</code></pre><p>当心{}会调用std::initializer_list 构造函数。为了避免这个问题，使用()：</p><pre><code>&lt;!-- lang: cpp --&gt;
vector&lt;int&gt; v(100, 1);  // A vector of 100 1s.
vector&lt;int&gt; v{100, 1};  // A vector of 100, 1.
</code></pre><h2 id="预处理指令"><a href="#预处理指令" class="headerlink" title="预处理指令"></a>预处理指令</h2><p>总是在一行的开头书写，无论是不是在代码块内：</p><pre><code>&lt;!-- lang: cpp --&gt;
// Good - directives at beginning of line
  if (lopsided_score) {
#if DISASTER_PENDING      // Correct -- Starts at beginning of line
    DropEverything();
# if NOTIFY               // OK but not required -- Spaces after #
    NotifyClient();
# endif
#endif
    BackToNormal();
  }
// Bad - indented directives
  if (lopsided_score) {
    #if DISASTER_PENDING  // Wrong!  The &quot;#if&quot; should be at beginning of line
    DropEverything();
    #endif                // Wrong!  Do not indent &quot;#endif&quot;
    BackToNormal();
  }
</code></pre><h2 id="类格式化"><a href="#类格式化" class="headerlink" title="类格式化"></a>类格式化</h2><p>public,protected,private前面有一个空格：</p><pre><code>&lt;!-- lang: cpp --&gt;
class MyClass : public OtherClass {
 public:      // Note the 1 space indent!
  MyClass();  // Regular 2 space indent.
  explicit MyClass(int var);
  ~MyClass() {}

  void SomeFunction();
  void SomeFunctionThatDoesNothing() {
  }

  void set_some_var(int var) { some_var_ = var; }
  int some_var() const { return some_var_; }

 private:
  bool SomeInternalFunction();

  int some_var_;
  int some_other_var_;
};
</code></pre><p>注意：</p><ul><li>基类名和子类名放在一行</li><li>除了第一个public，其他关键字前需要空一行，这个规则在小型类中可选。</li><li>这些关键字下面不要有空行</li></ul><h2 id="构造函数初始化列表"><a href="#构造函数初始化列表" class="headerlink" title="构造函数初始化列表"></a>构造函数初始化列表</h2><p>初始化列表可以在一行内，也可以折行，前面缩进4个字符：</p><pre><code>&lt;!-- lang: cpp --&gt;
// When it all fits on one line:
MyClass::MyClass(int var) : some_var_(var), some_other_var_(var + 1) {}
or

// When it requires multiple lines, indent 4 spaces, putting the colon on
// the first initializer line:
MyClass::MyClass(int var)
    : some_var_(var),             // 4 space indent
      some_other_var_(var + 1) {  // lined up
  ...
  DoSomething();
  ...
}
</code></pre><h2 id="命名空间格式"><a href="#命名空间格式" class="headerlink" title="命名空间格式"></a>命名空间格式</h2><p>命名空间内的内容不缩进。</p><pre><code>&lt;!-- lang: cpp --&gt;
namespace {

void foo() {  // Correct.  No extra indentation within namespace.
  ...
}

}  // namespace
Do not indent within a namespace:

namespace {

  // Wrong.  Indented when it should not be.
  void foo() {
    ...
  }

}  // namespace
</code></pre><h2 id="水平空格"><a href="#水平空格" class="headerlink" title="水平空格"></a>水平空格</h2><p>水平空格依赖于位置，不要行末添加空格。</p><pre><code>&lt;!-- lang: cpp --&gt;
void f(bool b) {  // Open braces should always have a space before them.
  ...
int i = 0;  // Semicolons usually have no space before them.
// Spaces inside braces for braced-init-list are optional.  If you use them,
// put them on both sides!
int x[] = { 0 };
int x[] = {0};

// Spaces around the colon in inheritance and initializer lists.
class Foo : public Bar {
 public:
  // For inline function implementations, put spaces between the braces
  // and the implementation itself.
  Foo(int b) : Bar(), baz_(b) {}  // No spaces inside empty braces.
  void Reset() { baz_ = 0; }  // Spaces separating braces from implementation.
  ...
</code></pre><p>循环和条件，</p><pre><code>&lt;!-- lang: cpp --&gt;
if (b) {          // Space after the keyword in conditions and loops.
} else {          // Spaces around else.
}
while (test) {}   // There is usually no space inside parentheses.
switch (i) {
for (int i = 0; i &lt; 5; ++i) {
// Loops and conditions may have spaces inside parentheses, but this
// is rare.  Be consistent.
switch ( i ) {
if ( test ) {
for ( int i = 0; i &lt; 5; ++i ) {
// For loops always have a space after the semicolon.  They may have a space
// before the semicolon, but this is rare.
for ( ; i &lt; 5 ; ++i) {
  ...

// Range-based for loops always have a space before and after the colon.
for (auto x : counts) {
  ...
}
switch (i) {
  case 1:         // No space before colon in a switch case.
    ...
  case 2: break;  // Use a space after a colon if there&apos;s code after it.
</code></pre><p>操作符，</p><pre><code>&lt;!-- lang: cpp --&gt;
// Assignment operators always have spaces around them.
x = 0;

// Other binary operators usually have spaces around them, but it&apos;s
// OK to remove spaces around factors.  Parentheses should have no
// internal padding.
v = w * x + y / z;
v = w*x + y/z;
v = w * (x + z);

// No spaces separating unary operators and their arguments.
x = -5;
++x;
if (x &amp;&amp; !y)
  ...
</code></pre><p>模板和类型转换，</p><pre><code>&lt;!-- lang: cpp --&gt;
// No spaces inside the angle brackets (&lt; and &gt;), before
// &lt;, or between &gt;( in a cast
vector&lt;string&gt; x;
y = static_cast&lt;char*&gt;(x);

// Spaces between type and pointer are OK, but be consistent.
vector&lt;char *&gt; x;
set&lt;list&lt;string&gt;&gt; x;        // Permitted in C++11 code.
set&lt;list&lt;string&gt; &gt; x;       // C++03 required a space in &gt; &gt;.

// You may optionally use symmetric spacing in &lt; &lt;.
set&lt; list&lt;string&gt; &gt; x;
</code></pre><h2 id="纵向空格"><a href="#纵向空格" class="headerlink" title="纵向空格"></a>纵向空格</h2><p>使纵向空格最小化。</p><p>当你没必要时，不要留很多空行。特别的，在函数间不要留超过一行或两行的空白。</p><p>函数开始不要有空行，函数结束也不要有空行。</p><p>基本原则：一个屏幕上有越多的代码，就越容易理解程序的控制流程。当然，可读性也很重要。</p><h1 id="以上规则的例外情况"><a href="#以上规则的例外情况" class="headerlink" title="以上规则的例外情况"></a>以上规则的例外情况</h1><h2 id="现存的不一致代码"><a href="#现存的不一致代码" class="headerlink" title="现存的不一致代码"></a>现存的不一致代码</h2><p>你可能会在不符合本规则的代码上工作，为了保持一致性，你不应该生搬硬套这个规则。</p><h2 id="Windows代码"><a href="#Windows代码" class="headerlink" title="Windows代码"></a>Windows代码</h2><ul><li>不要使用匈牙利命名法，例如 iNum。使用上面介绍的命名规则。</li><li>Windows定义了许多自己的类型，如DWORD，HANDLE等等。即便这样，你也应该使用你熟知的C++类型，例如：const TCHAR * 来代替LPCTSTR。</li><li>当使用Microsoft Visual C++编译时，将编译器设置3或以上的警告等级，并把所有警告视为错误。</li><li>不要使用#pragma once。使用第一个介绍的头文件保护策略。</li><li>实际上，不要使用任何非标准的扩展指令，像#pragma和<strong>declspec，除非你必须使用。允许使用</strong>declspec(dllimport) 和 __declspec(dllexport)。当然，你必须通过DLLIMPORT和DLLEXPORT宏来间接使用它们。</li></ul><p>上面的一些规则在Windows上不适用：</p><ul><li>禁止多重实现继承。在使用COM和一些ATL/WTL类时，多重继承是必要的。</li><li>不使用exception。在ATL和一些Visual C++的STL中使用了exception。使用ATL时，你应该定义_ATL_NO_EXCEPTIONS来禁用异常。</li><li>使用预编译头文件的一贯方法是包含StdAfx.h或者precompile.h。你应该避免手动包含预编译头文件，使用/FI编译器选项来自动包含这个文件。</li><li>资源头文件resource.h，仅包含宏，不需要套用本规则。</li></ul><h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><p>符合常识以及保持一致性。</p><p>在编辑代码之前，花几分钟看看当前代码的编码风格。并与之保持一致的风格。</p>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/uploads/master.portrait.png" alt="Micooz Lee">
            
              <p class="site-author-name" itemprop="name">Micooz Lee</p>
              <p class="site-description motion-element" itemprop="description">FullStack JavaScript Engineer</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">50</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">17</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/micooz" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:micooz@hotmail.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://twitter.com/MicoozLee" target="_blank" title="Twitter"><i class="fa fa-fw fa-twitter"></i>Twitter</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://instagram.com/micoozlee" target="_blank" title="Instagram"><i class="fa fa-fw fa-instagram"></i>Instagram</a>
                  
                </span>
              
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://flag.moe" title="哞菇菌" target="_blank">哞菇菌</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://haipz.com" title="海胖博客" target="_blank">海胖博客</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.otokaze.cn" title="音風の部屋" target="_blank">音風の部屋</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.anotherhome.net" title="DIYgod" target="_blank">DIYgod</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.0xbbc.com" title="BlueCocoa" target="_blank">BlueCocoa</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://windisco.com" title="ShinCurry" target="_blank">ShinCurry</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://codelover.link" title="codelover" target="_blank">codelover</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.chionlab.moe" title="ChionTang" target="_blank">ChionTang</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://rakume.com/#!/home" title="Rakume Hayashi" target="_blank">Rakume Hayashi</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://src.moe" title="POJO" target="_blank">POJO</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span> <span class="with-love" id="animate"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Micooz Lee</span></div><div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> v3.7.1</div><span class="post-meta-divider">|</span><div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Pisces</a> v6.1.0</div>
        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.1.0"></script>



  

  
    <script id="dsq-count-scr" src="https://micooz.disqus.com/count.js" async></script>
  

  





	





  












  

  <script type="text/javascript">function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var t=$("#local-search-input");t.attr("autocapitalize","none"),t.attr("autocorrect","off"),t.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/"+search_path,onPopupClose=function(t){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(t,e,o){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:t,dataType:isXml?"xml":"json",async:!0,success:function(t){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var n=isXml?$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():t,r=document.getElementById(e),s=document.getElementById(o),a=function(){var t=r.value.trim().toLowerCase(),e=t.split(/[\s\-]+/);e.length>1&&e.push(t);var o=[];if(t.length>0&&n.forEach(function(n){var r=!1,s=0,a=0,i=n.title.trim(),c=i.toLowerCase(),l=n.content.trim().replace(/<[^>]+>/g,""),h=l.toLowerCase(),p=decodeURIComponent(n.url),u=[],f=[];if(""!=i&&(e.forEach(function(t){function e(t,e,o){var n=t.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(e=e.toLowerCase(),t=t.toLowerCase());(s=e.indexOf(t,r))>-1;)a.push({position:s,word:t}),r=s+n;return a}u=u.concat(e(t,c,!1)),f=f.concat(e(t,h,!1))}),(u.length>0||f.length>0)&&(r=!0,s=u.length+f.length)),r){[u,f].forEach(function(t){t.sort(function(t,e){return e.position!==t.position?e.position-t.position:t.word.length-e.word.length})});function d(e,o,n,r){for(var s=r[r.length-1],i=s.position,c=s.word,l=[],h=0;i+c.length<=n&&0!=r.length;){c===t&&h++,l.push({position:i,length:c.length});var p=i+c.length;for(r.pop();0!=r.length&&(s=r[r.length-1],i=s.position,c=s.word,p>i);)r.pop()}return a+=h,{hits:l,start:o,end:n,searchTextCount:h}}var g=[];0!=u.length&&g.push(d(0,0,i.length,u));for(var v=[];0!=f.length;){var $=f[f.length-1],C=$.position,m=$.word,x=C-20,w=C+80;x<0&&(x=0),w<C+m.length&&(w=C+m.length),w>l.length&&(w=l.length),v.push(d(0,x,w,f))}v.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hits.length!==e.hits.length?e.hits.length-t.hits.length:t.start-e.start});var y=parseInt("1");y>=0&&(v=v.slice(0,y));function T(t,e){var o="",n=e.start;return e.hits.forEach(function(e){o+=t.substring(n,e.position);var r=e.position+e.length;o+='<b class="search-keyword">'+t.substring(e.position,r)+"</b>",n=r}),o+=t.substring(n,e.end)}var b="";0!=g.length?b+="<li><a href='"+p+"' class='search-result-title'>"+T(i,g[0])+"</a>":b+="<li><a href='"+p+"' class='search-result-title'>"+i+"</a>",v.forEach(function(t){b+="<a href='"+p+'\'><p class="search-result">'+T(l,t)+"...</p></a>"}),b+="</li>",o.push({item:b,searchTextCount:a,hitCount:s,id:o.length})}}),1===e.length&&""===e[0])s.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x" /></div>';else if(0===o.length)s.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>';else{o.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hitCount!==e.hitCount?e.hitCount-t.hitCount:e.id-t.id});var a='<ul class="search-result-list">';o.forEach(function(t){a+=t.item}),a+="</ul>",s.innerHTML=a}};r.addEventListener("input",a),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(t){t.stopPropagation(),!1===isfetched?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(t){t.stopPropagation()}),$(document).on("keyup",function(t){27===t.which&&$(".search-popup").is(":visible")&&onPopupClose()})</script>





  

  

  

  

  
  

  

  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=6.1.0"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=6.1.0"></script></body></html>