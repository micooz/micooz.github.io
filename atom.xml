<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Micooz</title>
  
  <subtitle>Make something different!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://apporz.com/"/>
  <updated>2017-12-07T11:52:35.388Z</updated>
  <id>https://apporz.com/</id>
  
  <author>
    <name>Micooz Lee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>How to disable text selection in svg</title>
    <link href="https://apporz.com/2016/07/26/how-to-disable-text-selection-in-svg/"/>
    <id>https://apporz.com/2016/07/26/how-to-disable-text-selection-in-svg/</id>
    <published>2016-07-25T16:00:00.000Z</published>
    <updated>2017-12-07T11:52:35.388Z</updated>
    
    <content type="html"><![CDATA[<p>In sass style:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">text</span> &#123;</span><br><span class="line">  <span class="attribute">user-select</span>: none;</span><br><span class="line">  </span><br><span class="line">  &amp;::selection &#123;</span><br><span class="line">    <span class="selector-tag">background</span>: <span class="selector-tag">none</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;In sass style:&lt;/p&gt;
&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/
      
    
    </summary>
    
    
      <category term="tech" scheme="https://apporz.com/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title>link in docker</title>
    <link href="https://apporz.com/2016/05/12/link-in-docker/"/>
    <id>https://apporz.com/2016/05/12/link-in-docker/</id>
    <published>2016-05-11T16:00:00.000Z</published>
    <updated>2017-12-07T11:52:35.388Z</updated>
    
    <content type="html"><![CDATA[<h1 id="–link-in-docker"><a href="#–link-in-docker" class="headerlink" title="–link in docker"></a>–link in docker</h1><p>容器A通过–link选项使用容器B的某个服务，<code>docker-compose.yml</code> 配置如下：</p><pre><code>A:  image: image_a  links:    - B:B  ...B:  image: image_b  ...</code></pre><p>当容器B被重启后，A的link不会被自动更新，要一并重启A才行：</p><pre><code>$ docker-compose restart B # A doesn&apos;t work$ docker-compose restart A # it works well</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;–link-in-docker&quot;&gt;&lt;a href=&quot;#–link-in-docker&quot; class=&quot;headerlink&quot; title=&quot;–link in docker&quot;&gt;&lt;/a&gt;–link in docker&lt;/h1&gt;&lt;p&gt;容器A通过–link选项使用容器B的
      
    
    </summary>
    
    
      <category term="tech" scheme="https://apporz.com/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title>webpack-dev-server 最佳实践</title>
    <link href="https://apporz.com/2016/05/10/webpack-dev-server-best-practice/"/>
    <id>https://apporz.com/2016/05/10/webpack-dev-server-best-practice/</id>
    <published>2016-05-09T16:00:00.000Z</published>
    <updated>2017-12-07T11:52:35.389Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p><a href="https://github.com/webpack/webpack-dev-server" target="_blank" rel="noopener">webpack-dev-server</a> 是用express和websocket实现的一套在开发环境下前端自动更新的工具。</p><p>webpack-dev-server提供CLI接口，读取传入的webpack.config.js配置文件，根据webpack配置，建立一个静态服务器，供前端加载静态资源，其中有一个关键附加脚本是 <code>webpack-dev-server.js</code>，位于PATH根路径，即 <code>/webpack-dev-server.js</code>，其中存放着websocket客户端。</p><h2 id="一般使用方法"><a href="#一般使用方法" class="headerlink" title="一般使用方法"></a>一般使用方法</h2><p>可以通过下面的命令运行webpack-dev-server：</p><pre><code>$ node node_modules/.bin/webpack-dev-server --config webpack/dev.config.js --inline --profile --colors --watch --display-error-details --display-cached</code></pre><p>参数说明参考：<a href="http://webpack.github.io/docs/webpack-dev-server.html#webpack-dev-server-cli" target="_blank" rel="noopener">这里</a></p><p>执行后会自动运行webpack进行打包等一系列操作。</p><p>在webpack配置文件中只需添加一个 <code>devServer</code> 配置项即可定义webpack-dev-server的行为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  port: <span class="number">3000</span>,</span><br><span class="line">  host: <span class="string">'localhost'</span>,</span><br><span class="line">  historyApiFallback: <span class="literal">true</span>,</span><br><span class="line">  quiet: <span class="literal">false</span>,</span><br><span class="line">  watchOptions: &#123;</span><br><span class="line">    aggregateTimeout: <span class="number">300</span>,</span><br><span class="line">    poll: <span class="number">1000</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>在这个例子中，webpack-dev-server会在本地<strong>3000</strong>端口上启动一个静态服务器，服务器serve的目录是webpack的必选配置 <code>output.path</code>，这是一个绝对路径。</p><h2 id="一些问题？"><a href="#一些问题？" class="headerlink" title="一些问题？"></a>一些问题？</h2><p>请考虑下面这个问题：</p><p>我有一个网站项目，分模块，每个模块是一个node项目，且每个模块可以<strong>独立存在</strong>（启动，调试，运行），它们有些用到了webpack-dev-server。</p><p>再次强调每个模块相互独立，它们之间的耦合方式只有一种：<strong>请求代理</strong>。</p><p>现在假设模块A作为API服务器，监听3000端口；模块B作为应用服务器，要提供资源给浏览器，于是用webpack-dev-server在端口3001的 <code>/</code> 上建立了静态服务器。模块B还要从模块A存取数据，那么必定存在从3001跨域请求到3000的问题，消除这个问题有多种解决办法：</p><ol><li>在A上设置 <code>Access-Control-Allow-Origin</code> 为B的域。</li><li>在A、B上层建立代理服务器，屏蔽端口限制。</li></ol><p>不深入讨论上面的方法，现在假设我们<strong>采用方法二</strong>解决了跨域请求问题，然后我们再考虑一下接下来的一个问题：</p><p>假设存在模块C，和B十分类似，也属于应用服务器；如果B和C存在同名资源，比如 <code>main.js</code>，访问该资源就会引发冲突，因为两个模块都在 <code>/</code> 上建立了静态服务器，而这又符合每个模块可以<strong>独立存在</strong>的先决条件：</p><pre><code>// Bhttp://localhost/B/index.htmlhttp://localhost/main.js// Chttp://localhost/C/index.htmlhttp://localhost/main.js // 哪个 main.js ?</code></pre><p>解决办法看似很明显：</p><pre><code>// Bhttp://localhost/B/index.htmlhttp://localhost/B/main.js// Chttp://localhost/C/index.htmlhttp://localhost/C/main.js // everyone is happy</code></pre><p>但这又破坏了每个模块的独立性，我希望单独启动C时，C总能从 <code>/</code> 上获取资源，而不是 <code>/C/...</code> 这么冗余。</p><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>问题就出在 <code>webpack-dev-server</code>，它适合作为<strong>静态资源服务器</strong>，而不是<strong>开发服务器</strong>。因此，我们的开发环境除了需要 <code>webpack-dev-server</code>，还需要专门的<strong>开发服务器</strong>。</p><pre><code>// =&gt; Module B// dev serverhttp://localhost/B/index.html// webpack-dev-server for Bhttp://localhost:3001/...// =&gt; Module C// dev serverhttp://localhost/C/index.html// webpack-dev-server for Chttp://localhost:3003/...</code></pre><p>每个模块从对应的 <code>webpack-dev-server</code> 获取资源，解决了冲突又保留了每个模块的独立性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/webpack/webpack-dev-server&quot; target=&quot;_blank
      
    
    </summary>
    
    
      <category term="tech" scheme="https://apporz.com/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title>Angular2 如何多次触发子组件的 ngOnInit</title>
    <link href="https://apporz.com/2016/03/29/angular2-multiple-ngoninit/"/>
    <id>https://apporz.com/2016/03/29/angular2-multiple-ngoninit/</id>
    <published>2016-03-28T16:00:00.000Z</published>
    <updated>2017-12-07T11:52:35.387Z</updated>
    
    <content type="html"><![CDATA[<p>通常子组件加载后只会执行一次<code>ngOnInit</code>，不利于子组件的自我更新，但设法使子组件从Dom中移除后重建就可以多次触发<code>ngOnInit</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">person</span> *<span class="attr">ngIf</span>=<span class="string">"show"</span>&gt;</span><span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonComponent</span> </span>&#123;</span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">    <span class="comment">// triggered if show is available</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像这种<strong>带星号的指令</strong>就是Angular2中一种模板语法糖，可以管控组件的生命周期。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通常子组件加载后只会执行一次&lt;code&gt;ngOnInit&lt;/code&gt;，不利于子组件的自我更新，但设法使子组件从Dom中移除后重建就可以多次触发&lt;code&gt;ngOnInit&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;
      
    
    </summary>
    
    
      <category term="tech" scheme="https://apporz.com/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title>webpack复习</title>
    <link href="https://apporz.com/2016/03/22/webpack-review/"/>
    <id>https://apporz.com/2016/03/22/webpack-review/</id>
    <published>2016-03-21T16:00:00.000Z</published>
    <updated>2017-12-07T11:52:35.390Z</updated>
    
    <content type="html"><![CDATA[<p>使用<code>ProvidePlugin</code>暴露对象到全局：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> webpack.ProvidePlugin(&#123;</span><br><span class="line">    $: <span class="string">'jquery'</span>,</span><br><span class="line">    jQuery: <span class="string">'jquery'</span>,</span><br><span class="line">    <span class="string">'window.jQuery'</span>: <span class="string">'jquery'</span></span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>自定义require返回值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"></span><br><span class="line">externals: &#123;</span><br><span class="line">  <span class="string">'data'</span>: <span class="string">'data data...'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// use in code</span></span><br><span class="line"><span class="keyword">var</span> data = <span class="built_in">require</span>(<span class="string">'data'</span>); <span class="comment">// 'data data...'</span></span><br></pre></td></tr></table></figure><p><strong>开启Hot Module Replacement(HMR)</strong></p><p>方法一：</p><pre><code>$ webpack --hot --inline</code></pre><ul><li>–hot: 添加HotModuleReplacementPlugin</li><li>–inline: 在生成的js中添加websocket客户端</li></ul><p>方法二：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"></span><br><span class="line">entry: &#123;</span><br><span class="line">  <span class="string">'webpack/hot/dev-server'</span>, <span class="comment">// 仅仅是为window添加一个listener</span></span><br><span class="line">  <span class="string">'webpack-dev-server/client?http://localhost:8000'</span> <span class="comment">// websocket客户端</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用&lt;code&gt;ProvidePlugin&lt;/code&gt;暴露对象到全局：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/sp
      
    
    </summary>
    
    
      <category term="tech" scheme="https://apporz.com/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title>利用索引提升js的执行效率</title>
    <link href="https://apporz.com/2016/03/17/improve-js-performance-by-using-index/"/>
    <id>https://apporz.com/2016/03/17/improve-js-performance-by-using-index/</id>
    <published>2016-03-16T16:00:00.000Z</published>
    <updated>2017-12-07T11:52:35.388Z</updated>
    
    <content type="html"><![CDATA[<p><strong>问题引入：</strong></p><p>前段时间，有一个任务是需要<strong>频繁</strong>在<strong>大量的数据</strong>集合中<strong>快速定位</strong>并修改某个元素某个字段的值。</p><p>数据结构是<strong>数组</strong>，元素的结构可能相当复杂且<strong>乱序</strong>。</p><p><strong>问题分析：</strong></p><p>假定这个数据集如下：</p><pre><code>// array dataset[{  name: &apos;name1&apos;,  body: {    metadata: {      header: {        id: 1 // unique      }    }  },  ...}]</code></pre><p>实际上就是一个<strong>查找算法</strong>问题，假设要从1000条数据中查找id为1的元素，最SB做法是直接遍历整个数据集：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> ele <span class="keyword">of</span> dataset) &#123;</span><br><span class="line">  <span class="keyword">if</span> (ele.body.metadata.header.id === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ele;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最坏的情况是O(n)，当然也可以使用其他常见的查找算法减少遍历次数，但如果要<strong>频繁</strong>查找，同步操作会导致页面直接卡死。</p><p>如果有一张<strong>哈希表</strong>就帮大忙了，不妨先想想下面这个问题：</p><blockquote><p>在数据库里，为什么给一个字段加个索引就可以极大提升查询效率（通常情况）？</p></blockquote><p><strong>解决方案：</strong></p><p>首先理解索引的含义，在js中，数组是线性结构，它的下标可以当成一种索引，通过下标访问元素时间复杂度为O(1)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> db = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, ...];</span><br><span class="line"><span class="keyword">const</span> ele = db[<span class="number">2</span>]; <span class="comment">// very quick</span></span><br></pre></td></tr></table></figure><p>对于一个Object，同样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  col1: <span class="number">1</span>,</span><br><span class="line">  col2: <span class="number">2</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> col2 = obj[<span class="string">'col2'</span>]; <span class="comment">// very quick</span></span><br><span class="line"><span class="keyword">const</span> col2 = obj.col2; <span class="comment">// very quick</span></span><br></pre></td></tr></table></figure><p>再看看最开始的那个问题，如果我们可以：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> id = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> ele = dataset[id]; <span class="comment">// very quick</span></span><br></pre></td></tr></table></figure><p>实现这个效果实际上就要<strong>建立索引</strong>，此时的 <code>dataset</code> 显然已经不能是最原始的数组了。当id不是数字的时候，<code>dataset</code> 也不能是数组，<br>那么Object就理所当然地充当js里的HashMap了（ES6中已经有标准的<a href="http://es6.ruanyifeng.com/#docs/set-map#Map" target="_blank" rel="noopener">Map</a>实现）。</p><p>编写一个通用的索引创建函数，这个函数可以为一个数组，通过传入的回调函数的返回值创建一个包含所有数据引用的索引对象（Object）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> index = <span class="function">(<span class="params">arr, fn</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> indexes = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> it <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = fn(it);</span><br><span class="line">    <span class="keyword">if</span> (!indexes[key]) &#123;</span><br><span class="line">      indexes[key] = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    indexes[key] = it;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> indexes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数只需要<strong>遍历一次数据集</strong>来建立索引。</p><p>用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> our_index = _index(dataset, ele =&gt; ele.body.metadata.header.id);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  "1": &#123;</span></span><br><span class="line"><span class="comment">    name: 'name1',</span></span><br><span class="line"><span class="comment">    body: &#123;</span></span><br><span class="line"><span class="comment">      metadata: &#123;</span></span><br><span class="line"><span class="comment">        header: &#123;</span></span><br><span class="line"><span class="comment">          id: 1 // unique</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  "2": &#123;...&#125;,</span></span><br><span class="line"><span class="comment">  ...</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>有了这个索引 <code>our_index</code>，就可以愉快的以<strong>O(1)</strong>的复杂度来访问任意元素，取出的元素是引用，于是也可以直接对原存储空间的数据进行操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ele = our_index[<span class="number">1</span>];</span><br><span class="line"><span class="comment">// operation on ele</span></span><br><span class="line">ele.name = <span class="string">'_'</span> + ele.name;</span><br></pre></td></tr></table></figure><p><strong>小结</strong></p><p>原生JavaScript不支持Map数据结构，因此可以通过对象来实现；关键在于如何根据需要建立索引，建立索引的字段必须满足<strong>唯一性</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;问题引入：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前段时间，有一个任务是需要&lt;strong&gt;频繁&lt;/strong&gt;在&lt;strong&gt;大量的数据&lt;/strong&gt;集合中&lt;strong&gt;快速定位&lt;/strong&gt;并修改某个元素某个字段的值。&lt;/p&gt;
&lt;p&gt;数据结构是&lt;
      
    
    </summary>
    
    
      <category term="tech" scheme="https://apporz.com/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title>Angular2 事件绑定注意</title>
    <link href="https://apporz.com/2016/02/23/angular2-events-bind/"/>
    <id>https://apporz.com/2016/02/23/angular2-events-bind/</id>
    <published>2016-02-22T16:00:00.000Z</published>
    <updated>2017-12-07T11:52:35.386Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> [(<span class="attr">ngModel</span>)]=<span class="string">"value"</span> (<span class="attr">change</span>)=<span class="string">"onSelect(value)"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onSelect(value) &#123;</span><br><span class="line">  <span class="comment">// value 还是原来的值，没来得及改变</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决办法</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">onSelect(value) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// value 绑定完成后的值</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="console-log-或者说Chrome-DevTools的坑"><a href="#console-log-或者说Chrome-DevTools的坑" class="headerlink" title="console.log 或者说Chrome DevTools的坑"></a>console.log 或者说Chrome DevTools的坑</h1><p>考虑下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: []&#125;, n = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">while</span>(n--) &#123;</span><br><span class="line">  obj.a.push(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// obj.a[50]: -100</span></span><br><span class="line"></span><br><span class="line">obj.a[<span class="number">50</span>] = <span class="number">-100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// obj.a[50]: -100</span></span><br></pre></td></tr></table></figure><p>浏览器里可以发现两次输出的结果中 <code>a[50]</code> 都是 <code>-100</code>。这一点如果第一次遇到的话还真是匪夷所思。</p><p>这里我故意把 <code>a</code> 数组的元素弄得很多，使 <code>DevTools</code> 以 <strong>折叠</strong> 方式显示：</p><blockquote><p>Object {a: Array[100]}<br>Object {a: Array[100]}</p></blockquote><p>看似友好的显示方式，实际上里面有很大的问题。</p><p>当我们<strong>展开第一个输出</strong>时， <code>DevTools</code> 会 <strong>及时</strong> 读取变量值，由于这是个 <strong>引用</strong> 类型，实际上它读到的是 <code>obj</code> 的最终值，及 <code>a[50]</code> 是 <code>-100</code>。</p><p>如果数组a只有很少的元素，<code>DevTools</code> 不启用智能显示时就不会出现这个问题。</p><p>也就是说，<code>console.log</code> 到 <code>DevTools</code> 里的实际上<strong>是引用而不是拷贝</strong>，<strong>展开</strong>操作会及时读取变量值。</p><p>如果把上面例子的两个输出改成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj));</span><br></pre></td></tr></table></figure><p>结果将和预期的一致。</p><p><strong>因此</strong>，在浏览器中调试 <code>js</code> 程序应该以 <code>调试器</code> 下断点为主，日志为辅。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="tech" scheme="https://apporz.com/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title>Angular2 @Input 绑定问题</title>
    <link href="https://apporz.com/2016/02/19/angular2-input-bind/"/>
    <id>https://apporz.com/2016/02/19/angular2-input-bind/</id>
    <published>2016-02-18T16:00:00.000Z</published>
    <updated>2017-12-07T11:52:35.386Z</updated>
    
    <content type="html"><![CDATA[<pre><code>@Component({  template: `&lt;child [value]=&quot;bindValue&quot;&gt;&lt;/child&gt;`})class HomeComponent {  bindValue:string = &apos;hello&apos;;}@Component({  selector: &apos;child&apos;,  template: `...`})class ChildComponent{  @Input() value;  ngOnInit(){    // 这里可以取到value的值为&apos;hello&apos;    // 当bindValue动态改变时，此函数不会再次调用，需要在ngOnChanges中手动更新  }  ngOnChanges(changes) {    // this.value = changes[&apos;value&apos;].currentValue;    // ...    // 但是要小心这个函数会被频繁调用，    // 不要做复杂逻辑  }}</code></pre><h1 id="Array-prototype-map-的坑"><a href="#Array-prototype-map-的坑" class="headerlink" title="Array.prototype.map 的坑"></a>Array.prototype.map 的坑</h1><p>map回调如果不给出返回值，则默认返回 <code>undefined</code>，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" target="_blank" rel="noopener">MDN文档</a>中似乎并未提到这一点。</p><pre><code>var numbers = [1, 4, 9];var roots = numbers.map(n =&gt; {  if (n === 4) {    return -1;  }});// [undefined, -1, undefined]</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;@Component({
  template: `&amp;lt;child [value]=&amp;quot;bindValue&amp;quot;&amp;gt;&amp;lt;/child&amp;gt;`
})
class HomeComponent {
  bindValue:string 
      
    
    </summary>
    
    
      <category term="tech" scheme="https://apporz.com/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title>浮动元素z-index无效问题</title>
    <link href="https://apporz.com/2016/02/18/float-element-z-index-problem/"/>
    <id>https://apporz.com/2016/02/18/float-element-z-index-problem/</id>
    <published>2016-02-17T16:00:00.000Z</published>
    <updated>2017-12-07T11:52:35.387Z</updated>
    
    <content type="html"><![CDATA[<pre><code>.view-container {  float: right !important;  z-index: 999; /* invalid! */  /* position must be set */  position: relative;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;.view-container {
  float: right !important;
  z-index: 999; /* invalid! */

  /* position must be set */
  position: relative;
}
      
    
    </summary>
    
    
      <category term="tech" scheme="https://apporz.com/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title>Object.assign</title>
    <link href="https://apporz.com/2016/02/17/object-assign/"/>
    <id>https://apporz.com/2016/02/17/object-assign/</id>
    <published>2016-02-16T16:00:00.000Z</published>
    <updated>2017-12-07T11:52:35.389Z</updated>
    
    <content type="html"><![CDATA[<pre><code>const _new = Object.assign(target, {...});</code></pre><p>会改变 <code>target</code> 本身，引发问题。</p><blockquote><p>The Object.assign() method is used to copy the values of all enumerable own properties from one or more source objects <strong>to</strong> a target object. It will return the target object.</p></blockquote><p>有三个解决办法：</p><p><strong>逐个拷贝</strong></p><pre><code>const _new = {k1: target.k1, k2: target.k2, ...};</code></pre><p><strong>ES6</strong></p><pre><code>const _new = {...target, ...{...}};</code></pre><p><strong>（最佳）把第一个参数设成空对象</strong></p><pre><code>const _new = Object.assign({}, target, {...});</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;const _new = Object.assign(target, {...});
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;会改变 &lt;code&gt;target&lt;/code&gt; 本身，引发问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The Object.assign
      
    
    </summary>
    
    
      <category term="tech" scheme="https://apporz.com/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title>Angular2 - Routing &amp; Navigation</title>
    <link href="https://apporz.com/2016/02/15/angular2-routing-navigation/"/>
    <id>https://apporz.com/2016/02/15/angular2-routing-navigation/</id>
    <published>2016-02-14T16:00:00.000Z</published>
    <updated>2017-12-07T11:52:35.387Z</updated>
    
    <content type="html"><![CDATA[<p><code>@routerCanActive</code> 在加载组件前执行，其回调函数有两种返回方式：</p><pre><code>@routerCanActive(function() {  // return true; 同步  // return Promise.resolve(true); 异步})</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;@routerCanActive&lt;/code&gt; 在加载组件前执行，其回调函数有两种返回方式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@routerCanActive(function() {
  // return true; 同步
  // return Promis
      
    
    </summary>
    
    
      <category term="tech" scheme="https://apporz.com/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title>使用Docker部署PHP应用的设计方案</title>
    <link href="https://apporz.com/2015/08/29/docker-lnmp/"/>
    <id>https://apporz.com/2015/08/29/docker-lnmp/</id>
    <published>2015-08-28T16:00:00.000Z</published>
    <updated>2017-12-08T13:17:42.223Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Docker"><a href="#1-Docker" class="headerlink" title="1. Docker"></a>1. Docker</h1><p>Docker的官方定义是：</p><blockquote><p>Docker allows you to package an application with all of its dependencies into a standardized unit for software development.</p><p>– <a href="https://www.docker.com/whatisdocker" target="_blank" rel="noopener">https://www.docker.com/whatisdocker</a></p></blockquote><p>毫无疑问的是，Docker解决了应用部署上一个巨大的问题：</p><p>客户: 安装好了，用不了。</p><p>发布者：我的机器上没问题。</p><p>如何解决每个应用的依赖在Docker出现之前是个头疼的问题，现在仅仅通过一次配置，Dockerfile或者image作为最终交付，就能在任何Linux上完美运行了。说起来很简单的样子，但在Docker配置过程中，又存在很多值得思考的问题：应用各个组件如何安排？一个Container解决问题还是细化Container？Container之间何如通信？等等。。下面用一个最普遍的WEB应用配置部署来说明这些问题。</p><p><strong>NOTE</strong>：本文假定读者对Docker中的一些概念有基本的认识，如果不甚了解，我推荐这篇文章：</p><p><a href="https://linux.cn/article-6074-weibo.html" target="_blank" rel="noopener">https://linux.cn/article-6074-weibo.html</a></p><h1 id="2-LNMP"><a href="#2-LNMP" class="headerlink" title="2. LNMP"></a>2. LNMP</h1><p>典型的PHP应用配置方案是LAMP或者LNMP，本文以LNMP为例。</p><p>设计方案如下图:</p><p><img src="202542_DLat_580940.png" alt=""></p><p>应用由4个组件组成，分别是Nginx，PHP-FPM(PHP)，MySQL以及WWW，4个组件运行在由各自镜像创建出来的独立的容器中。其中WWW Container只是一个存储业务代码和静态资源的容器，可以认为是”死”的。</p><p>事实上LNMP架构采用上面的设计方式应该是最容易想到的，也是最清晰的，每个组件有相对的独立性。其中除了WWW容器，其他3个容器都可以直接通过官方镜像构建出来。</p><p>然而网上很多同学并不是这样做的，不会分的这么细，通常是把Nginx和WWW放到一个容器内，或者干脆全部放到一个容器中。可以学习一下大家的Dockerfile:</p><p><a href="https://github.com/search?utf8=✓&amp;q=docker-lnmp" target="_blank" rel="noopener">https://github.com/search?utf8=✓&amp;q=docker-lnmp</a></p><p>细化Container这种设计的优缺点：</p><ol><li>容器间的耦合性增大。可以看到PHP-FPM容器和另外三个容器间有耦合关系，MySQL容器最独立。</li><li>虽然耦合性比较大，但这种端口耦合，文件系统耦合关系可以通过增加几个运行选项解决掉，后面有介绍。</li><li>由于容器对整个架构的划分，使得容器中的内容变得十分独立和安全。例如，我希望在线上更新WWW中的代码，只需要进入WWW容器做修改，不会影响到Nginx，PHP-FPM或者是MySQL。</li><li>各容器可灵活拆卸更换，比如我想把MySQL换成Mongodb，或者干脆把业务代码搬个家，不会影响到其他容器（仅仅更改相关配置文件）</li><li>由于各容器经由官方的镜像创建，因此可以随时花最少的代价使用最新的官方镜像尝鲜。</li><li>占用空间会比较大，一个简单的应用要这么做的话，四个镜像会占用大量的存储空间。</li></ol><h1 id="2-1-容器间通信问题"><a href="#2-1-容器间通信问题" class="headerlink" title="2.1 容器间通信问题"></a>2.1 容器间通信问题</h1><p>细化Container面临着另一个问题，就是如何进行容器间通信。下面简要描述一下上图中的数据流程：</p><ol><li>客户端的http请求达到server的80端口，该端口被映射到Nginx Container的80端口，因此进入Nginx处理。Nginx会分析请求资源，判定是静态资源还是php脚本，如果是静态资源，则直接从WWW中取出发回客户端；如果是脚本程序，则要告诉PHP-FPM到WWW获取相应脚本，然后通过php-cgi处理。</li><li>fast-cgi通过php执行脚本，必要时访问MySQL存取数据。</li></ol><p>这样耦合关系就出来了：</p><ol><li>Nginx需要连接PHP-FPM开放的9000端口，需要访问WWW中的文件系统。</li><li>PHP-FPM也需要访问WWW中的文件系统，还要访问MySQL的3306端口。</li></ol><h1 id="2-2-解决问题"><a href="#2-2-解决问题" class="headerlink" title="2.2 解决问题"></a>2.2 解决问题</h1><p>可以看出有两类耦合关系：端口和文件系统。</p><p>对于端口耦合，docker是通过–link选项解决的；对于文件系统耦合，docker是通过–volumes-from选项解决的。</p><p>解决第一个耦合关系：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -p 80:80 -p 443:443  <span class="comment"># 主机端口映射到容器</span></span><br><span class="line">--volumes-from WWW_CONTAINER_NAME  <span class="comment"># 把WWW容器VOLUME过的文件夹挂载到将启动的容器上</span></span><br><span class="line">--link PHP_FPM_CONTAINER_NAME:fpmservice  <span class="comment"># 冒号前是正在运行的FPM容器名称，后面是别名，别名会作为hostname在将启动的容器内可见</span></span><br><span class="line">-d  <span class="comment"># detach</span></span><br><span class="line">NGINX_IMAGE  <span class="comment"># 镜像名</span></span><br></pre></td></tr></table></figure><p>解决第二个耦合关系：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run --volumes-from WWW_CONTAINER_NAME</span><br><span class="line">--link MYSQL_CONTAINER_NAME:mysql</span><br><span class="line">-d</span><br><span class="line">PHP_FPM_IMAGE</span><br></pre></td></tr></table></figure><p>参考文档：<a href="https://docs.docker.com/reference/run/" target="_blank" rel="noopener">https://docs.docker.com/reference/run/</a></p><p>因此容器启动的先后顺序就出来了：</p><ol><li>MySQL Container</li><li>WWW Container (由于没有任何服务运行，容器run后会立即exit，可以使用 tail -f 等block命令使容器保持运行不退出)</li><li>PHP-FPM Container</li><li>Nginx Container</li></ol><p>其中1和2可以对换。</p><h1 id="3-Dockerfile"><a href="#3-Dockerfile" class="headerlink" title="3. Dockerfile"></a>3. Dockerfile</h1><p>Dockerfiles 请参见：</p><p><a href="https://github.com/micooz/dockerfile" target="_blank" rel="noopener">https://github.com/micooz/dockerfile</a></p><p><a href="http://git.oschina.net/micooz/dockerfile" target="_blank" rel="noopener">http://git.oschina.net/micooz/dockerfile</a></p><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><p>利用Docker部署Web应用可以带来很多便利，在宏观上实现应用组件化，为实现分布式系统奠定了基础。</p><p>可以看到实际上在Docker容器间共享数据是很方便的，搞清楚各容器的依赖关系就不难解决。</p><p>P.s. 本文是我学习docker两天后的心得体会，纰漏在所难免，如有错误还请斧正。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Docker&quot;&gt;&lt;a href=&quot;#1-Docker&quot; class=&quot;headerlink&quot; title=&quot;1. Docker&quot;&gt;&lt;/a&gt;1. Docker&lt;/h1&gt;&lt;p&gt;Docker的官方定义是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Docker all
      
    
    </summary>
    
    
      <category term="tech" scheme="https://apporz.com/tags/tech/"/>
    
      <category term="docker" scheme="https://apporz.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>C++使用模板类实现任意类型switch和变量case</title>
    <link href="https://apporz.com/2015/06/02/cpp-template-class-switch-case/"/>
    <id>https://apporz.com/2015/06/02/cpp-template-class-switch-case/</id>
    <published>2015-06-01T16:00:00.000Z</published>
    <updated>2017-12-08T13:17:42.217Z</updated>
    
    <content type="html"><![CDATA[<p>最近自己维护的一个项目<a href="https://github.com/micooz/program_options" target="_blank" rel="noopener">program_options</a>(是一个命令行生成与解析的C++库)在实际应用的时候遇到一个需求：</p><p>需要switch一个字符串来执行相应代码块，然而原生的switch-case条件选择语法针对condition有严格的限制，下面摘录一段switch的语法标准：</p><h2 id="switch-statement"><a href="#switch-statement" class="headerlink" title="switch statement"></a>switch statement</h2><p>Transfers control to one of the several statements, depending on the value of a condition.</p><p>Syntax</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">attr(optional) switch ( condition ) statement</span><br><span class="line"></span><br><span class="line">attr(C++11)-any number of attributes</span><br><span class="line">condition-any expression of integral or enumeration type, or of a class type contextually implicitly convertible to an integral or enumeration type, or a declaration of a single non-array variable of such type with a brace-or-equals initializer.</span><br><span class="line">statement-any statement (typically a compound statement). case: and default: labels are permitted in statement and break; statement has special meaning.</span><br><span class="line"></span><br><span class="line">attr(optional) case constant_expression : statement(1)</span><br><span class="line">attr(optional) default : statement(2)</span><br><span class="line"></span><br><span class="line">constant_expression-a constant expression of the same type as the type of condition after conversions and integral promotions</span><br></pre></td></tr></table></figure><h3 id="condition"><a href="#condition" class="headerlink" title="condition"></a>condition</h3><p>原生switch语法的condition支持整数，枚举或者根据上下文能够隐式转换为整数或者枚举的类，再或者是非数组类型的=或{}初始化语句，举例来说就是如下四类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(<span class="number">100</span>)</span><br><span class="line"><span class="keyword">enum</span> color &#123;r, g, b&#125;</span><br><span class="line"><span class="keyword">switch</span>(r)</span><br><span class="line"><span class="keyword">switch</span>(<span class="keyword">int</span> n = <span class="number">1</span>)</span><br><span class="line"><span class="keyword">switch</span>(<span class="keyword">int</span> n = &#123;<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><h3 id="case"><a href="#case" class="headerlink" title="case"></a>case</h3><p>必须是常量，这样一来就无法做变量与变量之间的比较。</p><h3 id="statement"><a href="#statement" class="headerlink" title="statement"></a>statement</h3><p>当statement没有被{}包围的时候，在其内使用声明语句会导致编译错误。比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(num)&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>; <span class="comment">// error: jump bypasses variable initialization</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然我的需求不能用原生的switch来实现，得老老实实if-elseif-elseif…来分别判断，导致代码又长又臭，if越套越多，逐条判断效率也让人心塞。</p><p>有需求就有想法，有想法就有创新，相信这样的需求早就有人实现过了，比如：</p><ul><li>为C++添加短字符串的switch-case支持<br>将字符串通过#@转换为整形再进行case</li><li>使用C++11新特性，实现用字符串作为switch的case子句<br>利用C++11的constexpr，计算字符串的hash值再进行case</li></ul><p>想法很不错，但是我想要更灵活的解决方案，我希望新的switch支持switch(object)，case(object)，还希望statement对变量声明没有限制，何不完全抛开原生switch的枷锁，自己利用标准库造一个switch来解决问题呢。</p><h2 id="蓝图"><a href="#蓝图" class="headerlink" title="蓝图"></a>蓝图</h2><p>我希望利用C++强大的<strong>template</strong>来兼容任意类型，用C++11的<strong>lambda</strong>匿名函数实现statement，用<strong>操作符重载</strong>operator==来匹配条件，用<strong>hash表</strong>来提升匹配效率，看起来很容易不是吗？</p><p>开始Coding之前我先拟定好蓝图：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 蓝图1</span></span><br><span class="line">select(condition, &#123;</span><br><span class="line">  &#123;<span class="string">"case1"</span>, []() &#123;</span><br><span class="line">    <span class="comment">// code goes here</span></span><br><span class="line">  &#125;&#125;,</span><br><span class="line">  &#123;<span class="string">"case2"</span>, []() &#123;</span><br><span class="line">    <span class="comment">// code goes here</span></span><br><span class="line">  &#125;&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 蓝图2</span></span><br><span class="line">select(condition)</span><br><span class="line">  .found(<span class="string">"case1"</span>, []() &#123;</span><br><span class="line">    <span class="comment">// code goes here</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .found(<span class="string">"case2"</span>, []() &#123;</span><br><span class="line">    <span class="comment">// code goes here</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .others([]() &#123;</span><br><span class="line">    <span class="comment">// default</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>我承认我是受到了javascript的影响，我一直以为C++越来越像是一种高级的脚本语言，或许也是它未来的发展趋势。</p><p>蓝图的设计首先符合C++的语法规范，没有语法错误，其次力求语义明确，简洁。</p><p>蓝图1的大括号太多，书写时容易出错。</p><p>蓝图2语法简洁明了，我相信任何会闭包的Coder都能理解。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>有了蓝图后我们就可以照着这个模样来写代码了，首先分析一下蓝图2。</p><ul><li>存在链式操作，显然select函数要返回一个对象，该对象有found和others方法，并且，found方法要返回实例本身。</li><li>condition和found的第一个参数类型必须一致，但不一定是string，也可以是int，Object，可用template实现</li><li>found第二个参数是lambda表达式，类型是std::function&lt;…&gt;，类似C里面的函数指针，可定义为回调函数。</li><li>每个found块对应于switch里的case，是一个kv关系，可用std::map来存储关联。</li></ul><p>C++建议模板类的声明和定义必须写在同一个文件里，因此起一个<strong>switch.hpp</strong>文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Ty&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Switch</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Switch()&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Switch</span><span class="params">(<span class="keyword">const</span> Ty&amp; target)</span></span></span><br><span class="line">      : target_(target) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  Switch&amp; found(const Ty&amp; _case, const std::function&lt;void(void)&gt;&amp; callback) &#123;</span><br><span class="line">    reflections_[_case] = callback;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">const</span> Ty&amp; target_;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">const</span> Ty, <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">void</span>)&gt;&gt; reflections_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Ty&gt;</span><br><span class="line">Switch&lt;Ty&gt; select(<span class="keyword">const</span> Ty&amp; expression) &#123;</span><br><span class="line">  <span class="keyword">return</span> Switch&lt;Ty&gt;(expression);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么一来就实现了found得链式操作，存储了kv对，全局(也可以在某个命名空间内)select函数是一个简化书写的帮助函数，创建对象后返回该对象的拷贝，实现了如下调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select(<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"condition"</span>))</span><br><span class="line">  .found ...</span><br></pre></td></tr></table></figure><p>接下来我需要实现查找到对应的target，然后调用它的callback。</p><p>增加一个done()方法，该方法被调用意味着结束整个Switch，开始匹配found块，如果没找到，调用others函数(对应default块)：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> kv = reflections_.find(target_);</span><br><span class="line">  <span class="keyword">if</span> (kv != reflections_.end()) &#123;</span><br><span class="line">    <span class="comment">// found</span></span><br><span class="line">    <span class="keyword">auto</span> scope = kv-&gt;second;</span><br><span class="line">    scope();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (has_others_scope_) &#123;</span><br><span class="line">    <span class="comment">// not found, call others</span></span><br><span class="line">    others_();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>std::map的find方法时间复杂度是O(logN)，而原生switch匹配时间复杂度是O(1)，肯定是有很大差距的，但是为了实现switch没有的功能，这点损失也是十分值得的。</p><p>others方法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">others</span><span class="params">(<span class="keyword">const</span> Scope&amp; callback)</span> </span>&#123;</span><br><span class="line">  has_others_scope_ = <span class="literal">true</span>;</span><br><span class="line">  others_ = callback;</span><br><span class="line">  <span class="keyword">this</span>-&gt;done();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当用户调用others方法定义了default块之后，就没必要再调用done了，又可以减少7个字符的书写。</p><p>这里has_others<em>scope</em>为bool成员；others<em>是单独存放的lambda表达式成员，为了简化查找，不宜放在reflections</em>中。</p><p>再简化书写，用typedef缩短类型，然后替换原类中相应类型为短类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">void</span>)&gt; Scope;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">const</span> Ty, Scope&gt; Reflections;</span><br></pre></td></tr></table></figure><p>这么一来几乎很完美了，全新的Switch如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> printl(<span class="meta-keyword">line</span>) printf((<span class="meta-keyword">line</span>)); printf(<span class="meta-string">"\n"</span>)</span></span><br><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">condition</span><span class="params">(<span class="string">"windows"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// match std::string</span></span><br><span class="line">select(condition)</span><br><span class="line">  .found(<span class="string">"apple"</span>, []() &#123;</span><br><span class="line">    printl(<span class="string">"it's apple"</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .found(<span class="string">"windows"</span>, []() &#123;</span><br><span class="line">    printl(<span class="string">"it's windows"</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .found(<span class="string">"linux"</span>, []() &#123;</span><br><span class="line">    printl(<span class="string">"it's linux"</span>);</span><br><span class="line">  &#125;).done();</span><br><span class="line"></span><br><span class="line"><span class="comment">// match int</span></span><br><span class="line">select(<span class="number">100</span>)</span><br><span class="line">  .found(<span class="number">10</span>, []() &#123;</span><br><span class="line">    printl(<span class="string">"it's 10"</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .found(<span class="number">20</span>, []() &#123;</span><br><span class="line">    printl(<span class="string">"it's 20"</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .others([]() &#123;</span><br><span class="line">    printl(<span class="string">"nothing found"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="comment">// it's windows</span></span><br><span class="line"><span class="comment">// nothing found</span></span><br></pre></td></tr></table></figure><p>我想进一步实现<strong>自定义class</strong>的case，定义一个User类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  explicit User(int age) : age_(age) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> User&amp; user) <span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;age_ &lt; user.age(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> age_; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> age_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Switch如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">User u1(20), u2(22), ux(20);</span><br><span class="line">  select(ux)</span><br><span class="line">    .found(u1, []() &#123;</span><br><span class="line">      printl(<span class="string">"it's u1"</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .found(u2, []() &#123;</span><br><span class="line">      printl(<span class="string">"it's u2"</span>);</span><br><span class="line">    &#125;).done();</span><br><span class="line">  <span class="comment">// it's u2</span></span><br></pre></td></tr></table></figure><p>非常有必要说明的是这个重载：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> User&amp; user) <span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;age_ &lt; user.age(); &#125;</span><br></pre></td></tr></table></figure><p>返回bool没有问题，但为什么必须是operator&lt;呢，原因在这句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> kv = reflections_.find(target_);</span><br></pre></td></tr></table></figure><p>std::map&lt;&gt;::find不是通过==进行查找的，而是&lt;，因此必须重载&lt;。</p><p>该重载必须被const修饰，原因也是find这句里面，const对象只能调用const方法。</p><p>标准库里的实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">LIBCPP_TYPE_VIS_ONLY</span> <span class="title">less</span> :</span> binary_function&lt;_Tp, _Tp, <span class="keyword">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x, <span class="keyword">const</span> _Tp&amp; __y)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;<span class="keyword">return</span> __x &lt; __y;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以非常明显的看到const和&lt;。</p><p>此外我还实现了Switch之间的found块组合，比较简单就不阐述了。</p><h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><p>常量字符串的转型问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select(<span class="string">"condition"</span>)</span><br><span class="line">  .found(<span class="string">"case"</span>, ...)</span><br><span class="line">  .done();</span><br></pre></td></tr></table></figure><p>编译器将”condition”理解为const char[10]，数组类型有固定长度，found块的_case参数类型是const char[5]，导致编译错误。原因在于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Switch&amp; <span class="title">found</span><span class="params">(<span class="keyword">const</span> Ty&amp; _case, <span class="keyword">const</span> Scope&amp; callback)</span></span></span><br></pre></td></tr></table></figure><p>这里传递const引用，因此编译器把”case”当做了const char[5]。此时Ty的类型和说好的const char[10]不一致，编译失败。</p><p>解决方法是通过std::string来避免数组长度不匹配问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select(<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"condition"</span>))</span><br><span class="line">  .found(<span class="string">"case"</span>, ...)</span><br><span class="line">  .done();</span><br></pre></td></tr></table></figure><p>希望读者有更好地解决方案。</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>这里直接引用我项目里面的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PROGRAM_OPTIONS_SWITCH_HPP_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROGRAM_OPTIONS_SWITCH_HPP_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> program_options &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief The Switch template class.</span></span><br><span class="line"><span class="comment">* @param Ty The target type.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Ty&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Switch</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">void</span>)&gt; Scope;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">const</span> Ty, Scope&gt; Reflections;</span><br><span class="line"></span><br><span class="line">  Switch() : has_others_scope_(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Switch</span><span class="params">(<span class="keyword">const</span> Ty&amp; target)</span></span></span><br><span class="line">      : target_(target), has_others_scope_(false) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief Create a case block with an expression and a callback function.</span></span><br><span class="line"><span class="comment">   * @param _case The case expression, variable is allowed.</span></span><br><span class="line"><span class="comment">   * @param callback The callback function, can be a lambda expression.</span></span><br><span class="line"><span class="comment">   * @return The current Switch instance.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">Switch&amp; <span class="title">found</span><span class="params">(<span class="keyword">const</span> Ty&amp; _case, <span class="keyword">const</span> Scope&amp; callback)</span> </span>&#123;</span><br><span class="line">    reflections_[_case] = callback;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief Create a default block with a callback function,</span></span><br><span class="line"><span class="comment">   *        if no cases matched, this block will be called.</span></span><br><span class="line"><span class="comment">   * @param callback</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">others</span><span class="params">(<span class="keyword">const</span> Scope&amp; callback)</span> </span>&#123;</span><br><span class="line">    has_others_scope_ = <span class="literal">true</span>;</span><br><span class="line">    others_ = callback;</span><br><span class="line">    <span class="keyword">this</span>-&gt;done();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief Finish the cases,</span></span><br><span class="line"><span class="comment">   * others() will call this method automatically.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> kv = reflections_.find(target_);</span><br><span class="line">    <span class="keyword">if</span> (kv != reflections_.end()) &#123;</span><br><span class="line">      <span class="comment">// found</span></span><br><span class="line">      <span class="keyword">auto</span> scope = kv-&gt;second;</span><br><span class="line">      scope();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (has_others_scope_) &#123;</span><br><span class="line">      <span class="comment">// not found, call others</span></span><br><span class="line">      others_();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief Combine the cases to this Switch from another Switch.</span></span><br><span class="line"><span class="comment">   *        Note that this two Switch should be the same template.</span></span><br><span class="line"><span class="comment">   * @param _switch Another Switch instance.</span></span><br><span class="line"><span class="comment">   * @return</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> Switch&amp; <span class="title">combine</span><span class="params">(<span class="keyword">const</span> Switch&amp; _switch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> kv : _switch.reflections()) &#123;</span><br><span class="line">      <span class="keyword">this</span>-&gt;reflections_[kv.first] = kv.second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief Return the case-callback pairs.</span></span><br><span class="line"><span class="comment">   * @return</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> Reflections <span class="title">reflections</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> reflections_; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">const</span> Ty&amp; target_;</span><br><span class="line">  <span class="keyword">bool</span> has_others_scope_;</span><br><span class="line">  Scope others_;</span><br><span class="line">  Reflections reflections_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Define which expression does the Switch match.</span></span><br><span class="line"><span class="comment"> * @param expression</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Ty&gt;</span><br><span class="line">Switch&lt;Ty&gt; select(<span class="keyword">const</span> Ty&amp; expression) &#123;</span><br><span class="line">  <span class="keyword">return</span> Switch&lt;Ty&gt;(expression);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// PROGRAM_OPTIONS_SWITCH_HPP_</span></span></span><br></pre></td></tr></table></figure><p>欢迎各位读者指正。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近自己维护的一个项目&lt;a href=&quot;https://github.com/micooz/program_options&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;program_options&lt;/a&gt;(是一个命令行生成与解析的C++库)在实际应用的
      
    
    </summary>
    
    
      <category term="tech" scheme="https://apporz.com/tags/tech/"/>
    
      <category term="cpp" scheme="https://apporz.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>Google C++ Style Guide 笔记</title>
    <link href="https://apporz.com/2015/02/23/google-cpp-style-guide-note/"/>
    <id>https://apporz.com/2015/02/23/google-cpp-style-guide-note/</id>
    <published>2015-02-22T16:00:00.000Z</published>
    <updated>2017-12-08T13:17:42.226Z</updated>
    
    <content type="html"><![CDATA[<p>英文原版: <a href="http://google-styleguide.googlecode.com/svn/trunk/cppguide.html" target="_blank" rel="noopener">http://google-styleguide.googlecode.com/svn/trunk/cppguide.html</a></p><h1 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h1><p>每个源文件都要对应一个头文件。例外：单元测试文件和仅包含main的小型源文件。</p><h2 id="独立头文件"><a href="#独立头文件" class="headerlink" title="独立头文件"></a>独立头文件</h2><p>以.h结尾的都是应该是独立的，以.inc结尾的仅用作文本包含，所有头文件都必须是独立的。</p><p>inline和template函数的声明和定义(实现)应该在同一个文件中。</p><p>Note:这里的独立是指，用户和重构工具可以无特殊限制地包含头文件。</p><h2 id="define宏保护"><a href="#define宏保护" class="headerlink" title="define宏保护"></a>define宏保护</h2><p>所有头文件都应该使用#define来防止重复包含。格式如下：</p><p>头文件路径：foo/src/bar/baz.h</p><pre><code>&lt;!-- lang: cpp --&gt;#ifndef FOO_BAR_BAZ_H_#define FOO_BAR_BAZ_H_...#endif  // FOO_BAR_BAZ_H_</code></pre><h2 id="前置声明"><a href="#前置声明" class="headerlink" title="前置声明"></a>前置声明</h2><p>前置声明用来避免不必要的include，但有很多缺陷。</p><ul><li>当使用在一个头文件中已声明的函数时，总是include那个头文件</li><li>当使用类模板，最好include它的头文件</li><li>当使用一个一般的class时，可以进行前置声明，但是要小心它可能是不完整或不正确的，不确定时，就include合适的头文件</li><li>不要为了避免使用include而把数据成员换成指针</li></ul><h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>仅在函数少于10行时，才可以把函数定义为inline。</p><p>过度使用inline，实际上会使程序变慢。inline一个非常短的函数可以缩短代码长度，而inline一个很长的函数反而会戏剧性地增大代码长度。</p><p>小心析构函数，他们的代码通常比表面上的更长，因为存在虚函数和父析构函数调用。</p><p>虚函数和递归函数不应该被inline。</p><h2 id="参数顺序"><a href="#参数顺序" class="headerlink" title="参数顺序"></a>参数顺序</h2><p>顺序应该是：输入，输出</p><p>输入参数通常是按值，或按const引用传入。输出则是non-const的指针（引用也是指针实现的）。</p><p>当要新增一个参数时，应该按照上面顺序加入。</p><p>注意这个规则不是硬性的，可以放宽这个规则以确保一致性。</p><h2 id="includes的名称和顺序"><a href="#includes的名称和顺序" class="headerlink" title="includes的名称和顺序"></a>includes的名称和顺序</h2><p>顺序：</p><ol><li>关联的头文件  —-&gt;  确保编译当前源文件时提前报错，而不牵扯到别人的文件。</li><li>C库</li><li>C++库</li><li>第三方库</li><li>你的项目头文件</li></ol><p>每个部分再按字典顺序排列。例如：</p><pre><code>&lt;!-- lang: cpp --&gt;#include &quot;foo/server/fooserver.h&quot;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;hash_map&gt;#include &lt;vector&gt;#include &quot;base/basictypes.h&quot;#include &quot;base/commandlineflags.h&quot;#include &quot;foo/server/bar.h&quot;</code></pre><p>系统相关的头文件可用宏来限定，以减小代码和保持本地化。</p><pre><code>&lt;!-- lang: cpp --&gt;#include &quot;foo/public/fooserver.h&quot;#include &quot;base/port.h&quot;  // For LANG_CXX11.#ifdef LANG_CXX11#include &lt;initializer_list&gt;#endif  // LANG_CXX11</code></pre><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>在源文件中鼓励使用匿名命名空间（ namespace {…} ），对于非匿名命名空间则选取它的路径来命名。不要使用using namespace。不要使用inline命名空间。</p><h2 id="匿名命名空间"><a href="#匿名命名空间" class="headerlink" title="匿名命名空间"></a>匿名命名空间</h2><ol><li><p>可以避免链接期的名字冲突：</p> <!-- lang: cpp --><p> namespace {                           // This is in a .cc file.</p><p> // The content of a namespace is not indented.<br> //<br> // This function is guaranteed not to generate a colliding symbol<br> // with other symbols at link time, and is only visible to<br> // callers in this .cc file.<br> bool UpdateInternals(Frobber* f, int newval) {<br>   …<br> }</p><p> }  // namespace</p></li><li><p>不要在头文件中使用匿名命名空间。</p></li></ol><h2 id="含名称的命名空间"><a href="#含名称的命名空间" class="headerlink" title="含名称的命名空间"></a>含名称的命名空间</h2><ul><li><p>在includes，gflags声明和定义，其他命名空间中class的前置声明之后，包裹全部的代码：</p>  <!-- lang: cpp --><p>  // In the .h file<br>  namespace mynamespace {</p><p>  // All declarations are within the namespace scope.<br>  // Notice the lack of indentation.<br>  class MyClass {<br>   public:</p><pre><code>...void Foo();</code></pre><p>  };</p><p>  }  // namespace mynamespace<br>  // In the .cc file<br>  namespace mynamespace {</p><p>  // Definition of functions is within scope of the namespace.<br>  void MyClass::Foo() {</p><pre><code>...</code></pre><p>  }</p><p>  }  // namespace mynamespace</p></li><li><p>不要在std中声明任何东西，也不要对标准库的class进行前置声明。</p></li><li><p>不要使用using namespace</p>  <!-- lang: cpp --><p>  // Forbidden – This pollutes the namespace.<br>  using namespace foo;</p></li><li><p>可以在源文件的任意位置，在头文件的函数，方法，class中使用using声明</p>  <!-- lang: cpp --><p>  // OK in .cc files.<br>  // Must be in a function, method or class in .h files.<br>  using ::foo::bar;</p></li><li><p>别名命名空间可以在源文件的任意位置，头文件的namespace内，函数，方法内使用。</p>  <!-- lang: cpp --><p>  // Shorten access to some commonly used names in .cc files.<br>  namespace fbz = ::foo::bar::baz;</p><p>  // Shorten access to some commonly used names (in a .h file).<br>  namespace librarian {<br>  // The following alias is available to all files including<br>  // this header (in namespace librarian):<br>  // alias names should therefore be chosen consistently<br>  // within a project.<br>  namespace pd_s = ::pipeline_diagnostics::sidetable;</p><p>  inline void my_inline_function() {</p><pre><code>// namespace alias local to a function (or method).namespace fbz = ::foo::bar::baz;...</code></pre><p>  }<br>  }  // namespace librarian</p></li></ul><p>Note：尽量避免在公共头文件中使用别名命名空间。</p><ul><li>不要使用inline命名空间</li></ul><h2 id="成员类"><a href="#成员类" class="headerlink" title="成员类"></a>成员类</h2><pre><code>&lt;!-- lang: cpp --&gt;class Foo { private:  // Bar is a member class, nested within Foo.  class Bar {    ...  };};</code></pre><p>不要把成员类公开，除非他们确实是这个接口的一部分。</p><h2 id="非成员，静态成员和全局函数"><a href="#非成员，静态成员和全局函数" class="headerlink" title="非成员，静态成员和全局函数"></a>非成员，静态成员和全局函数</h2><p>最好在命名空间中使用非成员函数，或使用静态成员函数，而不要或很少使用全局函数。</p><p>非成员函数不应该依赖于外部变量，并且应该总处于一个命名空间中。</p><p>那些仅仅用来集结静态成员函数，且没有共享静态数据的类，应该用命名空间取而代之。</p><p>如果必须要使用非成员函数并且只在当前这个源文件中使用，则用一个匿名命名空间或static修饰来限制它的作用域。</p><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>将一个函数中的变量放到尽可能有限的作用域内，并在声明时初始化。</p><pre><code>&lt;!-- lang: cpp --&gt;int i;i = f();      // Bad -- initialization separate from declaration.int j = g();  // Good -- declaration has initialization.vector&lt;int&gt; v;v.push_back(1);  // Prefer initializing using brace initialization.v.push_back(2);vector&lt;int&gt; v = {1, 2};  // Good -- v starts initialized.</code></pre><p>一些供if,while,for使用的变量应该在statement处声明。</p><pre><code>&lt;!-- lang: cpp --&gt;while (const char* p = strchr(str, &apos;/&apos;)) str = p + 1;</code></pre><p>一点注意：如果是变量是一个对象，构造函数将在每次进入作用域时被执行，析构函数将在每次离开作用域时被执行。</p><pre><code>&lt;!-- lang: cpp --&gt;// Inefficient implementation:for (int i = 0; i &lt; 1000000; ++i) {  Foo f;  // My ctor and dtor get called 1000000 times each.  f.DoSomething(i);}// 对象放在外面更高效Foo f;  // My ctor and dtor get called once each.for (int i = 0; i &lt; 1000000; ++i) {  f.DoSomething(i);}</code></pre><h2 id="静态和全局变量"><a href="#静态和全局变量" class="headerlink" title="静态和全局变量"></a>静态和全局变量</h2><p>类的静态或全局变量是禁止使用的。然而constexpr的变量是被允许的，因为他们不会动态初始化或销毁。</p><p>静态存储的对象，包括全局变量，静态变量，静态类成员变量以及函数内静态变量，必须是Plain Old Data(POD)。</p><p>只有int,char,float,pointer,或者arrays/structs属于POD。</p><p>静态vector应该用C数组代替，静态string应该用const char []代替。</p><p>如果需要使用静态或全局类对象，考虑初使用它的指针类型（不会被order-of-destrctor释放掉），注意必须是一个纯的指针，而不是一个智能指针。</p><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><h2 id="构造函数该做的事"><a href="#构造函数该做的事" class="headerlink" title="构造函数该做的事"></a>构造函数该做的事</h2><p>避免在构造函数中进行复杂初始化，比如那些可能会失败或者进行虚函数调用的步骤。</p><p>构造函数不应该调用虚函数，或者试图抛出非致命性错误。如果你的对象需要进行重要的初始化工作，考虑使用一个工厂函数或init方法。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h2 id="明确构造函数"><a href="#明确构造函数" class="headerlink" title="明确构造函数"></a>明确构造函数</h2><p>在具有一个参数的构造函数上使用explicit关键字。因为构造时传入一个参数可能会被编译器当做拷贝构造进行隐式转换。</p><pre><code>&lt;!-- lang: cpp --&gt;explicit Foo(string name);</code></pre><p>除了构造函数的第一个参数外，其他参数都应该指定一个默认值,来防止不期望的类型转换。</p><pre><code>&lt;!-- lang: cpp --&gt;Foo::Foo(string name, int id = 42)</code></pre><p>拷贝构造函数，以及作为其他类的透明包装的类，不应该被explicit修饰。</p><h2 id="可拷贝和可移动类型"><a href="#可拷贝和可移动类型" class="headerlink" title="可拷贝和可移动类型"></a>可拷贝和可移动类型</h2><p>可拷贝的例子：std::string</p><p>可移动但不可拷贝的例子：std::unique_ptr<int></int></p><p>对于一些不需要拷贝操作的类型，提供拷贝操作符可能会产生混淆，无意义或者完全是不正确的。</p><p>基类的拷贝、赋值操作符是有风险的，他们会导致对象分裂。</p><p>如果要加入拷贝特性，就要同时定义拷贝构造函数和赋值操作符。</p><p>如果你的类型可拷贝，但移动操作符更高效，那么就同时定义移动操作。</p><p>避免给试图被继承的类提供赋值操作符或公开的拷贝/移动构造函数。</p><p>如果你的基类需要被拷贝，提供一个公开的虚Clone()方法，和一个保护的拷贝构造函数，来使子类能够实现它。</p><p>如果你不想支持拷贝/移动操作，使用 = delete 来明确地禁用它们。</p><h2 id="委托和继承构造函数"><a href="#委托和继承构造函数" class="headerlink" title="委托和继承构造函数"></a>委托和继承构造函数</h2><p>委托构造的例子：</p><pre><code>&lt;!-- lang: cpp --&gt;X::X(const string&amp; name) : name_(name) {  ...}X::X() : X(&quot;&quot;) { }</code></pre><p>继承构造的例子：</p><pre><code>&lt;!-- lang: cpp --&gt;class Base { public:  Base();  Base(int n);  Base(const string&amp; s);  ...};class Derived : public Base { public:  using Base::Base;  // Base&apos;s constructors are redeclared here.};</code></pre><p>在能减少冗余和改善可读性的前提下使用委托和继承。</p><h2 id="结构体-vs-类"><a href="#结构体-vs-类" class="headerlink" title="结构体 vs. 类"></a>结构体 vs. 类</h2><p>struct仅在存储数据时使用，否则使用class。</p><p>struct可以直接访问字段而不通过方法调用。struct内的方法只用来设置数据成员。</p><p>如果需要更多地函数支持，class更合适，如果不确定用哪个，就用class。</p><p>注意struct和class内的成员变量具有不同的命名方式。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>组合通常比继承更合适。当使用继承时，指明为public。</p><p>实际上，继承在C++中主要应用于两个方面：</p><ul><li>实现继承（最普通意义上的继承）</li><li>接口继承（仅继承方法，实现接口）</li></ul><p>所有的继承都应当是public的，如果你需要用private继承，你就应该保存一份基类的成员实例来替代private继承（达到private的效果）。</p><p>不要过度使用实现继承，因为代码实现被分散于子类和基类。</p><p>继承应该被限定为”is-a”的关系，即”子类是基类的特例”。</p><p>如果你的类中有虚函数，那么你的析构函数也必须是virtual。</p><p>数据成员应该是private的。</p><h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><p>仅有很少的多重实现继承是有用的。你通常可以找到一个不同的，更明确地，更干净的解决方案。</p><p>多继承仅允许在父类都是纯接口的时候使用。</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>一个类是纯接口的条件：</p><ul><li>只有public的纯虚函数（= 0）和静态方法（析构函数除外）</li><li>不含非静态的数据成员</li><li>不需要构造函数，如果有，一定没有参数以及被声明为protected</li><li>如果它是子类，它的父类也必须符合这些条件</li></ul><h2 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h2><p>不要重载那些很少使用的，特殊的操作符。不要给用户字面值定义操作符。</p><p>为了使类模板函数正常工作，你或许需要定义操作符。</p><p>虽然操作符重载可以使代码更简洁，但它有以下几个缺点：</p><ul><li>它会让我们以为原本高代价的操作是划算的</li><li>不便于寻找到底调用了那个方法，例如Equals()要比==更方便查找</li><li>许多操作符对指针也有效，很容易出bug。例如：Foo + 4和 &amp;Foo + 4截然不同</li><li>用户字面值允许创造出新的句法，即使经验丰富的C++程序员也会觉得陌生</li></ul><p>重载也会出现意想不到的后果，比如，一个类重载了一元operator&amp;，它将不能安全的被前置声明。</p><p>一般而言，不要定义操作符重载。需要时你可以用普通的函数例如Equals()来替代。</p><p>不要重载operator””，即用户字面值。</p><p>当然，有些情况下可以进行重载，例如对标准C++库：</p><pre><code>&lt;!-- lang: cpp --&gt;operator&lt;&lt;(ostream&amp;, const T&amp;) for logging</code></pre><h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><p>使数据成员是private的，然后提供访问函数（getter/setter）来访问它们。例如：一个叫做foo_的变量有一个foo()访问函数，或者set_foo()。</p><p>例外：static const 数据成员(kFoo)不应该是private。</p><p>访问器的定义通常是内联在头文件中的。</p><h2 id="声明顺序"><a href="#声明顺序" class="headerlink" title="声明顺序"></a>声明顺序</h2><p>public: protected: private: ；方法在数据成员之前。</p><p>每个区块内的顺序：</p><ul><li>typedef &amp; enum</li><li>常量（包括静态数据成员）</li><li>构造函数</li><li>析构函数</li><li>方法（包括静态方法）</li><li>数据成员（静态数据除外）</li></ul><p>友元函数总是在private内声明。</p><p>在源文件中的方法定义应该和声明顺序尽量保持一致。</p><h2 id="写出短小的函数"><a href="#写出短小的函数" class="headerlink" title="写出短小的函数"></a>写出短小的函数</h2><p>书写短小的，清晰地函数。如果一个函数超过40行，可以考虑是否可以在不改变程序结构的前提下进行分割。</p><h1 id="Google经验技巧"><a href="#Google经验技巧" class="headerlink" title="Google经验技巧"></a>Google经验技巧</h1><h2 id="所有权和智能指针"><a href="#所有权和智能指针" class="headerlink" title="所有权和智能指针"></a>所有权和智能指针</h2><p>最好使用std::unique_ptr来使所有权传递更明确：</p><pre><code>&lt;!-- lang: cpp --&gt;std::unique_ptr&lt;Foo&gt; FooFactory();void FooConsumer(std::unique_ptr&lt;Foo&gt; ptr);</code></pre><p>在没有一个非常好的理由的前提下，不要把你的代码设计为共享所有权。</p><p>不要再新的代码中使用scoped_ptr除非为了适配老版本的C++。</p><p>不要使用std::auto_ptr，用std::unique_ptr代替。</p><h2 id="cpplint"><a href="#cpplint" class="headerlink" title="cpplint"></a>cpplint</h2><p>使用cpplint.py来检查风格错误。</p><h1 id="其他C-特性"><a href="#其他C-特性" class="headerlink" title="其他C++特性"></a>其他C++特性</h1><h2 id="引用参数"><a href="#引用参数" class="headerlink" title="引用参数"></a>引用参数</h2><p>所有按引用传递的参数必须被const修饰。</p><pre><code>&lt;!-- lang: cpp --&gt;void Foo(const string &amp;in, string *out);</code></pre><p>有些情况下用const T* 做输入参数比const T&amp;好：</p><ul><li>要传递一个空指针</li><li>该函数将指针或引用保存到输入参数</li></ul><p>记住大多数时候输入参数都写为const T&amp;。</p><h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><p>右值引用只在move构造函数以及move赋值操作符定义时使用，不要使用std::forward。</p><ul><li>在move构造函数中应用右值引用，可以实现移动数据而不是复制数据，例如：auto v2(std::move(v1))会把v1数据移动到v2中，而不是完全复制一遍，可用于性能提升。</li><li>无论参数是否为临时对象，右值引用都可以经行参数传递。</li><li>右值引用对于没有明确定义拷贝操作，但你仍想向其传递参数的函数有很大的意义，比如向容器内存放数据而不需要copy。</li><li>std::move对高效使用一些标准库类型，例如std::unique_ptr很有必要。</li><li>右值引用作为C++11的新特性，还没有被广泛得理解和应用。</li></ul><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>如果一个函数依靠参数类型的不同来进行重载，读者可能必须理解C++的复杂匹配机制来确定接下来会发生什么。</p><p>如果你像重载一个函数，考虑给出一些信息对参数进行限定，例如使用AppendString(), AppendInt()而不仅仅是Append()。</p><h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><p>除了下面几个情形，我们不允许默认函数参数。如果合适的话，请用函数重载在替代。</p><p>当默认参数做函数指针时容易使人混淆，因为函数签名常常不会匹配调用。加入默认参数时会改变函数的类型，这样会在获取它的地址时造成一些问题。使用函数重载可以避免这个问题。</p><p>一些例外：</p><p>当一个静态函数出现在源文件中时，由于本地化的缘故上述规则不再适用。</p><p>另外，默认参数可在构造函数中使用，上述规则也不适用，因为不可能获取到构造函数的地址。</p><p>还有一个例外是默认参数用来模拟变长数组时，例如：</p><pre><code>&lt;!-- lang: cpp --&gt;// Support up to 4 params by using a default empty AlphaNum.string StrCat(const AlphaNum &amp;a,              const AlphaNum &amp;b = gEmptyAlphaNum,              const AlphaNum &amp;c = gEmptyAlphaNum,              const AlphaNum &amp;d = gEmptyAlphaNum);</code></pre><h2 id="变长数组和alloca"><a href="#变长数组和alloca" class="headerlink" title="变长数组和alloca()"></a>变长数组和alloca()</h2><p>我们不允许使用变长数组或者alloca()</p><p>变长数组和alloca()并不是标准C++的一部分。更重要的是，他会在栈空间中分配大量的空间，可能会触发内存覆盖的bug：在我机器上运行的好好的，在生产环境却死掉了。。</p><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>友元通常都应该被定义在同一个文件中。</p><p>通常会定义一个FooBuilder作为Foo的一个友元。</p><p>在创建一个单元测试的时候，使用友元很管用。</p><h2 id="例外"><a href="#例外" class="headerlink" title="例外"></a>例外</h2><p>我们不使用C++的exceptions。</p><h2 id="运行时类型信息（RTTI）"><a href="#运行时类型信息（RTTI）" class="headerlink" title="运行时类型信息（RTTI）"></a>运行时类型信息（RTTI）</h2><p>避免使用RTTI。</p><p>在运行时查询对象的类型可以说是一个错误的设计问题。</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>使用C++的类型转换如static_cast<int>()。而不要用C-style的int y = (int)x或者int y = int(x)。</int></p><p>使用const_cast来除去const限定，只在你知道你在做什么的情况下，使用reinterpret_cast来做不安全的指针转换。</p><h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><p>流仅用于日志。使用类似printf的形式来代替流。</p><h2 id="前加和前减"><a href="#前加和前减" class="headerlink" title="前加和前减"></a>前加和前减</h2><p>在迭代器和其他模板对象上使用前加或前减。</p><p>当表达式的返回值被忽略时，++i比i++更高效。如果i是一个迭代器，由于i++的复制，开销很大。</p><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>只要讲得通，随时随地使用const。C++11中的constexpr是更好的选择。</p><ul><li>如果一个函数不会修改按引用传递，指针传递的参数，那么这个参数应该是const。</li><li>如果可以，把方法声明为const。访问器应该总是const的。其他方法如果不修改任何数据成员，不调用任何非const方法，不返回非const指针或非const引用，也应该修饰为const。</li><li>数据成员在构造函数执行之后不会被修改，应该声明为const。</li></ul><p>const应该放在哪儿？</p><pre><code>&lt;!-- lang: cpp --&gt;int const *foo;const int* foo;</code></pre><p>把const放在第一位具有更好地可读性，因为它符合英语的习惯：形容词（const），然后是名词（int）。</p><h2 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h2><p>在C++11中，可以使用constexpr来定义真实地常量或者确保常量初始化。</p><h2 id="整形"><a href="#整形" class="headerlink" title="整形"></a>整形</h2><p><stdint.h>中定义了一些不同长度的整形：int16_t, uint32_t, int64_t 等等。你应该总是使用这些整形，特别是你需要保证整形的长度时。</stdint.h></p><p>当我们认为一个整数”比较大”时，用int64_t。</p><p>你不应该使用无符号整形，如uint32_t，除非有一个合理的原因。特别的，不要认为使用了无符号类型它就不会是负数，使用断言来检验正负。</p><p>如果你需要接收一个容器的大小，确保你的类型能够容纳这个数字，否则使用一个更大的类型。</p><p>注意整形转换、类型提升可能会导致非预期行为。</p><p>关于无符号整形</p><pre><code>&lt;!-- lang: cpp --&gt;for (unsigned int i = foo.Length()-1; i &gt;= 0; --i) ...</code></pre><p>这将是一个死循环，因为unsigned int 和 int 比较。因此使用断言来证明非负。不要使用无符号类型来表示非负数。</p><h2 id="预处理宏"><a href="#预处理宏" class="headerlink" title="预处理宏"></a>预处理宏</h2><p>最好使用内联函数、枚举和const量代替宏。在使用宏之前，考虑是否有非宏的解决方案。</p><p>如果你使用了宏，应该注意：</p><ul><li>不要在头文件中定义宏</li><li>使用前正确定义它，使用后undef它</li><li>不要仅仅是为了替换为自己的而undef一个宏，应该取一个唯一的新名字</li><li>最好不要用##来生成函数、类、变量名</li></ul><h2 id="0-、nullptr、NULL"><a href="#0-、nullptr、NULL" class="headerlink" title="0 、nullptr、NULL"></a>0 、nullptr、NULL</h2><p>用0表示整形，0.0表示实数、nullptr（或NULL）表示指针，’\0’表示字符。</p><p>特别在一些情况下，sizeof(NULL)和sizeof(0)不同。</p><h2 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h2><p>最好使用sizeof(varname)而非sizeof(type)。因为当var改变时，sizeof(type)不会改变而sizeof(varname)会跟着改变。</p><pre><code>&lt;!-- lang: cpp --&gt;Struct data;memset(&amp;data, 0, sizeof(data));memset(&amp;data, 0, sizeof(Struct));if (raw_size &lt; sizeof(int)) {  LOG(ERROR) &lt;&lt; &quot;compressed record not big enough for count: &quot; &lt;&lt; raw_size;  return false;}</code></pre><h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h2><p>只在类型名十分混乱时使用auto，如果能增加可读性，继续使用完整地类型声明，除了局部变量外不要到处都用auto。</p><p>不要在文件域，命名空间域，类成员中使用auto。从不对大括号初始化列表使用auto。</p><h2 id="括号初始化列表"><a href="#括号初始化列表" class="headerlink" title="括号初始化列表"></a>括号初始化列表</h2><p>一些例子：</p><pre><code>&lt;!-- lang: cpp --&gt;// Basically the same, ignoring some small technicalities.// You may choose to use either form.vector&lt;string&gt; v = {&quot;foo&quot;, &quot;bar&quot;};// Usable with &apos;new&apos; expressions.auto p = new vector&lt;string&gt;{&quot;foo&quot;, &quot;bar&quot;};// A map can take a list of pairs. Nested braced-init-lists work.map&lt;int, string&gt; m = {{1, "one"}, {2, "2"}};// A braced-init-list can be implicitly converted to a return type.vector&lt;int&gt; test_function() { return {1, 2, 3}; }// Iterate over a braced-init-list.for (int i : {-1, -2, -3}) {}// Call a function using a braced-init-list.void TestFunction2(vector&lt;int&gt; v) {}TestFunction2({1, 2, 3});</code></pre><p>也可以给自己的类型定义初始化列表：</p><pre><code>&lt;!-- lang: cpp --&gt;class MyType { public:  // std::initializer_list references the underlying init list.  // It should be passed by value.  MyType(std::initializer_list&lt;int&gt; init_list) {    for (int i : init_list) append(i);  }  MyType&amp; operator=(std::initializer_list&lt;int&gt; init_list) {    clear();    for (int i : init_list) append(i);  }};MyType m{2, 3, 5, 7};</code></pre><p>在没有使用std::initializer_list<t>的情况下也可以：</t></p><pre><code>&lt;!-- lang: cpp --&gt;double d{1.23};// Calls ordinary constructor as long as MyOtherType has no// std::initializer_list constructor.class MyOtherType { public:  explicit MyOtherType(string);  MyOtherType(int, string);};MyOtherType m = {1, &quot;b&quot;};// If the constructor is explicit, you can&apos;t use the &quot;= {}&quot; form.MyOtherType m{&quot;b&quot;};</code></pre><p>不要给{}使用auto：</p><pre><code>&lt;!-- lang: cpp --&gt;auto d = {1.23};        // d is a std::initializer_list&lt;double&gt;auto d = double{1.23};  // Good -- d is a double, not a std::initializer_list.</code></pre><h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p>在适当的条件下用lambda表达式，不要使用默认的lambda捕获，把所有捕获明确地写出来。</p><p>如果匿名函数超过了5行，考虑给它起一个名字或者使用一个有名函数代替lambda表达式。</p><h2 id="C-11"><a href="#C-11" class="headerlink" title="C++11"></a>C++11</h2><p>合适的时候，用C++11编写的类库。在使用C++11之前，考虑好对其他环境的可移植性。</p><h1 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h1><h2 id="普遍命名规则"><a href="#普遍命名规则" class="headerlink" title="普遍命名规则"></a>普遍命名规则</h2><p>函数名，变量名和文件名应该是具有描述性的，而不是缩略的。</p><pre><code>&lt;!-- lang: cpp --&gt;int price_count_reader;    // No abbreviation.int num_errors;            // &quot;num&quot; is a widespread convention.int num_dns_connections;   // Most people know what &quot;DNS&quot; stands for.int n;                     // Meaningless.int nerr;                  // Ambiguous abbreviation.int n_comp_conns;          // Ambiguous abbreviation.int wgc_connections;       // Only your group knows what this stands for.int pc_reader;             // Lots of things can be abbreviated &quot;pc&quot;.int cstmr_id;              // Deletes internal letters.</code></pre><h2 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h2><p>文件名都该是小写的，并且可以包含下划线<em>或者短划线-。如果你的项目没有约定，最好用下划线</em>。</p><p>一些例子：</p><pre><code>&lt;!-- lang: cpp --&gt;my_useful_class.ccmy-useful-class.ccmyusefulclass.ccmyusefulclass_test.cc // _unittest and _regtest are deprecated.</code></pre><p>不要使用在/usr/include中已近存在的文件名，例如：db.h</p><p>普遍地，明确你的文件名。例如：http_server_logs.h 比 logs.h 好很多。</p><p>如果内联函数非常短，应该直接写在头文件中。</p><h2 id="类型名"><a href="#类型名" class="headerlink" title="类型名"></a>类型名</h2><p>类型名以大写字母开头，并且每个词开头都是大写的：MyExcitingClass, MyExcitingEnum。</p><pre><code>&lt;!-- lang: cpp --&gt;// classes and structsclass UrlTable { ...class UrlTableTester { ...struct UrlTableProperties { ...// typedefstypedef hash_map&lt;UrlTableProperties *, string&gt; PropertiesMap;// enumsenum UrlTableErrors { ...</code></pre><h2 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h2><p>变量和数据成员都是小写的，单词间有下划线：a_local_variable, a_struct_data_member, a_class_data<em>member</em>。</p><pre><code>&lt;!-- lang: cpp --&gt;string table_name;  // OK - uses underscore.string tablename;   // OK - all lowercase.string tableName;   // Bad - mixed case.</code></pre><p>类数据成员，末尾一个下划线：</p><pre><code>&lt;!-- lang: cpp --&gt;class TableInfo {  ... private:  string table_name_;  // OK - underscore at end.  string tablename_;   // OK.  static Pool&lt;TableInfo&gt;* pool_;  // OK.};</code></pre><p>结构体数据成员，末尾没有下划线：</p><pre><code>&lt;!-- lang: cpp --&gt;struct UrlTableProperties {  string name;  int num_entries;  static Pool&lt;UrlTableProperties&gt;* pool;};</code></pre><p>全局变量，没有一个特定的规则。如果你需要一个规则，考虑给全局变量加上g_前缀，来区分局部变量。</p><h2 id="常量名"><a href="#常量名" class="headerlink" title="常量名"></a>常量名</h2><p>在常量之前加上k，例如：const int kDaysInWeek = 7。</p><h2 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h2><p>和变量命名方式相似，但可以是大小写混合：</p><pre><code>&lt;!-- lang: cpp --&gt;MyExcitingFunction(), MyExcitingMethod(), my_exciting_member_variable(), set_my_exciting_member_variable().</code></pre><p>访问器(get)和修改器(set)应该匹配要访问或修改的那个变量名：</p><pre><code>&lt;!-- lang: cpp --&gt;class MyClass { public:  ...  int num_entries() const { return num_entries_; }  void set_num_entries(int num_entries) { num_entries_ = num_entries; } private:  int num_entries_;};</code></pre><h2 id="命名空间名"><a href="#命名空间名" class="headerlink" title="命名空间名"></a>命名空间名</h2><p>全为小写，并且尽可能是表示目录结构：google_awesome_project.</p><h2 id="枚举名"><a href="#枚举名" class="headerlink" title="枚举名"></a>枚举名</h2><pre><code>&lt;!-- lang: cpp --&gt;enum UrlTableErrors {  kOK = 0,  kErrorOutOfMemory,  kErrorMalformedInput,};enum AlternateUrlTableErrors {  OK = 0,  OUT_OF_MEMORY = 1,  MALFORMED_INPUT = 2,};</code></pre><h2 id="宏名"><a href="#宏名" class="headerlink" title="宏名"></a>宏名</h2><p>通常情况下宏不应该被使用，然而它又绝对是需要的，宏名应该全为大写。</p><pre><code>&lt;!-- lang: cpp --&gt;#define ROUND(x) ...#define PI_ROUNDED 3.0</code></pre><h2 id="命名规则的例外"><a href="#命名规则的例外" class="headerlink" title="命名规则的例外"></a>命名规则的例外</h2><p>如果你在为现存的C/C++代码工作，依据现存的命名方式，例如：</p><pre><code>&lt;!-- lang: cpp --&gt;bigopen()    function name, follows form of open()uint    typedefbigpos    struct or class, follows form of possparse_hash_map    STL-like entity; follows STL naming conventionsLONGLONG_MAX    a constant, as in INT_MAX</code></pre><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>为你的读者写注释，因为下一个读者也许就是你。</p><h2 id="注释风格"><a href="#注释风格" class="headerlink" title="注释风格"></a>注释风格</h2><p>保持//和/**/的一致性，通常//更普遍。</p><h2 id="文件注释"><a href="#文件注释" class="headerlink" title="文件注释"></a>文件注释</h2><p>以许可协议（例如：Apache 2.0, BSD, LGPL, GPL）开头，接下来是关于内容的描述。</p><p>如果你对一个已近存在作者标记的文件进行了修改，请删除作者那一行。</p><p>不要重复在头文件和源文件中书写注释。</p><h2 id="类注释"><a href="#类注释" class="headerlink" title="类注释"></a>类注释</h2><p>每个类定义都应该有一个用于描述它的作用，如何使用的注释：</p><pre><code>&lt;!-- lang: cpp --&gt;// Iterates over the contents of a GargantuanTable.  Sample usage://    GargantuanTableIterator* iter = table-&gt;NewIterator();//    for (iter-&gt;Seek(&quot;foo&quot;); !iter-&gt;done(); iter-&gt;Next()) {//      process(iter-&gt;key(), iter-&gt;value());//    }//    delete iter;class GargantuanTableIterator {  ...};</code></pre><h2 id="函数注释"><a href="#函数注释" class="headerlink" title="函数注释"></a>函数注释</h2><pre><code>&lt;!-- lang: cpp --&gt;// Returns an iterator for this table.  It is the client&apos;s// responsibility to delete the iterator when it is done with it,// and it must not use the iterator once the GargantuanTable object// on which the iterator was created has been deleted.//// The iterator is initially positioned at the beginning of the table.//// This method is equivalent to://    Iterator* iter = table-&gt;NewIterator();//    iter-&gt;Seek(&quot;&quot;);//    return iter;// If you are going to immediately seek to another place in the// returned iterator, it will be faster to use NewIterator()// and avoid the extra seek.Iterator* GetIterator() const;</code></pre><p>去掉不必要的注释：</p><pre><code>&lt;!-- lang: cpp --&gt;// Returns true if the table cannot hold any more entries.bool IsTableFull();</code></pre><h2 id="变量注释"><a href="#变量注释" class="headerlink" title="变量注释"></a>变量注释</h2><p>应该说明这个变量用来干什么，在特定的情况下，需要更多的注释。例如：</p><pre><code>&lt;!-- lang: cpp --&gt;private: // Keeps track of the total number of entries in the table. // Used to ensure we do not go over the limit. -1 means // that we don&apos;t yet know how many entries the table has. int num_total_entries_;</code></pre><p>所有的全局变量都应该给出一个注释，来描述它用来做什么。</p><pre><code>&lt;!-- lang: cpp --&gt;// The total number of tests cases that we run through in this regression test.const int kNumTestCases = 6;</code></pre><h2 id="实现注释"><a href="#实现注释" class="headerlink" title="实现注释"></a>实现注释</h2><p>一些难懂的，复杂的代码块应该被注释：</p><pre><code>&lt;!-- lang: cpp --&gt;// Divide result by two, taking into account that x// contains the carry from the add.for (int i = 0; i &lt; result-&gt;size(); i++) {  x = (x &lt;&lt; 8) + (*result)[i];  (*result)[i] = x &gt;&gt; 1;  x &amp;= 1;}</code></pre><p>意义不明显的行末应该空两个字符并给出注释：</p><pre><code>&lt;!-- lang: cpp --&gt;// If we have enough memory, mmap the data portion too.mmap_budget = max&lt;int64&gt;(0, mmap_budget - index_-&gt;length());if (mmap_budget &gt;= data_size_ &amp;&amp; !MmapData(mmap_chunk_bytes, mlock))  return;  // Error already logged.</code></pre><p>如果接下来的几行都有注释，最好排列起来增强可读性：</p><pre><code>&lt;!-- lang: cpp --&gt;DoSomething();                           // Comment here so the comments line up.DoSomethingElseThatIsLonger();  // Two spaces between the code and the comment.{ // One space before comment when opening a new scope is allowed,  // thus the comment lines up with the following comments and code.  DoSomethingElse();  // Two spaces before line comments normally.}vector&lt;string&gt; list{// Comments in braced lists describe the next element ..                    &quot;First item&quot;,                    // .. and should be aligned appropriately.                    &quot;Second item&quot;};DoSomething(); /* For trailing block comments, one space is fine. */</code></pre><p>当你传递一个空指针，布尔值或者字面整形值时，你应该考虑添加注释来说明他们是什么，或者使你的代码自我注释：</p><pre><code>&lt;!-- lang: cpp --&gt;bool success = CalculateSomething(interesting_value,                                  10,                                  false,                                  NULL);  // What are these arguments??versus:bool success = CalculateSomething(interesting_value,                                  10,     // Default base value.                                  false,  // Not the first time we&apos;re calling this.                                  NULL);  // No callback.Or alternatively, constants or self-describing variables:const int kDefaultBaseValue = 10;const bool kFirstTimeCalling = false;Callback *null_callback = NULL;bool success = CalculateSomething(interesting_value,                                  kDefaultBaseValue,                                  kFirstTimeCalling,                                  null_callback);</code></pre><p>切记不要描述代码自身：</p><pre><code>&lt;!-- lang: cpp --&gt;// Now go through the b array and make sure that if i occurs,// the next element is i+1....        // Geez.  What a useless comment.</code></pre><h2 id="标点，拼写和语法"><a href="#标点，拼写和语法" class="headerlink" title="标点，拼写和语法"></a>标点，拼写和语法</h2><p>完整的句子往往比句子片段更容易理解。</p><h2 id="TODO-注释"><a href="#TODO-注释" class="headerlink" title="TODO 注释"></a>TODO 注释</h2><p>使用TODO注释是一个临时的，短期的解决方案，很好的但不是完美的。</p><p>当你创建一个TODO时，总是给出你的名字：</p><pre><code>&lt;!-- lang: cpp --&gt;// TODO(kl@gmail.com): Use a &quot;*&quot; here for concatenation operator.// TODO(Zeke) change this to use relations.</code></pre><h2 id="弃用注释"><a href="#弃用注释" class="headerlink" title="弃用注释"></a>弃用注释</h2><p>使用DEPRECATED注释标记一个弃用的接口。</p><p>在DEPRECATED之后写出你的名字，email地址或其他能标识你的信息。</p><p>弃用注释必须包含简易的，清楚的指引来帮助使用者修复他们的问题。C++中，你可以将弃用的方法放在内联函数中，然后调用新的接口。</p><h1 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h1><h2 id="行长度"><a href="#行长度" class="headerlink" title="行长度"></a>行长度</h2><p>一行最多80个字符。</p><p>一些原始字符串可能会超出80个字符，除了测试外，这样的字符串应该出现在该文件的顶部。</p><p>#include 语句可能会超过80列。</p><h2 id="非ascii字符"><a href="#非ascii字符" class="headerlink" title="非ascii字符"></a>非ascii字符</h2><p>非ascii字符很少出现，但必须使用UTF-8编码。</p><p>十六进制也可以使用，在那些需要加强可读性的地方更建议使用。</p><p>你不应该使用C++11提供的char116_t和char32_t，因为他们用于非UTF8得文本。同样的，，你也不应该使用wchar_t，除非你是在用Windows API编写程序。</p><h2 id="空格和制表符"><a href="#空格和制表符" class="headerlink" title="空格和制表符"></a>空格和制表符</h2><p>只用空格并且缩进两个字符。</p><h2 id="函数声明和定义"><a href="#函数声明和定义" class="headerlink" title="函数声明和定义"></a>函数声明和定义</h2><p>返回类型出现在函数名的同一行，如果能适应，参数也出现在同一行。如果不能适应，折行书写参数表。</p><pre><code>&lt;!-- lang: cpp --&gt;ReturnType ClassName::FunctionName(Type par_name1, Type par_name2) {  DoSomething();  ...}If you have too much text to fit on one line:ReturnType ClassName::ReallyLongFunctionName(Type par_name1, Type par_name2,                                             Type par_name3) {  DoSomething();  ...}or if you cannot fit even the first parameter:ReturnType LongClassName::ReallyReallyReallyLongFunctionName(    Type par_name1,  // 4 space indent    Type par_name2,    Type par_name3) {  DoSomething();  // 2 space indent  ...}</code></pre><p>需要指出：</p><ul><li>如果不能把返回类型和函数名放在同一行，请折行</li><li>如果折行书写了返回类型，不要缩进</li><li>左圆括号始终和函数名处在同一行</li><li>括号和参数之间没有空格</li><li>左花括号始终和最后一个参数在同一行</li><li>右花括号在最后一行或者和左花括号在同一行</li><li>右小括号和左花括号之间有一个空格</li><li>所有参数都改命名，无论是在头文件，或者源文件中</li><li>如果可能，所有参数都要对齐</li><li>默认缩进2个字符</li><li>折行的参数有4个字符缩进</li></ul><p>如果一些参数未使用，在函数声明处注释出来：</p><pre><code>&lt;!-- lang: cpp --&gt;// Always have named parameters in interfaces.class Shape { public:  virtual void Rotate(double radians) = 0;};// Always have named parameters in the declaration.class Circle : public Shape { public:  virtual void Rotate(double radians);};// Comment out unused named parameters in definitions.void Circle::Rotate(double /*radians*/) {}// Bad - if someone wants to implement later, it&apos;s not clear what the// variable means.void Circle::Rotate(double) {}</code></pre><h2 id="lambda表达式-1"><a href="#lambda表达式-1" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p>像其他函数一样格式化参数和函数体，捕获表如其他逗号分隔的列表。</p><pre><code>&lt;!-- lang: cpp --&gt;int x = 0;auto add_to_x = [&amp;x](int n) { x += n; };</code></pre><p>简短的lambda表达式应该作为函数参数内联：</p><pre><code>&lt;!-- lang: cpp --&gt;std::set&lt;int&gt; blacklist = {7, 8, 9};std::vector&lt;int&gt; digits = {3, 9, 1, 8, 4, 7, 1};digits.erase(std::remove_if(digits.begin(), digits.end(), [&amp;blacklist](int i) {               return blacklist.find(i) != blacklist.end();             }),             digits.end());</code></pre><h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>将函数调用写在一行，用小括号包裹参数；或者将参数置于新行，用4个空格缩进。使用最小的行数。</p><p>如下格式：</p><pre><code>&lt;!-- lang: cpp --&gt;bool retval = DoSomething(argument1, argument2, argument3);</code></pre><p>如果参数太多，折行书写，括号左右不要有空格。</p><pre><code>&lt;!-- lang: cpp --&gt;bool retval = DoSomething(averyveryveryverylongargument1,                                        argument2, argument3);if (...) {  ...  ...  if (...) {    DoSomething(        argument1, argument2,  // 4 space indent        argument3, argument4);  }</code></pre><h2 id="花括号初始化列表格式"><a href="#花括号初始化列表格式" class="headerlink" title="花括号初始化列表格式"></a>花括号初始化列表格式</h2><pre><code>&lt;!-- lang: cpp --&gt;// Examples of braced init list on a single line.return {foo, bar};functioncall({foo, bar});pair&lt;int, int&gt; p{foo, bar};// When you have to wrap.SomeFunction(    {&quot;assume a zero-length name before {&quot;},    some_other_function_parameter);SomeType variable{    some, other, values,    {&quot;assume a zero-length name before {&quot;},    SomeOtherType{        &quot;Very long string requiring the surrounding breaks.&quot;,        some, other values},    SomeOtherType{&quot;Slightly shorter string&quot;,                  some, other, values}};SomeType variable{    &quot;This is too long to fit all in one line&quot;};MyType m = {  // Here, you could also break before {.    superlongvariablename1,    superlongvariablename2,    {short, interior, list},    {interiorwrappinglist,     interiorwrappinglist2}};</code></pre><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p>最好括号内无空格。if和else关键字属于分立的行中。</p><pre><code>&lt;!-- lang: cpp --&gt;if(condition) {   // Bad - space missing after IF.if (condition){   // Bad - space missing before {.if(condition){    // Doubly bad.if (condition) {  // Good - proper space after IF and before {.</code></pre><p>简短的条件块可以写在一行，如果能强化可读性。</p><pre><code>&lt;!-- lang: cpp --&gt;if (x == kFoo) return new Foo();if (x == kBar) return new Bar();</code></pre><p>如果含有else块，则不允许写在一行：</p><pre><code>&lt;!-- lang: cpp --&gt;// Not allowed - IF statement on one line when there is an ELSE clauseif (x) DoThis();else DoThat();</code></pre><p>一般而言，单行条件语句不需要花括号，如果你喜欢也可以加上，特别是在循环中存在复杂的条件时，使用花括号可增加可读性。有些项目还要求if块必须含有完整地括号对。</p><p>然而，if-else一部分使用了花括号，那么所有块都必须使用：</p><pre><code>&lt;!-- lang: cpp --&gt;// Not allowed - curly on IF but not ELSEif (condition) {  foo;} else  bar;// Not allowed - curly on ELSE but not IFif (condition)  foo;else {  bar;}// Curly braces around both IF and ELSE required because// one of the clauses used braces.if (condition) {  foo;} else {  bar;}</code></pre><h2 id="循环和选择语句"><a href="#循环和选择语句" class="headerlink" title="循环和选择语句"></a>循环和选择语句</h2><p>switch块必须包含default，如果default永不会被执行，则写一个assert：</p><pre><code>&lt;!-- lang: cpp --&gt;switch (var) {  case 0: {  // 2 space indent    ...      // 4 space indent    break;  }  case 1: {    ...    break;  }  default: {    assert(false);  }}</code></pre><p>空的case块用花括号括起来。</p><p>单语句循环，花括号可以省略，空循环用花括号括起来或者写continue，而不仅仅是分号。</p><pre><code>&lt;!-- lang: cpp --&gt;while (condition) {  // Repeat test until it returns false.}for (int i = 0; i &lt; kSomeNumber; ++i) {}  // Good - empty body.while (condition) continue;  // Good - continue indicates no logic.while (condition);  // Bad - looks like part of do/while loop.</code></pre><h2 id="指针和引用表达式"><a href="#指针和引用表达式" class="headerlink" title="指针和引用表达式"></a>指针和引用表达式</h2><p>句号和箭头周围无空格：</p><pre><code>&lt;!-- lang: cpp --&gt;x = *p;p = &amp;x;x = r.y;x = r-&gt;y;</code></pre><p>当声明一个指针类型变量时，保证星号两侧仅有一个空格：</p><pre><code>&lt;!-- lang: cpp --&gt;// These are fine, space preceding.char *c;const string &amp;str;// These are fine, space following.char* c;    // but remember to do &quot;char* c, *d, *e, ...;&quot;!const string&amp; str;char * c;  // Bad - spaces on both sides of *const string &amp; str;  // Bad - spaces on both sides of &amp;</code></pre><h2 id="布尔表达式"><a href="#布尔表达式" class="headerlink" title="布尔表达式"></a>布尔表达式</h2><p>当一个布尔表达式超过标准行长度(80)时，保证折行书写的一致性。</p><pre><code>&lt;!-- lang: cpp --&gt;if (this_one_thing &gt; this_other_thing &amp;&amp;    a_third_thing == a_fourth_thing &amp;&amp;    yet_another &amp;&amp; last_one) {  ...}</code></pre><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>不要给return语句加上括号。仅在返回一个逻辑表达式的时候加括号。</p><pre><code>&lt;!-- lang: cpp --&gt;return result;                  // No parentheses in the simple case.// Parentheses OK to make a complex expression more readable.return (some_long_condition &amp;&amp;        another_condition);return (value);                // You wouldn&apos;t write var = (value);return(result);                // return is not a function!</code></pre><h2 id="变量和数组初始化"><a href="#变量和数组初始化" class="headerlink" title="变量和数组初始化"></a>变量和数组初始化</h2><p>可以选择=，()或者{}。下面都是正确的：</p><pre><code>&lt;!-- lang: cpp --&gt;int x = 3;int x(3);int x{3};string name = &quot;Some Name&quot;;string name(&quot;Some Name&quot;);string name{&quot;Some Name&quot;};</code></pre><p>当心{}会调用std::initializer_list 构造函数。为了避免这个问题，使用()：</p><pre><code>&lt;!-- lang: cpp --&gt;vector&lt;int&gt; v(100, 1);  // A vector of 100 1s.vector&lt;int&gt; v{100, 1};  // A vector of 100, 1.</code></pre><h2 id="预处理指令"><a href="#预处理指令" class="headerlink" title="预处理指令"></a>预处理指令</h2><p>总是在一行的开头书写，无论是不是在代码块内：</p><pre><code>&lt;!-- lang: cpp --&gt;// Good - directives at beginning of line  if (lopsided_score) {#if DISASTER_PENDING      // Correct -- Starts at beginning of line    DropEverything();# if NOTIFY               // OK but not required -- Spaces after #    NotifyClient();# endif#endif    BackToNormal();  }// Bad - indented directives  if (lopsided_score) {    #if DISASTER_PENDING  // Wrong!  The &quot;#if&quot; should be at beginning of line    DropEverything();    #endif                // Wrong!  Do not indent &quot;#endif&quot;    BackToNormal();  }</code></pre><h2 id="类格式化"><a href="#类格式化" class="headerlink" title="类格式化"></a>类格式化</h2><p>public,protected,private前面有一个空格：</p><pre><code>&lt;!-- lang: cpp --&gt;class MyClass : public OtherClass { public:      // Note the 1 space indent!  MyClass();  // Regular 2 space indent.  explicit MyClass(int var);  ~MyClass() {}  void SomeFunction();  void SomeFunctionThatDoesNothing() {  }  void set_some_var(int var) { some_var_ = var; }  int some_var() const { return some_var_; } private:  bool SomeInternalFunction();  int some_var_;  int some_other_var_;};</code></pre><p>注意：</p><ul><li>基类名和子类名放在一行</li><li>除了第一个public，其他关键字前需要空一行，这个规则在小型类中可选。</li><li>这些关键字下面不要有空行</li></ul><h2 id="构造函数初始化列表"><a href="#构造函数初始化列表" class="headerlink" title="构造函数初始化列表"></a>构造函数初始化列表</h2><p>初始化列表可以在一行内，也可以折行，前面缩进4个字符：</p><pre><code>&lt;!-- lang: cpp --&gt;// When it all fits on one line:MyClass::MyClass(int var) : some_var_(var), some_other_var_(var + 1) {}or// When it requires multiple lines, indent 4 spaces, putting the colon on// the first initializer line:MyClass::MyClass(int var)    : some_var_(var),             // 4 space indent      some_other_var_(var + 1) {  // lined up  ...  DoSomething();  ...}</code></pre><h2 id="命名空间格式"><a href="#命名空间格式" class="headerlink" title="命名空间格式"></a>命名空间格式</h2><p>命名空间内的内容不缩进。</p><pre><code>&lt;!-- lang: cpp --&gt;namespace {void foo() {  // Correct.  No extra indentation within namespace.  ...}}  // namespaceDo not indent within a namespace:namespace {  // Wrong.  Indented when it should not be.  void foo() {    ...  }}  // namespace</code></pre><h2 id="水平空格"><a href="#水平空格" class="headerlink" title="水平空格"></a>水平空格</h2><p>水平空格依赖于位置，不要行末添加空格。</p><pre><code>&lt;!-- lang: cpp --&gt;void f(bool b) {  // Open braces should always have a space before them.  ...int i = 0;  // Semicolons usually have no space before them.// Spaces inside braces for braced-init-list are optional.  If you use them,// put them on both sides!int x[] = { 0 };int x[] = {0};// Spaces around the colon in inheritance and initializer lists.class Foo : public Bar { public:  // For inline function implementations, put spaces between the braces  // and the implementation itself.  Foo(int b) : Bar(), baz_(b) {}  // No spaces inside empty braces.  void Reset() { baz_ = 0; }  // Spaces separating braces from implementation.  ...</code></pre><p>循环和条件，</p><pre><code>&lt;!-- lang: cpp --&gt;if (b) {          // Space after the keyword in conditions and loops.} else {          // Spaces around else.}while (test) {}   // There is usually no space inside parentheses.switch (i) {for (int i = 0; i &lt; 5; ++i) {// Loops and conditions may have spaces inside parentheses, but this// is rare.  Be consistent.switch ( i ) {if ( test ) {for ( int i = 0; i &lt; 5; ++i ) {// For loops always have a space after the semicolon.  They may have a space// before the semicolon, but this is rare.for ( ; i &lt; 5 ; ++i) {  ...// Range-based for loops always have a space before and after the colon.for (auto x : counts) {  ...}switch (i) {  case 1:         // No space before colon in a switch case.    ...  case 2: break;  // Use a space after a colon if there&apos;s code after it.</code></pre><p>操作符，</p><pre><code>&lt;!-- lang: cpp --&gt;// Assignment operators always have spaces around them.x = 0;// Other binary operators usually have spaces around them, but it&apos;s// OK to remove spaces around factors.  Parentheses should have no// internal padding.v = w * x + y / z;v = w*x + y/z;v = w * (x + z);// No spaces separating unary operators and their arguments.x = -5;++x;if (x &amp;&amp; !y)  ...</code></pre><p>模板和类型转换，</p><pre><code>&lt;!-- lang: cpp --&gt;// No spaces inside the angle brackets (&lt; and &gt;), before// &lt;, or between &gt;( in a castvector&lt;string&gt; x;y = static_cast&lt;char*&gt;(x);// Spaces between type and pointer are OK, but be consistent.vector&lt;char *&gt; x;set&lt;list&lt;string&gt;&gt; x;        // Permitted in C++11 code.set&lt;list&lt;string&gt; &gt; x;       // C++03 required a space in &gt; &gt;.// You may optionally use symmetric spacing in &lt; &lt;.set&lt; list&lt;string&gt; &gt; x;</code></pre><h2 id="纵向空格"><a href="#纵向空格" class="headerlink" title="纵向空格"></a>纵向空格</h2><p>使纵向空格最小化。</p><p>当你没必要时，不要留很多空行。特别的，在函数间不要留超过一行或两行的空白。</p><p>函数开始不要有空行，函数结束也不要有空行。</p><p>基本原则：一个屏幕上有越多的代码，就越容易理解程序的控制流程。当然，可读性也很重要。</p><h1 id="以上规则的例外情况"><a href="#以上规则的例外情况" class="headerlink" title="以上规则的例外情况"></a>以上规则的例外情况</h1><h2 id="现存的不一致代码"><a href="#现存的不一致代码" class="headerlink" title="现存的不一致代码"></a>现存的不一致代码</h2><p>你可能会在不符合本规则的代码上工作，为了保持一致性，你不应该生搬硬套这个规则。</p><h2 id="Windows代码"><a href="#Windows代码" class="headerlink" title="Windows代码"></a>Windows代码</h2><ul><li>不要使用匈牙利命名法，例如 iNum。使用上面介绍的命名规则。</li><li>Windows定义了许多自己的类型，如DWORD，HANDLE等等。即便这样，你也应该使用你熟知的C++类型，例如：const TCHAR * 来代替LPCTSTR。</li><li>当使用Microsoft Visual C++编译时，将编译器设置3或以上的警告等级，并把所有警告视为错误。</li><li>不要使用#pragma once。使用第一个介绍的头文件保护策略。</li><li>实际上，不要使用任何非标准的扩展指令，像#pragma和<strong>declspec，除非你必须使用。允许使用</strong>declspec(dllimport) 和 __declspec(dllexport)。当然，你必须通过DLLIMPORT和DLLEXPORT宏来间接使用它们。</li></ul><p>上面的一些规则在Windows上不适用：</p><ul><li>禁止多重实现继承。在使用COM和一些ATL/WTL类时，多重继承是必要的。</li><li>不使用exception。在ATL和一些Visual C++的STL中使用了exception。使用ATL时，你应该定义_ATL_NO_EXCEPTIONS来禁用异常。</li><li>使用预编译头文件的一贯方法是包含StdAfx.h或者precompile.h。你应该避免手动包含预编译头文件，使用/FI编译器选项来自动包含这个文件。</li><li>资源头文件resource.h，仅包含宏，不需要套用本规则。</li></ul><h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><p>符合常识以及保持一致性。</p><p>在编辑代码之前，花几分钟看看当前代码的编码风格。并与之保持一致的风格。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;英文原版: &lt;a href=&quot;http://google-styleguide.googlecode.com/svn/trunk/cppguide.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://google-styleguide.g
      
    
    </summary>
    
    
      <category term="tech" scheme="https://apporz.com/tags/tech/"/>
    
      <category term="cpp" scheme="https://apporz.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>CMake官方Tutorial中英对照翻译</title>
    <link href="https://apporz.com/2015/01/08/cmake-tutorial-translation/"/>
    <id>https://apporz.com/2015/01/08/cmake-tutorial-translation/</id>
    <published>2015-01-07T16:00:00.000Z</published>
    <updated>2017-12-08T13:17:42.200Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CMake-Tutorial"><a href="#CMake-Tutorial" class="headerlink" title="CMake Tutorial"></a>CMake Tutorial</h1><p>原版英文Tutorial：</p><p><a href="http://www.cmake.org/cmake-tutorial/" target="_blank" rel="noopener">http://www.cmake.org/cmake-tutorial/</a></p><p>Step1-Step7的源代码及CMakeLists：</p><p><a href="http://public.kitware.com/cgi-bin/viewcvs.cgi/CMake/Tests/Tutorial/" target="_blank" rel="noopener">http://public.kitware.com/cgi-bin/viewcvs.cgi/CMake/Tests/Tutorial/</a></p><blockquote><p>Below is a step-by-step tutorial covering common build system issues<br>that CMake helps to address. Many of these topics have been introduced<br>in Mastering CMake as separate issues but seeing how they all work<br>together in an example project can be very helpful. This tutorial can<br>be found in the Tests/Tutorial directory of the CMake source code<br>tree. Each step has its own subdirectory containing a complete copy of<br>the tutorial for that step</p></blockquote><p>下面是涵盖CMake解决常见构建系统问题的一个手把手教程。通过单独的例子，阐述了CMake是如何协同工作的，这将会对你十分有帮助。这个教程可以在CMake源代码树的<code>Test/Tutorial</code>目录下找到。每个步骤有各自的子目录，且包含了一份关于这个步骤的完整教程。</p><h1 id="A-Basic-Starting-Point-Step1-简单的开始"><a href="#A-Basic-Starting-Point-Step1-简单的开始" class="headerlink" title="A Basic Starting Point (Step1)  简单的开始"></a>A Basic Starting Point (Step1)  简单的开始</h1><blockquote><p>The most basic project is an executable built from source code files.<br>For simple projects a two line CMakeLists file is all that is<br>required. This will be the starting point for our tutorial. The<br>CMakeLists file looks like:</p></blockquote><p>最基本的工程是从源代码文件构建出可执行程序。对于简单的工程而言，一个两行的<code>CMakeLists</code>文件已经足够了。这将会是我们教程开始的第一步。<code>CMakeLists</code>文件看起来像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">cmake_minimum_required (VERSION 2.6)</span><br><span class="line"></span><br><span class="line">project (Tutorial)</span><br><span class="line"></span><br><span class="line">add_executable(Tutorial tutorial.cxx)</span><br></pre></td></tr></table></figure><blockquote><p>Note that this example uses lower case commands in the CMakeLists<br>file. Upper, lower, and mixed case commands are supported by CMake.<br>The source code for tutorial.cxx will compute the square root of a<br>number and the first version of it is very simple, as follows:</p></blockquote><p>注意到这个例子在<code>CMakeLists</code>中用的是小写命令。无论是大写、小写、还是混合大小写，CMake都支持。<br>源代码文件<code>tutorial.cxx</code>将计算一个数的平方根，第一个版本十分简单：</p><pre><code>&lt;!-- lang: cpp --&gt;// A simple program that computes the square root of a number#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;int main (int argc, char *argv[]){  if (argc &lt; 2)    {    fprintf(stdout,&quot;Usage: %s number\n&quot;,argv[0]);    return 1;    }  double inputValue = atof(argv[1]);  double outputValue = sqrt(inputValue);  fprintf(stdout,&quot;The square root of %g is %g\n&quot;,          inputValue, outputValue);  return 0;}</code></pre><h2 id="Adding-a-Version-Number-and-Configured-Header-File-添加一个版本号和用于配置的头文件"><a href="#Adding-a-Version-Number-and-Configured-Header-File-添加一个版本号和用于配置的头文件" class="headerlink" title="Adding a Version Number and Configured Header File 添加一个版本号和用于配置的头文件"></a>Adding a Version Number and Configured Header File 添加一个版本号和用于配置的头文件</h2><blockquote><p>The first feature we will add is to provide our executable and project<br>with a version number. While you can do this exclusively in the source<br>code, doing it in the CMakeLists file provides more flexibility. To<br>add a version number we modify the CMakeLists file as follows:</p></blockquote><p>我们将为可执行程序和工程提供一个版本号作为第一个特性。当然你可以在源代码中专门这样做，但是使用<code>CMakeLists</code>文件将更加灵活。为了添加一个版本号，我们修改<code>CMakeLists</code>文件如下：</p><pre><code>&lt;!-- lang: shell --&gt;cmake_minimum_required (VERSION 2.6)project (Tutorial)# The version number.set (Tutorial_VERSION_MAJOR 1)set (Tutorial_VERSION_MINOR 0)# configure a header file to pass some of the CMake settings# to the source codeconfigure_file (  &quot;${PROJECT_SOURCE_DIR}/TutorialConfig.h.in&quot;  &quot;${PROJECT_BINARY_DIR}/TutorialConfig.h&quot;  )# add the binary tree to the search path for include files# so that we will find TutorialConfig.hinclude_directories(&quot;${PROJECT_BINARY_DIR}&quot;)# add the executableadd_executable(Tutorial tutorial.cxx)</code></pre><blockquote><p>Since the configured file will be written into the binary tree we must<br>add that directory to the list of paths to search for include files.<br>We then create a TutorialConfig.h.in file in the source tree with the<br>following contents:</p></blockquote><p>由于配置文件将被写入二进制树，我们必须要在路径列表中添加目录以搜索包含文件。<br>然后我们在源代码树中添加<code>TutorialConfig.h.in</code>文件：</p><pre><code>&lt;!-- lang: cpp --&gt;// the configured options and settings for Tutorial#define Tutorial_VERSION_MAJOR @Tutorial_VERSION_MAJOR@#define Tutorial_VERSION_MINOR @Tutorial_VERSION_MINOR@</code></pre><blockquote><p>When CMake configures this header file the values for<br>@Tutorial_VERSION_MAJOR@ and @Tutorial_VERSION_MINOR@ will be replaced<br>by the values from the CMakeLists file. Next we modify tutorial.cxx to<br>include the configured header file and to make use of the version<br>numbers. The resulting source code is listed below.</p></blockquote><p>CMake在配置过程中，将从<code>CMakeLists</code>文件中找到并替换头文件中的<code>@Tutorial_VERSION_MAJOR@</code>和<code>@Tutorial_VERSION_MINOR@</code>。之后我们修改<code>tutorial.cxx</code>，使它包含配置头文件，然后利用版本号。最终的源代码如下：</p><pre><code>&lt;!-- lang: cpp --&gt;// A simple program that computes the square root of a number#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;#include &quot;TutorialConfig.h&quot;int main (int argc, char *argv[]){  if (argc &lt; 2)    {    fprintf(stdout,&quot;%s Version %d.%d\n&quot;,            argv[0],            Tutorial_VERSION_MAJOR,            Tutorial_VERSION_MINOR);    fprintf(stdout,&quot;Usage: %s number\n&quot;,argv[0]);    return 1;    }  double inputValue = atof(argv[1]);  double outputValue = sqrt(inputValue);  fprintf(stdout,&quot;The square root of %g is %g\n&quot;,          inputValue, outputValue);  return 0;}</code></pre><blockquote><p>The main changes are the inclusion of the TutorialConfig.h header file<br>and printing out a version number as part of the usage message.</p></blockquote><p>主要的改变是添加了<code>TutorialConfig.h</code>头文件以及在使用帮助中打印出了版本号。</p><h1 id="Adding-a-Library-Step-2-添加一个库"><a href="#Adding-a-Library-Step-2-添加一个库" class="headerlink" title="Adding a Library (Step 2) 添加一个库"></a>Adding a Library (Step 2) 添加一个库</h1><blockquote><p>Now we will add a library to our project. This library will contain<br>our own implementation for computing the square root of a number. The<br>executable can then use this library instead of the standard square<br>root function provided by the compiler. For this tutorial we will put<br>the library into a subdirectory called MathFunctions. It will have the<br>following one line CMakeLists file:</p></blockquote><p>现在我们将为工程添加一个库。这个库将包含计算一个数的平方根的实现代码。可执行程序可以使用这个库，来替代编译器提供的标准平方根函数。在这个教程中，我们将把库放进一个叫做<code>MathFunctions</code>的子目录中。<code>CMakeLists</code>文件将包含这样一行：</p><pre><code>&lt;!-- lang: shell --&gt;add_library(MathFunctions mysqrt.cxx)</code></pre><blockquote><p>The source file mysqrt.cxx has one function called mysqrt that<br>provides similar functionality to the compiler’s sqrt function. To<br>make use of the new library we add an add_subdirectory call in the top<br>level CMakeLists file so that the library will get built. We also add<br>another include directory so that the MathFunctions/mysqrt.h header<br>file can be found for the function prototype. The last change is to<br>add the new library to the executable. The last few lines of the top<br>level CMakeLists file now look like:</p></blockquote><p>源代码文件<code>mysqrt.cxx</code>有一个叫做<code>mysqrt</code>的函数，提供了一个类似于编译器<code>sqrt</code>函数的功能。为了能利用这个新库，我们在<code>CMakeLists</code>文件的顶部添加一个<code>add_subdirectory</code>调用来使之能够被构建。同时，我们也添加一个包含目录使<code>MathFunctions/mysqrt.h</code>头文件提供函数原型。最后一个改变是给可执行程序添加新库。<code>CMakeLists</code>文件的最后几行看起来像这样：</p><pre><code>&lt;!-- lang: shell --&gt;include_directories (&quot;${PROJECT_SOURCE_DIR}/MathFunctions&quot;)add_subdirectory (MathFunctions) # add the executableadd_executable (Tutorial tutorial.cxx)target_link_libraries (Tutorial MathFunctions)</code></pre><blockquote><p>Now let us consider making the MathFunctions library optional. In this<br>tutorial there really isn’t any reason to do so, but with larger<br>libraries or libraries that rely on third party code you might want<br>to. The first step is to add an option to the top level CMakeLists<br>file.</p></blockquote><p>现在让我们考虑使<code>MathFunctions</code>库可选。这个教程中确实没有任何理由这样做，但是对于更大的库或依赖于第三方代码的库来说，你可能更愿意这样做。第一步是在<code>CMakeLists</code>中添加一个选项：</p><pre><code>&lt;!-- lang: shell --&gt;# should we use our own math functions?option (USE_MYMATH         &quot;Use tutorial provided math implementation&quot; ON) </code></pre><blockquote><p>This will show up in the CMake GUI with a default value of ON that the<br>user can change as desired. This setting will be stored in the cache<br>so that the user does not need to keep setting it each time they run<br>CMake on this project. The next change is to make the build and<br>linking of the MathFunctions library conditional. To do this we change<br>the end of the top level CMakeLists file to look like the following:</p></blockquote><p>这将在<code>CMake GUI</code>中默认显示为ON，这样使用者可以根据需要来改变它。这个配置将被保存在缓存中，这样使用者不必在工程中使用CMake时每次都去配置它。下一个改变是使构建和链接<code>MathFunctions</code>库有条件化。为了达到目的我们改变<code>CMakeLists</code>文件如下：</p><pre><code>&lt;!-- lang: shell --&gt;# add the MathFunctions library?#if (USE_MYMATH)  include_directories (&quot;${PROJECT_SOURCE_DIR}/MathFunctions&quot;)  add_subdirectory (MathFunctions)  set (EXTRA_LIBS ${EXTRA_LIBS} MathFunctions)endif (USE_MYMATH)# add the executableadd_executable (Tutorial tutorial.cxx)target_link_libraries (Tutorial  ${EXTRA_LIBS})</code></pre><blockquote><p>This uses the setting of USE_MYMATH to determine if the MathFunctions<br>should be compiled and used. Note the use of a variable (EXTRA_LIBS in<br>this case) to collect up any optional libraries to later be linked<br>into the executable. This is a common approach used to keep larger<br>projects with many optional components clean. The corresponding<br>changes to the source code are fairly straight forward and leave us<br>with:</p></blockquote><p>它使用了<code>USE_MYMATH</code>设置来决定<code>MathFunctions</code>是否应该被编译和使用。注意变量<code>EXTRA_LIBS</code>（本例中）用来收集接下来将被链接到可执行程序中的可选库。这是一个保持大型工程和许多可选组件干净的常用方法。在源代码中的相应改变非常简单：</p><pre><code>&lt;!-- lang: cpp --&gt;// A simple program that computes the square root of a number#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;#include &quot;TutorialConfig.h&quot;#ifdef USE_MYMATH#include &quot;MathFunctions.h&quot;#endifint main (int argc, char *argv[]){  if (argc &lt; 2)    {    fprintf(stdout,&quot;%s Version %d.%d\n&quot;, argv[0],            Tutorial_VERSION_MAJOR,            Tutorial_VERSION_MINOR);    fprintf(stdout,&quot;Usage: %s number\n&quot;,argv[0]);    return 1;    }  double inputValue = atof(argv[1]);#ifdef USE_MYMATH  double outputValue = mysqrt(inputValue);#else  double outputValue = sqrt(inputValue);#endif  fprintf(stdout,&quot;The square root of %g is %g\n&quot;,          inputValue, outputValue);  return 0;}</code></pre><blockquote><p>In the source code we make use of USE_MYMATH as well. This is provided<br>from CMake to the source code through the TutorialConfig.h.in<br>configured file by adding the following line to it:</p></blockquote><p>在源代码中我们利用了<code>USE_MYMATH</code>。它是由<code>TutorialConfig.h.in</code>文件通过CMake提供的：</p><pre><code>&lt;!-- lang: cpp --&gt;#cmakedefine USE_MYMATH</code></pre><h1 id="Installing-and-Testing-Step-3-安装和测试"><a href="#Installing-and-Testing-Step-3-安装和测试" class="headerlink" title="Installing and Testing (Step 3) 安装和测试"></a>Installing and Testing (Step 3) 安装和测试</h1><blockquote><p>For the next step we will add install rules and testing support to our<br>project. The install rules are fairly straight forward. For the<br>MathFunctions library we setup the library and the header file to be<br>installed by adding the following two lines to MathFunctions’<br>CMakeLists file:</p></blockquote><p>下一步我们将给工程添加安装规则和测试支持。安装规则相当简单。</p><p>对于<code>MathFunctions</code>库，我们通过在<code>MathFunction</code>的<code>CMakeLists</code>文件中添加下面两行，来使它的库和头文件可以被安装：</p><pre><code>&lt;!-- lang: shell --&gt;install (TARGETS MathFunctions DESTINATION bin)install (FILES MathFunctions.h DESTINATION include)</code></pre><blockquote><p>For the application the following lines are added to the top level<br>CMakeLists file to install the executable and the configured header<br>file:</p></blockquote><p>对于应用程序，在<code>CMakeLists</code>中添加下面的命令来安装可执行程序和配置文件：</p><pre><code>&lt;!-- lang: shell --&gt;# add the install targetsinstall (TARGETS Tutorial DESTINATION bin)install (FILES &quot;${PROJECT_BINARY_DIR}/TutorialConfig.h&quot;                 DESTINATION include)</code></pre><blockquote><p>That is all there is to it. At this point you should be able to build<br>the tutorial, then type make install (or build the INSTALL target from<br>an IDE) and it will install the appropriate header files, libraries,<br>and executables. The CMake variable CMAKE_INSTALL_PREFIX is used to<br>determine the root of where the files will be installed. Adding<br>testing is also a fairly straight forward process. At the end of the<br>top level CMakeLists file we can add a number of basic tests to verify<br>that the application is working correctly.</p></blockquote><p>就是这么一回事，现在你能够构建这个教程了，然后执行<code>make install</code>（或者通过IDE构建INSTALL目标），它将安装适当的头文件，库和可执行程序。CMake变量<code>CMAKE_INSTALL_PREFIX</code>用来决定所安装文件的根目录。</p><p>添加测试也非常简单。在顶级<code>CMakeLists</code>文件的最后，我们可以添加一系列基础测试来验证应用程序是否运行正常。</p><pre><code>&lt;!-- lang: shell --&gt;# does the application runadd_test (TutorialRuns Tutorial 25)# does it sqrt of 25add_test (TutorialComp25 Tutorial 25)set_tests_properties (TutorialComp25   PROPERTIES PASS_REGULAR_EXPRESSION &quot;25 is 5&quot;)# does it handle negative numbersadd_test (TutorialNegative Tutorial -25)set_tests_properties (TutorialNegative  PROPERTIES PASS_REGULAR_EXPRESSION &quot;-25 is 0&quot;)# does it handle small numbersadd_test (TutorialSmall Tutorial 0.0001)set_tests_properties (TutorialSmall  PROPERTIES PASS_REGULAR_EXPRESSION &quot;0.0001 is 0.01&quot;)# does the usage message work?add_test (TutorialUsage Tutorial)set_tests_properties (TutorialUsage  PROPERTIES   PASS_REGULAR_EXPRESSION &quot;Usage:.*number&quot;)</code></pre><blockquote><p>The first test simply verifies that the application runs, does not<br>segfault or otherwise crash, and has a zero return value. This is the<br>basic form of a CTest test. The next few tests all make use of the<br>PASS_REGULAR_EXPRESSION test property to verify that the output of the<br>test contains certain strings. In this case verifying that the<br>computed square root is what it should be and that the usage message<br>is printed when an incorrect number of arguments are provided. If you<br>wanted to add a lot of tests to test different input values you might<br>consider creating a macro like the following:</p></blockquote><p>第一个测试例子验证了程序运行，是否出现段错误或者崩溃，是否返回0值。这是一个<code>CTest</code>的基本测试。接下来的几个测试都利用了<code>PASS_REGULAR_EXPRESSION</code>来验证输出是否包含指定的字符串。在这种情况下，验证计算平方根是必要的，当提供了一个错误的参数时就打印用法信息。如果你想添加测试多个不同的输入值，可以考虑写一个像下面这样的宏：</p><pre><code>&lt;!-- lang: shell --&gt;#define a macro to simplify adding tests, then use itmacro (do_test arg result)  add_test (TutorialComp${arg} Tutorial ${arg})  set_tests_properties (TutorialComp${arg}    PROPERTIES PASS_REGULAR_EXPRESSION ${result})endmacro (do_test)# do a bunch of result based testsdo_test (25 &quot;25 is 5&quot;)do_test (-25 &quot;-25 is 0&quot;)</code></pre><blockquote><p>For each invocation of do_test, another test is added to the project<br>with a name, input, and results based on the passed arguments.</p></blockquote><p>对于每个<code>do_test</code>调用，都会根据传入其中的参数，在工程中添加名称、输入和结果。</p><h1 id="Adding-System-Introspection-Step-4-添加系统反馈"><a href="#Adding-System-Introspection-Step-4-添加系统反馈" class="headerlink" title="Adding System Introspection (Step 4) 添加系统反馈"></a>Adding System Introspection (Step 4) 添加系统反馈</h1><blockquote><p>Next let us consider adding some code to our project that depends on<br>features the target platform may not have. For this example we will<br>add some code that depends on whether or not the target platform has<br>the log and exp functions. Of course almost every platform has these<br>functions but for this tutorial assume that they are less common. If<br>the platform has log then we will use that to compute the square root<br>in the mysqrt function. We first test for the availability of these<br>functions using the CheckFunctionExists.cmake macro in the top level<br>CMakeLists file as follows:</p></blockquote><p>接下来让我们考虑在工程中添加一些代码，依赖目标平台上可能没有的特性。在这个例子中，我们将添加一些依赖于目标平台是否存在<code>log</code>和<code>exp</code>函数的代码。当然几乎所有的平台都有这些函数，但这个教程假设它们（这些函数）不常见。如果平台存在<code>log</code>，我们就在<code>mysqrt</code>中使用它来计算平方根。我们首先在顶级<code>CMakeLists</code>中使用<code>CheckFunctionExists.cmake</code>宏来测试这些函数的可用性：</p><pre><code>&lt;!-- lang: shell --&gt;# does this system provide the log and exp functions?include (CheckFunctionExists.cmake)check_function_exists (log HAVE_LOG)check_function_exists (exp HAVE_EXP)</code></pre><blockquote><p>Next we modify the TutorialConfig.h.in to define those values if CMake<br>found them on the platform as follows:</p></blockquote><p>接下来我们修改<code>TutorialConfig.h.in</code>，如果CMake在平台上找到他们（函数），就定义这些值：</p><pre><code>&lt;!-- lang: shell --&gt;// does the platform provide exp and log functions?#cmakedefine HAVE_LOG#cmakedefine HAVE_EXP</code></pre><blockquote><p>It is important that the tests for log and exp are done before the<br>configure_file command for TutorialConfig.h. The configure_file<br>command immediately configures the file using the current settings in<br>CMake. Finally in the mysqrt function we can provide an alternate<br>implementation based on log and exp if they are available on the<br>system using the following code:</p></blockquote><p>在为<code>TutorialConfig.h</code>执行<code>configure_file</code>命令之前完成对<code>log</code>和<code>exp</code>的测试非常重要。<code>configure_file</code>命令会使用CMake的当前设置立即配置这个文件。最后我们可以在<code>mysqrt</code>函数中提供基于<code>log</code>和<code>exp</code>的可选实现（如果他们在当前系统上可用）：</p><pre><code>&lt;!-- lang: cpp --&gt;// if we have both log and exp then use them#if defined (HAVE_LOG) &amp;&amp; defined (HAVE_EXP)  result = exp(log(x)*0.5);#else // otherwise use an iterative approach  . . .</code></pre><h1 id="Adding-a-Generated-File-and-Generator-Step-5-添加生成的文件和生成器"><a href="#Adding-a-Generated-File-and-Generator-Step-5-添加生成的文件和生成器" class="headerlink" title="Adding a Generated File and Generator (Step 5) 添加生成的文件和生成器"></a>Adding a Generated File and Generator (Step 5) 添加生成的文件和生成器</h1><blockquote><p>In this section we will show how you can add a generated source file<br>into the build process of an application. For this example we will<br>create a table of precomputed square roots as part of the build<br>process, and then compile that table into our application. To<br>accomplish this we first need a program that will generate the table.<br>In the MathFunctions subdirectory a new source file named<br>MakeTable.cxx will do just that.</p></blockquote><p>在这个单元中我们将为你展示如何在应用程序的构建过程中添加生成好的源文件。这个例子中我们将为构建过程造一个预计算平方根的表，然后将这个表编译进我们的应用程序。为了完成这个，我们首先需要一个可以生成这个表的程序。<code>MathFunctions</code>子目录下的<code>MakeTable.cxx</code>新源文件将完成这个工作：</p><pre><code>&lt;!-- lang: cpp --&gt;// A simple program that builds a sqrt table #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;int main (int argc, char *argv[]){  int i;  double result;  // make sure we have enough arguments  if (argc &lt; 2)    {    return 1;    }  // open the output file  FILE *fout = fopen(argv[1],&quot;w&quot;);  if (!fout)    {    return 1;    }  // create a source file with a table of square roots  fprintf(fout,&quot;double sqrtTable[] = {\n&quot;);  for (i = 0; i &lt; 10; ++i)    {    result = sqrt(static_cast&lt;double&gt;(i));    fprintf(fout,&quot;%g,\n&quot;,result);    }  // close the table with a zero  fprintf(fout,&quot;0};\n&quot;);  fclose(fout);  return 0;}</code></pre><blockquote><p>Note that the table is produced as valid C++ code and that the name of<br>the file to write the output to is passed in as an argument. The next<br>step is to add the appropriate commands to MathFunctions’ CMakeLists<br>file to build the MakeTable executable, and then run it as part of the<br>build process. A few commands are needed to accomplish this, as shown<br>below.</p></blockquote><p>注意这个表格由C++代码产生，文件名作为参数传入以在里面输出结果。下一步是给<code>MathFunctions</code>的<code>CMakeLists</code>添加适当的命令来构建<code>MakeTable</code>程序。之后将作为构建过程的一部分来运行。需要很少的命令来完成这件事：</p><pre><code>&lt;!-- lang: shell --&gt;# first we add the executable that generates the tableadd_executable(MakeTable MakeTable.cxx)# add the command to generate the source codeadd_custom_command (  OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/Table.h  COMMAND MakeTable ${CMAKE_CURRENT_BINARY_DIR}/Table.h  DEPENDS MakeTable  )# add the binary tree directory to the search path for # include filesinclude_directories( ${CMAKE_CURRENT_BINARY_DIR} )# add the main libraryadd_library(MathFunctions mysqrt.cxx ${CMAKE_CURRENT_BINARY_DIR}/Table.h  )</code></pre><blockquote><p>First the executable for MakeTable is added as any other executable<br>would be added. Then we add a custom command that specifies how to<br>produce Table.h by running MakeTable. Next we have to let CMake know<br>that mysqrt.cxx depends on the generated file Table.h. This is done by<br>adding the generated Table.h to the list of sources for the library<br>MathFunctions. We also have to add the current binary directory to the<br>list of include directories so that Table.h can be found and included<br>by mysqrt.cxx. When this project is built it will first build the<br>MakeTable executable. It will then run MakeTable to produce Table.h.<br>Finally, it will compile mysqrt.cxx which includes Table.h to produce<br>the MathFunctions library. At this point the top level CMakeLists file<br>with all the features we have added looks like the following:</p></blockquote><p>首先，<code>MakeTable</code>像其他任何一个可执行程序一样被添加进入。然后，我们添加一个定制的命令来指定如何运行<code>MakeTable</code>来产生<code>Table.h</code>。之后，我们必须让CMake知道<code>mysqrt.cxx</code>依赖生成的<code>Table.h</code>文件。将生成的<code>Table.h</code>添加到<code>MathFunctions</code>源代码列表中来搞定它。同时我们也必须将当前二进制目录添加到包含目录列表中，使得<code>Table.h</code>可以被找到，以及被<code>mysqrt.cxx</code>包含。</p><p>但工程开始构建时，他首先会构建<code>MakeTable</code>程序，然后执行<code>MakeTable</code>来产生<code>Table.h</code>。最后，他会编译包含了<code>Table.h</code>的<code>mysqrt.cxx</code>来生成<code>MathFunctions</code>库。</p><p>至此，顶层的CMakeLists文件包含了我们之前添加的所有特性：</p><pre><code>&lt;!-- lang: shell --&gt;cmake_minimum_required (VERSION 2.6)project (Tutorial)# The version number.set (Tutorial_VERSION_MAJOR 1)set (Tutorial_VERSION_MINOR 0)# does this system provide the log and exp functions?include (${CMAKE_ROOT}/Modules/CheckFunctionExists.cmake)check_function_exists (log HAVE_LOG)check_function_exists (exp HAVE_EXP)# should we use our own math functionsoption(USE_MYMATH   &quot;Use tutorial provided math implementation&quot; ON)# configure a header file to pass some of the CMake settings# to the source codeconfigure_file (  &quot;${PROJECT_SOURCE_DIR}/TutorialConfig.h.in&quot;  &quot;${PROJECT_BINARY_DIR}/TutorialConfig.h&quot;  )# add the binary tree to the search path for include files# so that we will find TutorialConfig.hinclude_directories (&quot;${PROJECT_BINARY_DIR}&quot;)# add the MathFunctions library?if (USE_MYMATH)  include_directories (&quot;${PROJECT_SOURCE_DIR}/MathFunctions&quot;)  add_subdirectory (MathFunctions)  set (EXTRA_LIBS ${EXTRA_LIBS} MathFunctions)endif (USE_MYMATH)# add the executableadd_executable (Tutorial tutorial.cxx)target_link_libraries (Tutorial  ${EXTRA_LIBS})# add the install targetsinstall (TARGETS Tutorial DESTINATION bin)install (FILES &quot;${PROJECT_BINARY_DIR}/TutorialConfig.h&quot;                 DESTINATION include)# does the application runadd_test (TutorialRuns Tutorial 25)# does the usage message work?add_test (TutorialUsage Tutorial)set_tests_properties (TutorialUsage  PROPERTIES   PASS_REGULAR_EXPRESSION &quot;Usage:.*number&quot;  )#define a macro to simplify adding testsmacro (do_test arg result)  add_test (TutorialComp${arg} Tutorial ${arg})  set_tests_properties (TutorialComp${arg}    PROPERTIES PASS_REGULAR_EXPRESSION ${result}    )endmacro (do_test)# do a bunch of result based testsdo_test (4 &quot;4 is 2&quot;)do_test (9 &quot;9 is 3&quot;)do_test (5 &quot;5 is 2.236&quot;)do_test (7 &quot;7 is 2.645&quot;)do_test (25 &quot;25 is 5&quot;)do_test (-25 &quot;-25 is 0&quot;)do_test (0.0001 &quot;0.0001 is 0.01&quot;)</code></pre><blockquote><p>TutorialConfig.h looks like:</p></blockquote><p><code>TutorialConfig.h</code>如下：</p><pre><code>&lt;!-- lang: cpp --&gt;// the configured options and settings for Tutorial#define Tutorial_VERSION_MAJOR @Tutorial_VERSION_MAJOR@#define Tutorial_VERSION_MINOR @Tutorial_VERSION_MINOR@#cmakedefine USE_MYMATH// does the platform provide exp and log functions?#cmakedefine HAVE_LOG#cmakedefine HAVE_EXP</code></pre><blockquote><p>And the CMakeLists file for MathFunctions looks like:</p></blockquote><p><code>MathFunctions</code>的<code>CMakeLists</code>如下：</p><pre><code>&lt;!-- lang: shell --&gt;# first we add the executable that generates the tableadd_executable(MakeTable MakeTable.cxx)# add the command to generate the source codeadd_custom_command (  OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/Table.h  DEPENDS MakeTable  COMMAND MakeTable ${CMAKE_CURRENT_BINARY_DIR}/Table.h  )# add the binary tree directory to the search path # for include filesinclude_directories( ${CMAKE_CURRENT_BINARY_DIR} )# add the main libraryadd_library(MathFunctions mysqrt.cxx ${CMAKE_CURRENT_BINARY_DIR}/Table.h)install (TARGETS MathFunctions DESTINATION bin)install (FILES MathFunctions.h DESTINATION include)</code></pre><h1 id="Building-an-Installer-Step-6-构建一个安装程序"><a href="#Building-an-Installer-Step-6-构建一个安装程序" class="headerlink" title="Building an Installer (Step 6) 构建一个安装程序"></a>Building an Installer (Step 6) 构建一个安装程序</h1><blockquote><p>Next suppose that we want to distribute our project to other people so<br>that they can use it. We want to provide both binary and source<br>distributions on a variety of platforms. This is a little different<br>from the instal we did previously in section Installing and Testing<br>(Step 3), where we were installing the binaries that we had built from<br>the source code. In this example we will be building installation<br>packages that support binary installations and package management<br>features as found in cygwin, debian, RPMs etc. To accomplish this we<br>will use CPack to create platform specific installers as described in<br>Chapter Packaging with CPack. Specifically we need to add a few lines<br>to the bottom of our toplevel CMakeLists.txt file.</p></blockquote><p>下面假设我们想发布我们的工程给其他人使用。我们想同时在多个平台上提供二进制程序和源代码。这和我们之前在第三部分<code>Installing and Testing</code>中做的安装（从源代码构建安装）有一点不同。这个例子中，我们将构建一个支持二进制安装和包管理特性的安装包，就像在<code>cygwin</code>、<code>debian</code>、<code>RPM</code>中找到的安装包一样。为了完成这件事，我们将利用在章节<code>Packaging with CPack</code>提到的<code>CPack</code>制作指定平台的安装程序。特别地，我们需要在顶层<code>CMakeLists</code>下面添加几行：</p><pre><code>&lt;!-- lang: shell --&gt;# build a CPack driven installer packageinclude (InstallRequiredSystemLibraries)set (CPACK_RESOURCE_FILE_LICENSE       &quot;${CMAKE_CURRENT_SOURCE_DIR}/License.txt&quot;)set (CPACK_PACKAGE_VERSION_MAJOR &quot;${Tutorial_VERSION_MAJOR}&quot;)set (CPACK_PACKAGE_VERSION_MINOR &quot;${Tutorial_VERSION_MINOR}&quot;)include (CPack)</code></pre><blockquote><p>That is all there is to it. We start by including<br>InstallRequiredSystemLibraries. This module will include any runtime<br>libraries that are needed by the project for the current platform.<br>Next we set some CPack variables to where we have stored the license<br>and version information for this project. The version information<br>makes use of the variables we set earlier in this tutorial. Finally we<br>include the CPack module which will use these variables and some other<br>properties of the system you are on to setup an installer. The next<br>step is to build the project in the usual manner and then run CPack on<br>it. To build a binary distribution you would run:</p></blockquote><p>就是这样，先包含<code>InstallRequiredSystemLibraries</code>。这个模块将包含工程在当前平台需要的任何运行库。然后，我们设置一些<code>CPack</code>变量指向工程存放<code>license</code>和<code>version</code>信息的地方。版本信息利用了我们之前在教程里设置的变量。最后，我们包含的<code>CPack</code>模块将会使用这些变量，以及你所在系统的其他一些属性，来制作一个安装包。</p><p>下一步是按照平常的方式构建工程然后启动<code>CPack</code>。要发布一个二进制版，你需要执行：</p><pre><code>&lt;!-- lang: shell --&gt;cpack -C CPackConfig.cmake</code></pre><blockquote><p>To create a source distribution you would type</p></blockquote><p>要发布源代码，你需要执行：</p><pre><code>&lt;!-- lang: shell --&gt;cpack -C CPackSourceConfig.cmake</code></pre><h1 id="Adding-Support-for-a-Dashboard-Step-7-添加面板支持"><a href="#Adding-Support-for-a-Dashboard-Step-7-添加面板支持" class="headerlink" title="Adding Support for a Dashboard (Step 7)  添加面板支持"></a>Adding Support for a Dashboard (Step 7)  添加面板支持</h1><blockquote><p>Adding support for submitting our test results to a dashboard is very<br>easy. We already defined a number of tests for our project in the<br>earlier steps of this tutorial. We just have to run those tests and<br>submit them to a dashboard. To include support for dashboards we<br>include the CTest module in our toplevel CMakeLists file.</p></blockquote><p>为提交我们的测试结果添加面板支持十分简单。在之前的教程中，我们已经为工程定义了很多测试。我们仅仅需要执行这些测试以及把它们提交到面板。要包含面板支持我们需要在顶层<code>CMakeLists</code>中包含<code>CTest</code>模块。</p><pre><code>&lt;!-- lang: shell --&gt;# enable dashboard scriptinginclude (CTest)</code></pre><blockquote><p>We also create a CTestConfig.cmake file where we can specify the name<br>of this project for the dashboard.</p></blockquote><p>我们还为面板写了一个可以指定工程名的<code>CTestConfig.cmake</code>文件。</p><pre><code>&lt;!-- lang: shell --&gt;set (CTEST_PROJECT_NAME &quot;Tutorial&quot;)</code></pre><blockquote><p>CTest will read in this file when it runs. To create a simple<br>dashboard you can run CMake on your project, change directory to the<br>binary tree, and then run ctest –D Experimental. The results of your<br>dashboard will be uploaded to Kitware’s public dashboard here.</p></blockquote><p><code>CTest</code>将在运行时读取这个文件。要创建一个简单的面板，你可以在你的工程里运行CMake，将目录改变到二进制树，然后执行实验性的<code>ctest -D</code>。你面板上的结果将会被上传到<code>Kitware</code>的<a href="http://www.cdash.org/CDash/index.php?project=PublicDashboard" target="_blank" rel="noopener">公开面板</a>。</p><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>由于本人水平所限，译文和原文内容难免存在差异，甚至错误，还请各位读者评批指出！谢谢！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CMake-Tutorial&quot;&gt;&lt;a href=&quot;#CMake-Tutorial&quot; class=&quot;headerlink&quot; title=&quot;CMake Tutorial&quot;&gt;&lt;/a&gt;CMake Tutorial&lt;/h1&gt;&lt;p&gt;原版英文Tutorial：&lt;/p&gt;
&lt;p&gt;&lt;
      
    
    </summary>
    
    
      <category term="tech" scheme="https://apporz.com/tags/tech/"/>
    
      <category term="cmake" scheme="https://apporz.com/tags/cmake/"/>
    
  </entry>
  
  <entry>
    <title>C++ 字符编码问题探究和中文乱码的产生</title>
    <link href="https://apporz.com/2015/01/02/cpp-encoding-problem/"/>
    <id>https://apporz.com/2015/01/02/cpp-encoding-problem/</id>
    <published>2015-01-01T16:00:00.000Z</published>
    <updated>2017-12-08T13:17:42.203Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>一直以来，C/C++对中文字符的处理时常让人摸不着头脑。</p><p>主要有下面几个原因：</p><ol><li><p>文件编码方式的差异</p></li><li><p>系统环境对中文的解释有差异</p></li><li><p>不同编译器对标准库的实现有差异</p></li></ol><p>而这三者往往又相互影响，暗藏玄机，让人抓狂。</p><p>在写本文之前我查阅了很多博客，关于中文的输入输出，cout，wcout，fstream，wfstream，乱码解决方案等等问题都有了十分详细的解答，但是，很多博文具有片面性。</p><p>许多博主仅仅是针对自己所使用的环境做阐述，而又没有明确指明使用了何种IDE，何种编译器，何种系统。结果就是，博主们高高兴兴的解决的自己的问题并分享出来，大家高高兴兴的点赞，觉得自己和博主的问题是同一个问题，实际情况却大相径庭。</p><h1 id="必要的说明"><a href="#必要的说明" class="headerlink" title="必要的说明"></a>必要的说明</h1><p>文本涉及的编译器和系统：</p><ul><li><p>msvc v120  Windows 8.1</p></li><li><p>mingw 4.8 32bit Windows 8.1</p></li><li><p>g++ 4.8.2 Linux 64bit</p></li></ul><h1 id="开始测试"><a href="#开始测试" class="headerlink" title="开始测试"></a>开始测试</h1><p>测试之前很有必要说明一点：</p><blockquote><p>A program should not mix output operations on wcout with output operations on cout (or with other narrow-oriented output operations on stdout): Once an output operation has been performed on either, the standard output stream acquires an orientation (either narrow or wide) that can only be safely changed by calling freopen on stdout.<br>—- cplusplus.com</p></blockquote><p>就是说不要混用cout和wcout进行输出，因此下面的例子中都是单独使用cout或者wcout。</p><h2 id="cout测试"><a href="#cout测试" class="headerlink" title="cout测试"></a>cout测试</h2><p><em>下面的测试在Visual Studio 2013中进行。</em></p><h3 id="MSVC，默认编码GB2312（可以在-文件–高级保存选项-中查看和修改）"><a href="#MSVC，默认编码GB2312（可以在-文件–高级保存选项-中查看和修改）" class="headerlink" title="MSVC，默认编码GB2312（可以在 文件–高级保存选项 中查看和修改）"></a>MSVC，默认编码GB2312（可以在 <strong>文件–高级保存选项</strong> 中查看和修改）</h3><pre><code>&lt;!-- lang: cpp --&gt;#include &lt;iostream&gt;int main() {    using namespace std;    const char *code = &quot;abc中文def&quot;;    cout &lt;&lt; &quot;abc中文def&quot; &lt;&lt; endl;    cout &lt;&lt; code &lt;&lt; endl;    return 0;}</code></pre><p><strong>结果</strong></p><blockquote><p>abc中文def</p><p>abc中文def</p></blockquote><p>均正确输出。</p><h3 id="MSVC，改变编码为UTF8（-bom）"><a href="#MSVC，改变编码为UTF8（-bom）" class="headerlink" title="MSVC，改变编码为UTF8（+bom）"></a>MSVC，改变编码为UTF8（+bom）</h3><p><strong>结果</strong></p><blockquote><p>abc中文def</p><p>abc中文def</p></blockquote><p>均正确输出。</p><h3 id="MSVC，改变编码为UTF8（-bom）-1"><a href="#MSVC，改变编码为UTF8（-bom）-1" class="headerlink" title="MSVC，改变编码为UTF8（-bom）"></a>MSVC，改变编码为UTF8（-bom）</h3><p><strong>结果</strong></p><blockquote><p>abc涓枃def</p><p>abc涓枃def</p></blockquote><p>出现乱码。</p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>可以看到源文件的编码方式会影响最后的输出，原因在于常量文本采用了<strong>硬编码</strong>的方式，也就是说源代码里面的中文会根据当前文件的编码方式直接翻译成对应字节码放进存储空间。</p><p>如“中文”二字，</p><p><strong>GB2312</strong>（Codepage 936）的编码为：</p><p>D6 D0 CE C4</p><p>而<strong>UTF8</strong>是：</p><p>E4 B8 AD E6 96 87</p><p>而控制台也有一套编码方式，对于Windows的cmd，可以查看其 <strong>属性</strong> 下面的当前代码页，笔者是ANSI(936)。</p><p>当向控制台传送GB2312的字节码时，中文显示正常，当传入无签名的UTF8的字节码时，中文就不能被正确解释，出现了乱码。</p><p>Q：为什么带有签名的UTF8却可以正常显示呢？</p><p>A：实际上UTF8完全不需要带签名，M$自作聪明YY了一个bom头来识别文件是不是UTF8。因此带有签名的UTF8能被cmd识别为UTF8，中文才能显示正常。</p><p>为了进一步证实是不是和控制台的编码有关系，并正确理解上一个例子中乱码的产生缘由，我们可以做一个重定向，将结果输出到文本文件：</p><blockquote><p>test.exe &gt; test.txt</p></blockquote><p>使用任意可以改变编码的文本编辑器（笔者使用的是everedit）查看，可以发现以UTF8解释，显示正常，以ANSI(936)解释，将得到刚才那个乱码。</p><hr><p><em>下面的测试在QtCreator中进行。</em></p><h3 id="MinGW，UTF8"><a href="#MinGW，UTF8" class="headerlink" title="MinGW，UTF8"></a>MinGW，UTF8</h3><p><strong>结果</strong></p><blockquote><p>abc涓枃def</p><p>abc涓枃def</p></blockquote><p>出现乱码。</p><h3 id="MinGW，ANSI-936"><a href="#MinGW，ANSI-936" class="headerlink" title="MinGW，ANSI-936"></a>MinGW，ANSI-936</h3><p><strong>结果</strong></p><blockquote><p>abc中文def</p><p>abc中文def</p></blockquote><p>显示正确。</p><hr><p><em>下面的测试在Linux的bash中进行。</em></p><h3 id="g-，UTF8"><a href="#g-，UTF8" class="headerlink" title="g++，UTF8"></a>g++，UTF8</h3><p><strong>结果</strong></p><blockquote><p>abc中文def</p><p>abc中文def</p></blockquote><p>显示正确。</p><h3 id="g-，gb2312"><a href="#g-，gb2312" class="headerlink" title="g++，gb2312"></a>g++，gb2312</h3><p><strong>结果</strong></p><blockquote><p>abc▒▒▒▒def</p><p>abc▒▒▒▒def</p></blockquote><p>出现乱码。</p><p>Ubuntu查看/etc/default/locale，可以看到LANG=”en_US.UTF-8”，说明bash能解释UTF8的字节码，而gb2312的变成了乱码。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>程序的输出编码必须和”显示程序”的显示编码适配时才能得到正确的结果。简而言之就是<strong>解铃还须系铃人</strong>。</p><hr><p>宽字符使用多个字节来表示一个字符，中文可以用char来表示没问题，用wchar来表示也没有问题。</p><h2 id="wcout测试"><a href="#wcout测试" class="headerlink" title="wcout测试"></a>wcout测试</h2><p>wcout输出wchar_t型的宽字符，测试代码如下：</p><pre><code>&lt;!-- lang: cpp --&gt;#include &lt;iostream&gt;int main() {    using namespace std;    const wchar_t *code = L&quot;abc中文def&quot;;    wcout &lt;&lt; L&quot;abc中文def&quot; &lt;&lt; endl;    wcout &lt;&lt; code &lt;&lt; endl;    return 0;}</code></pre><h3 id="MSVC，无论上述何种编码"><a href="#MSVC，无论上述何种编码" class="headerlink" title="MSVC，无论上述何种编码"></a>MSVC，无论上述何种编码</h3><p><strong>结果</strong></p><p>abc</p><p>输出被截断，只有前几个英文字母可以被输出，传入指针输出无效。</p><h3 id="问题分析-1"><a href="#问题分析-1" class="headerlink" title="问题分析"></a>问题分析</h3><p><strong>L”abc中文def”</strong> 在内存中表现为：</p><blockquote><p>(gb2312)    61 00 62 00 63 00 <strong>2d 4e 87 65</strong> 64 00 65 00 66 00</p><p>(utf8-bom) 61 00 62 00 63 00 <strong>2d 4e 87 65</strong> 64 00 65 00 66 00</p><p>(utf8+bom)61 00 62 00 63 00 <strong>93 6d 5f e1 83 67</strong> 64 00 65 00  66 00</p></blockquote><p>wcout 在处理L”abc中文def”时，按宽字节依次遍历，前面的abc没问题（小端序第一个字节是00），遇到中文，识别不了，无输出，间接导致后续&lt;&lt;都没有输出了。</p><p>也就是说wcout不能用来处理中文输出。</p><p>第二个传入wchar_t指针，发现没有任何输出，为了验证是不是由于上一条输出语句中中文的影响，单独测试如下：</p><pre><code>&lt;!-- lang: cpp --&gt;#include &lt;iostream&gt;int main() {    using namespace std;    const wchar_t *code = L&quot;abc中文def&quot;;    wcout &lt;&lt; code &lt;&lt; endl;    return 0;}</code></pre><p><strong>结果</strong></p><p>abc</p><p>说明传入wchar_t指针是可以正常输出宽字节英文的，一旦遇到非00字节间隔，后续所有输出将无效。</p><p>MinGW的结果同样如此，无论编码与否，只要wcout遇到中文立马跪。</p><p>有博主称可以在输出前执行下面的函数或者进行全局设置来让wcout认识中文：</p><pre><code>&lt;!-- lang: cpp --&gt;std::wcout.imbue(std::locale(&quot;chs&quot;));std::locale::global(std::locale(&quot;&quot;));//全局设置</code></pre><ul><li><p>MSVC下，没有问题，可以达到预期结果。</p></li><li><p>MinGW下，第一条语句会抛出一个runtime_error异常崩溃掉，第二条语句无效。</p></li><li><p>Linux g++下，没问题。</p></li></ul><p>可见MinGW的libstdc++对locale的实现不理想，有传闻使用stlport可以避免这个问题。</p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p>认清你的代码处在何种编码的环境</p></li><li><p>认清放在你字符串里面的数据是何种编码</p></li><li><p>认清你要向具有何种编码的屏幕传送数据</p></li><li><p>解铃还须系铃人</p></li><li><p>非特殊情况下不建议使用wchar_t来存放中文字符</p></li></ul><p>很多时候中文并不是硬编码进程序的，例如一段中文来自网络，以gb2312编码，而”屏幕”只认UTF8，这个时候就要进行必要的编码转换。boost库的boost::locale::conv中提供了很多常用的转换模板函数，来实现宽窄字符、ansi和utf之间的相互转换。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;一直以来，C/C++对中文字符的处理时常让人摸不着头脑。&lt;/p&gt;
&lt;p&gt;主要有下面几个原因：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;文件编码方式的
      
    
    </summary>
    
    
      <category term="tech" scheme="https://apporz.com/tags/tech/"/>
    
      <category term="cpp" scheme="https://apporz.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>C++使用Boost实现Network Time Protocol(NTP)客户端</title>
    <link href="https://apporz.com/2014/10/01/cpp-ntp-client-using-boost/"/>
    <id>https://apporz.com/2014/10/01/cpp-ntp-client-using-boost/</id>
    <published>2014-09-30T16:00:00.000Z</published>
    <updated>2017-12-08T13:17:42.213Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>笔者机器上安装了两个系统，一个Linux Ubuntu，一个Windows8.1。让人感到郁闷的是，每次从Ubuntu重启进入Windows时，系统时间总是少了8个小时，每次都要用Windows的时间程序进行同步，也就是下面这个东西：</p><p><img src="103314_axWa_580940.png" alt=""></p><p>这个东西其实就是一个NTP Client，从Internet上选择一台NTP Server，获取UTC时间，然后设置本地时间。</p><p>于是我想自己实现一个这样的程序，先百度一下吧，网上有很多关于NTP的资料和实现代码，大多是单一平台的，不能跨平台</p><p>，下面给几个参考：</p><p><a href="http://blog.csdn.net/loongee/article/details/24271129" target="_blank" rel="noopener">http://blog.csdn.net/loongee/article/details/24271129</a></p><p><a href="http://blog.csdn.net/chexlong/article/details/6963541" target="_blank" rel="noopener">http://blog.csdn.net/chexlong/article/details/6963541</a></p><p><a href="http://www.cnblogs.com/TianFang/archive/2011/12/20/2294603.html" target="_blank" rel="noopener">http://www.cnblogs.com/TianFang/archive/2011/12/20/2294603.html</a></p><p>本文使用boost的Asio来跨平台实现NTP Client.</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ol><li>最新的boost库，本文使用的是1.56.0版本<br>要用到里面的ASIO网络库</li><li>IDE是Visual Studio 2013 with Update3<br>笔者是版本帝</li><li>WireShark也是最新的1.12.1版本<br>用来分析Windows自带的NTP Client</li></ol><h2 id="NTP-Packet分析"><a href="#NTP-Packet分析" class="headerlink" title="NTP Packet分析"></a>NTP Packet分析</h2><p>这里我们分析的正是上图那个程序，点击立即更新，会发送NTP的请求包，下面是Wireshark的抓包结果：</p><p><img src="105506_Pfy8_580940.png" alt=""></p><p>可以得到下面一些信息：</p><ol><li>NTP时间同步分两个过程，一个Request，一个Response</li><li>这里的NTP Server的IP地址是<strong>129.6.15.28</strong></li><li>程序没有进行DNS解析，可能是直接保存了IP地址</li><li>NTP服务的端口号是123，Client也使用了<strong>123端口</strong>，后来发现Client不是一定要使用123端口的</li><li>NTP协议是构建在<strong>UDP传输协议</strong>上的应用协议</li><li>这里使用V3版的NTP协议，目前还有v4</li></ol><p>好了，有了关于NTP协议的一些基本信息，我们再来看看应用层的详细信息：</p><p><strong>Response</strong>包：</p><p><img src="110611_s2ke_580940.png" alt=""></p><p>分了很多字段，关于每个字段的含义请参考上面给出的链接，本文主要讲实现。这里Reference Timestamp就是Request包发送的Timestamp，而Origin,Receive,Transmit都是从Server返回回来的时间，后三个时间都相差非常小，因此方便一点，我们取最后一个Transmit Timestamp作为结果。</p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>boost里面相关库的编译可以参考官方的文档，里面有非常简单的例子。</p><h5 id="1-需要的头文件和名字空间"><a href="#1-需要的头文件和名字空间" class="headerlink" title="1. 需要的头文件和名字空间"></a>1. 需要的头文件和名字空间</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"boost/asio.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"boost/date_time/posix_time/posix_time.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::posix_time;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::asio::ip;</span><br></pre></td></tr></table></figure><h5 id="2-NtpPacket的构造"><a href="#2-NtpPacket的构造" class="headerlink" title="2. NtpPacket的构造"></a>2. NtpPacket的构造</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NtpPacket</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NtpPacket() &#123;</span><br><span class="line">        _rep._flags = <span class="number">0xdb</span>;</span><br><span class="line">        <span class="comment">//    11.. ....    Leap Indicator: unknown</span></span><br><span class="line">        <span class="comment">//    ..01 1...    NTP Version 3</span></span><br><span class="line">        <span class="comment">//    .... .011    Mode: client</span></span><br><span class="line">        _rep._pcs = <span class="number">0x00</span>;<span class="comment">//unspecified</span></span><br><span class="line">        _rep._ppt = <span class="number">0x01</span>;</span><br><span class="line">        _rep._pcp = <span class="number">0x01</span>;</span><br><span class="line">        _rep._rdy = <span class="number">0x01000000</span>;<span class="comment">//big-endian</span></span><br><span class="line">        _rep._rdn = <span class="number">0x01000000</span>;</span><br><span class="line">        _rep._rid = <span class="number">0x00000000</span>;</span><br><span class="line">        _rep._ret = <span class="number">0x0</span>;</span><br><span class="line">        _rep._ort = <span class="number">0x0</span>;</span><br><span class="line">        _rep._rct = <span class="number">0x0</span>;</span><br><span class="line">        _rep._trt = <span class="number">0x0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; os, <span class="keyword">const</span> NtpPacket&amp; ntpacket) &#123;</span><br><span class="line">        <span class="keyword">return</span> os.write(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt;(&amp;ntpacket._rep), <span class="keyword">sizeof</span>(ntpacket._rep));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::istream&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="built_in">std</span>::istream&amp; is, NtpPacket&amp; ntpacket) &#123;</span><br><span class="line">        <span class="keyword">return</span> is.read(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(&amp;ntpacket._rep), <span class="keyword">sizeof</span>(ntpacket._rep));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(1)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NtpHeader</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint8_t</span> _flags;<span class="comment">//Flags</span></span><br><span class="line">        <span class="keyword">uint8_t</span> _pcs;<span class="comment">//Peer Clock Stratum</span></span><br><span class="line">        <span class="keyword">uint8_t</span> _ppt;<span class="comment">//Peer Polling Interval</span></span><br><span class="line">        <span class="keyword">uint8_t</span> _pcp;<span class="comment">//Peer Clock Precision</span></span><br><span class="line">        <span class="keyword">uint32_t</span> _rdy;<span class="comment">//Root Delay</span></span><br><span class="line">        <span class="keyword">uint32_t</span> _rdn;<span class="comment">//Root Dispersion</span></span><br><span class="line">        <span class="keyword">uint32_t</span> _rid;<span class="comment">//Reference ID</span></span><br><span class="line">        <span class="keyword">uint64_t</span> _ret;<span class="comment">//Reference Timestamp</span></span><br><span class="line">        <span class="keyword">uint64_t</span> _ort;<span class="comment">//Origin Timestamp</span></span><br><span class="line">        <span class="keyword">uint64_t</span> _rct;<span class="comment">//Receive Timestamp</span></span><br><span class="line">        <span class="keyword">uint64_t</span> _trt;<span class="comment">//Transmit Timestamp</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()</span></span><br><span class="line">    NtpHeader _rep;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里为了方便存取就没有把struct放到private中，需要注意的是结构体各个字段的顺序和需要进行内存1字节对齐，即使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(1)</span></span><br></pre></td></tr></table></figure><p>内存对齐在网络编程中十分重要，他会直接影响Packet的内容，关于内存对齐可以参考：</p><p><a href="http://www.cppblog.com/cc/archive/2006/08/01/10765.html" target="_blank" rel="noopener">http://www.cppblog.com/cc/archive/2006/08/01/10765.html</a></p><p>NTP请求包中最重要的是flags，里面存有版本信息等直接影响协议工作的内容，因此不能搞错了。</p><p>两个operator重载用来方便读写Packet数据。</p><p>再来看看Client类的实现，Client类的主要任务就是发送和接受NTP包，并返回最后那个64bit的Timestamp。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NtpClient</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NtpClient(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; serverIp)</span><br><span class="line">        :_socket(io), _serverIp(serverIp) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">time_t</span> getTime() &#123;</span><br><span class="line">        <span class="keyword">if</span> (_socket.is_open()) &#123;</span><br><span class="line">            _socket.shutdown(udp::socket::shutdown_both, _ec);</span><br><span class="line">            <span class="keyword">if</span> (_ec) &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; _ec.message() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                _socket.close();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            _socket.close();</span><br><span class="line">        &#125;</span><br><span class="line">        udp::endpoint ep(boost::asio::ip::address_v4::from_string(_serverIp), NTP_PORT);</span><br><span class="line">        NtpPacket request;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stringstream</span> ss;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> buf;</span><br><span class="line">        ss &lt;&lt; request;</span><br><span class="line">        ss &gt;&gt; buf;</span><br><span class="line">        _socket.open(udp::v4());</span><br><span class="line">        _socket.send_to(boost::asio::buffer(buf), ep);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">uint8_t</span>, 128&gt; recv;</span><br><span class="line">        <span class="keyword">size_t</span> len = _socket.receive_from(boost::asio::buffer(recv), ep);</span><br><span class="line">        <span class="keyword">uint8_t</span>* pBytes = recv.data();</span><br><span class="line">        <span class="comment">/****dump hex data</span></span><br><span class="line"><span class="comment">        for (size_t i = 0; i &lt; len; i++) &#123;</span></span><br><span class="line"><span class="comment">        if (i % 16 == 0) &#123;</span></span><br><span class="line"><span class="comment">        std::cout &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        else &#123;</span></span><br><span class="line"><span class="comment">        std::cout &lt;&lt; std::setw(2) &lt;&lt; std::setfill('0')</span></span><br><span class="line"><span class="comment">        &lt;&lt; std::hex &lt;&lt; (uint32_t) pBytes[i];</span></span><br><span class="line"><span class="comment">        std::cout &lt;&lt; ' ';</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        ****/</span></span><br><span class="line">        <span class="keyword">time_t</span> tt;</span><br><span class="line">        <span class="keyword">uint64_t</span> last;</span><br><span class="line">        <span class="keyword">uint32_t</span> seconds;</span><br><span class="line">        <span class="comment">/****get the last 8 bytes(Transmit Timestamp) from received packet.</span></span><br><span class="line"><span class="comment">        std::memcpy(&amp;last, pBytes + len - 8, sizeof(last));</span></span><br><span class="line"><span class="comment">        ****create a NtpPacket*/</span></span><br><span class="line">        NtpPacket resonpse;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stringstream</span> rss;</span><br><span class="line">        rss.write(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(pBytes), len);</span><br><span class="line">        rss &gt;&gt; resonpse;</span><br><span class="line">        last = resonpse._rep._trt;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        reverseByteOrder(last);</span><br><span class="line">        seconds = (last &amp; <span class="number">0x7FFFFFFF00000000</span>) &gt;&gt; <span class="number">32</span>;</span><br><span class="line">        tt = seconds + <span class="number">8</span> * <span class="number">3600</span> * <span class="number">2</span> - <span class="number">61533950</span>;</span><br><span class="line">        <span class="keyword">return</span> tt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint16_t</span> NTP_PORT = <span class="number">123</span>;</span><br><span class="line">    udp::socket _socket;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> _serverIp;</span><br><span class="line">    boost::system::error_code _ec;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意几个地方：</p><h5 id="1-udp-socket是boost里面使用udp协议的套接字，他的构造需要一个io-service，io-service可以直接在全局区进行声明："><a href="#1-udp-socket是boost里面使用udp协议的套接字，他的构造需要一个io-service，io-service可以直接在全局区进行声明：" class="headerlink" title="1. udp::socket是boost里面使用udp协议的套接字，他的构造需要一个io_service，io_service可以直接在全局区进行声明："></a>1. udp::socket是boost里面使用udp协议的套接字，他的构造需要一个io_service，io_service可以直接在全局区进行声明：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boost::asio::io_service io;</span><br></pre></td></tr></table></figure><h5 id="2-创建一个endpoint用来表示NTP-Server的地址："><a href="#2-创建一个endpoint用来表示NTP-Server的地址：" class="headerlink" title="2. 创建一个endpoint用来表示NTP Server的地址："></a>2. 创建一个endpoint用来表示NTP Server的地址：</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">udp::endpoint ep(boost::asio::ip::address_v4::from_string(_serverIp), NTP_PORT);</span><br></pre></td></tr></table></figure><p>向这个ep send_to，并从这个ep receive_from数据包。</p><h5 id="3-time-t的定义如下："><a href="#3-time-t的定义如下：" class="headerlink" title="3. time_t的定义如下："></a>3. time_t的定义如下：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">__time64_t</span> <span class="keyword">time_t</span>;      <span class="comment">/* time value */</span></span><br><span class="line"><span class="keyword">typedef</span> __int64 <span class="keyword">__time64_t</span>;     <span class="comment">/* 64-bit time value */</span></span><br></pre></td></tr></table></figure><p>也就是说这个time_t其实就是一个64bit的int，我们可以用uint64_t这个类型与之互换，他可以用来表示一个Timestamp。</p><ol><li><p>获取最后8字节内容有两种方式，一种是直接复制pBytes的内存，一种是构造NtpPacket，然后取成员，这里选择后者易于理解。</p></li><li><p>字节序的问题</p></li></ol><p>网络字节序都是大端模式，需要进行转换，由于仅仅需要最后那个uint64_t所以我写了一个针对64bit的字节序转换函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverseByteOrder</span><span class="params">(<span class="keyword">uint64_t</span> &amp;in)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> rs = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">memset</span>(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint8_t</span>*&gt;(&amp;rs) + len - <span class="number">1</span> - i</span><br><span class="line">                    , <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt; ((in &amp; <span class="number">0xFF</span>LL &lt;&lt; (i * <span class="number">8</span>)) &gt;&gt; i * <span class="number">8</span>)</span><br><span class="line">                    , <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    in = rs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后一个64bit内容的高32位存了UTC秒数，所以需要取出来，然后再转换为本地时区的秒数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seconds = (last &amp; <span class="number">0x7FFFFFFF00000000</span>) &gt;&gt; <span class="number">32</span>;</span><br></pre></td></tr></table></figure><p>注意最高位是不能取的，尽管是unsigned，至于为什么要- 61533950这个是笔者在自己电脑上尝试出来的，找了很多资料不知是哪里的问题，还请各位知道的读者告诉我哈。</p><p>再来看看主函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* agrv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">NtpClient <span class="title">ntp</span><span class="params">(<span class="string">"129.6.15.28"</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="keyword">time_t</span> tt = ntp.getTime();</span><br><span class="line">        boost::posix_time::ptime utc = <span class="keyword">from_time_t</span>(tt);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Local Timestamp:"</span> &lt;&lt; time(<span class="number">0</span>) &lt;&lt; <span class="string">'\t'</span> &lt;&lt; <span class="string">"NTP Server:"</span> &lt;&lt; tt &lt;&lt; <span class="string">"("</span> &lt;&lt; to_simple_string(utc) &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        Sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里进行5次NTP请求，并使用boost的to_simple_string转换UTC时间打印结果。</p><p>大概是这种效果：</p><p><img src="115316_jWZi_580940.png" alt=""></p><h2 id="收尾"><a href="#收尾" class="headerlink" title="收尾"></a>收尾</h2><p>同步时间一般都会想到找一个http api接口，本文主要是用了NTP协议。为了跨平台，上面的代码尽可能避免使用平台相关的宏和函数，只要稍作修改就能在各种平台下执行，也得益于boost这个强悍的准标准库给开发者带来的便利。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;笔者机器上安装了两个系统，一个Linux Ubuntu，一个Windows8.1。让人感到郁闷的是，每次从Ubuntu重启进入Windows
      
    
    </summary>
    
    
      <category term="tech" scheme="https://apporz.com/tags/tech/"/>
    
      <category term="cpp" scheme="https://apporz.com/tags/cpp/"/>
    
      <category term="net" scheme="https://apporz.com/tags/net/"/>
    
  </entry>
  
  <entry>
    <title>C++我也来写个工厂模式</title>
    <link href="https://apporz.com/2014/08/28/cpp-factory-design-pattern/"/>
    <id>https://apporz.com/2014/08/28/cpp-factory-design-pattern/</id>
    <published>2014-08-27T16:00:00.000Z</published>
    <updated>2017-12-08T13:17:42.203Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>工厂方法模式（Factory method pattern）是一种实现了“工厂”概念的面向对象设计模式。就像其他创建型模式一样，它也是处理在不指定对象具体类型的情况下创建对象的问题。工厂方法模式的实质是“定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。</p></blockquote><p>以前是没有实现过工厂模式，这里我用到了template来创建类型不同的Products，内存管理这块没想到更好的办法来cleanup，打算是利用析构自动release，不过貌似到模版里就捉禁见肘了。。大家有什么高见？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ProductA</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ProductA::name()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I'm Product A."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ProductB</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ProductB::name()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I'm Product B."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Factory</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">static</span> T* <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Factory();</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T*&gt; objs_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T*&gt; Factory&lt;T&gt;::objs_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Factory&lt;T&gt;::Factory()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Factory&lt;T&gt;::cleanup()</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">for</span> <span class="title">each</span> <span class="params">(T* obj in objs_)</span></span></span><br><span class="line"><span class="function"><span class="title">if</span> <span class="params">(obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"release "</span> &lt;&lt; obj &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">delete</span> obj;</span><br><span class="line">obj = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">objs_.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T* Factory&lt;T&gt;::create()</span><br><span class="line">&#123;</span><br><span class="line">T * obj = <span class="keyword">new</span> T;</span><br><span class="line">objs_.push_back(obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//create 10 ProductAs</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> pa = Factory&lt;ProductA&gt;::create();</span><br><span class="line">pa-&gt;name();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//create 10 ProductBs</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> pb = Factory&lt;ProductB&gt;::create();</span><br><span class="line">pb-&gt;name();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//free memory</span></span><br><span class="line">Factory&lt;ProductA&gt;::cleanup();</span><br><span class="line">Factory&lt;ProductB&gt;::cleanup();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;工厂方法模式（Factory method pattern）是一种实现了“工厂”概念的面向对象设计模式。就像其他创建型模式一样，它也是处理在不指定对象具体类型的情况下创建对象的问题。工厂方法模式的实质是“定义一个创建对象的接口，但让实现这个接口的类
      
    
    </summary>
    
    
      <category term="tech" scheme="https://apporz.com/tags/tech/"/>
    
      <category term="cpp" scheme="https://apporz.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>使用Golang实现简单Ping过程</title>
    <link href="https://apporz.com/2014/08/11/golang-ping-implememt/"/>
    <id>https://apporz.com/2014/08/11/golang-ping-implememt/</id>
    <published>2014-08-10T16:00:00.000Z</published>
    <updated>2017-12-08T13:17:42.225Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>关于各种语言实现Ping已经是大家喜闻乐见的事情了，网络上利用Golang实现Ping已经有比较详细的代码示例，但大多是仅仅是实现了Request过程，而对Response的回显内容并没有做接收。而Ping程序不仅仅是发送一个ICMP，更重要的是如何接收并进行统计。</p><p>下面是网络上几篇关于Ping的实现代码：</p><p><a href="https://github.com/paulstuart/ping/blob/master/ping.go" target="_blank" rel="noopener">https://github.com/paulstuart/ping/blob/master/ping.go</a></p><p><a href="http://blog.csdn.net/gophers/article/details/21481447" target="_blank" rel="noopener">http://blog.csdn.net/gophers/article/details/21481447</a></p><p><a href="http://blog.csdn.net/laputa73/article/details/17226337" target="_blank" rel="noopener">http://blog.csdn.net/laputa73/article/details/17226337</a></p><p>本文借鉴了第二个链接里面的部分代码。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ol><li>安装最新的Go<br>由于Google被墙的原因，如果没有VPN的话，就到这里下载：<br><a href="http://www.golangtc.com/download" target="_blank" rel="noopener">http://www.golangtc.com/download</a></li><li>使用任意文本编辑器，或者LiteIDE会比较方便编译和调试，下面是LiteIDE的下载地址<br><a href="https://github.com/visualfc/liteide" target="_blank" rel="noopener">https://github.com/visualfc/liteide</a></li></ol><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>要用到的package：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"container/list"</span></span><br><span class="line"><span class="string">"encoding/binary"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><ol><li>使用Golang提供的net包中的相关函数可以快速构造一个IP包并自定义其中一些关键参数，而不需要再自己手动填充IP报文。</li><li>使用encoding/binary包可以轻松获取结构体struct的内存数据并且可以规定字节序（这里要用网络字节序BigEndian），而不需要自己去转换字节序。之前的一片文中使用boost，还要自己去实现转换过程，详见：关于蹭网检查的原理及实现</li><li>使用container/list包，方便进行结果统计</li><li>使用time包实现耗时和超时处理</li></ol><p>ICMP报文struct：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ICMP <span class="keyword">struct</span> &#123;</span><br><span class="line">Type        <span class="keyword">uint8</span></span><br><span class="line">Code        <span class="keyword">uint8</span></span><br><span class="line">Checksum    <span class="keyword">uint16</span></span><br><span class="line">Identifier  <span class="keyword">uint16</span></span><br><span class="line">SequenceNum <span class="keyword">uint16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Usage提示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">arg_num := <span class="built_in">len</span>(os.Args)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> arg_num &lt; <span class="number">2</span> &#123;</span><br><span class="line">fmt.Print(</span><br><span class="line"><span class="string">"Please runAs [super user] in [terminal].\n"</span>,</span><br><span class="line"><span class="string">"Usage:\n"</span>,</span><br><span class="line"><span class="string">"\tgoping url\n"</span>,</span><br><span class="line"><span class="string">"\texample: goping www.baidu.com"</span>,</span><br><span class="line">)</span><br><span class="line">time.Sleep(<span class="number">5e9</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这个ping程序，包括之前的ARP程序都必须使用系统最高权限执行，所以这里先给出提示，使用time.Sleep(5e9)，暂停5秒，是为了使双击执行者看到提示，避免控制台一闪而过。</p><p>关键net对象的创建和初始化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">icmp     ICMP</span><br><span class="line">laddr    = net.IPAddr&#123;IP: net.ParseIP(<span class="string">"0.0.0.0"</span>)&#125;</span><br><span class="line">raddr, _ = net.ResolveIPAddr(<span class="string">"ip"</span>, os.Args[<span class="number">1</span>])</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">conn, err := net.DialIP(<span class="string">"ip4:icmp"</span>, &amp;laddr, raddr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err.Error())</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br></pre></td></tr></table></figure><p>net.DialIP表示生成一个IP报文，版本号是v4，协议是ICMP（这里字符串ip4:icmp会把IP报文的协议字段设为1表示ICMP协议），</p><p>源地址laddr可以是0.0.0.0也可以是自己的ip，这个并不影响ICMP的工作。</p><p>目的地址raddr是一个URL，这里使用Resolve进行DNS解析，注意返回值是一个指针，所以下面的DialIP方法中参数表示没有取地址符。</p><p>这样一个完整的IP报文就装配好了，我们并没有去操心IP中的其他一些字段，Go已经为我们处理好了。</p><p>通过返回的conn *net.IPConn对象可以进行后续操作。</p><p>defer conn.Close() 表示该函数将在Return时被执行，确保不会忘记关闭。</p><p>下面需要构造ICMP报文了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">icmp.Type = <span class="number">8</span></span><br><span class="line">icmp.Code = <span class="number">0</span></span><br><span class="line">icmp.Checksum = <span class="number">0</span></span><br><span class="line">icmp.Identifier = <span class="number">0</span></span><br><span class="line">icmp.SequenceNum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> buffer bytes.Buffer</span><br><span class="line">binary.Write(&amp;buffer, binary.BigEndian, icmp)</span><br><span class="line">icmp.Checksum = CheckSum(buffer.Bytes())</span><br><span class="line">buffer.Reset()</span><br><span class="line">binary.Write(&amp;buffer, binary.BigEndian, icmp)</span><br></pre></td></tr></table></figure><p>仍然非常简单，利用binary可以把一个结构体数据按照指定的字节序读到缓冲区里面，计算校验和后，再读进去。</p><p>检验和算法参考上面给出的URL中的实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CheckSum</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="title">uint16</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">sum    <span class="keyword">uint32</span></span><br><span class="line">length <span class="keyword">int</span> = <span class="built_in">len</span>(data)</span><br><span class="line">index  <span class="keyword">int</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">for</span> length &gt; <span class="number">1</span> &#123;</span><br><span class="line">sum += <span class="keyword">uint32</span>(data[index])&lt;&lt;<span class="number">8</span> + <span class="keyword">uint32</span>(data[index+<span class="number">1</span>])</span><br><span class="line">index += <span class="number">2</span></span><br><span class="line">length -= <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> length &gt; <span class="number">0</span> &#123;</span><br><span class="line">sum += <span class="keyword">uint32</span>(data[index])</span><br><span class="line">&#125;</span><br><span class="line">sum += (sum &gt;&gt; <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">uint16</span>(^sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是Ping的Request过程，这里仿照Windows的ping，默认只进行4次：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"\n正在 Ping %s 具有 0 字节的数据:\n"</span>, raddr.String())</span><br><span class="line">recv := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">statistic := list.New()</span><br><span class="line">sended_packets := <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">4</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _, err := conn.Write(buffer.Bytes()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err.Error())</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">sended_packets++</span><br><span class="line">t_start := time.Now()</span><br><span class="line"></span><br><span class="line">conn.SetReadDeadline((time.Now().Add(time.Second * <span class="number">5</span>)))</span><br><span class="line">_, err := conn.Read(recv)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"请求超时"</span>)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t_end := time.Now()</span><br><span class="line"></span><br><span class="line">dur := t_end.Sub(t_start).Nanoseconds() / <span class="number">1e6</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"来自 %s 的回复: 时间 = %dms\n"</span>, raddr.String(), dur)</span><br><span class="line"></span><br><span class="line">statistic.PushBack(dur)</span><br><span class="line"></span><br><span class="line"><span class="comment">//for i := 0; i &lt; recvsize; i++ &#123;</span></span><br><span class="line"><span class="comment">//if i%16 == 0 &#123;</span></span><br><span class="line"><span class="comment">//fmt.Println("")</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//fmt.Printf("%.2x ", recv[i])</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//fmt.Println("")</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“具有0字节的数据”表示ICMP报文中没有数据字段，这和Windows里面32字节的数据的略有不同。</p><p>conn.Write方法执行之后也就发送了一条ICMP请求，同时进行计时和计次。</p><p>conn.SetReadDeadline可以在未收到数据的指定时间内停止Read等待，并返回错误err，然后判定请求超时。否则，收到回应后，计算来回所用时间，并放入一个list方便后续统计。</p><p>注释部分内容是我在探索返回数据时的代码，读者可以试试看Read到的数据是哪个数据包的？</p><p>统计工作将在循环结束时进行，这里使用了defer其实是希望按了Ctrl+C之后能return执行，但是控制台确实不给力，直接给杀掉了。。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">""</span>)</span><br><span class="line"><span class="comment">//信息统计</span></span><br><span class="line"><span class="keyword">var</span> min, max, sum <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">if</span> statistic.Len() == <span class="number">0</span> &#123;</span><br><span class="line">min, max, sum = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">min, max, sum = statistic.Front().Value.(<span class="keyword">int64</span>), statistic.Front().Value.(<span class="keyword">int64</span>), <span class="keyword">int64</span>(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> v := statistic.Front(); v != <span class="literal">nil</span>; v = v.Next() &#123;</span><br><span class="line"></span><br><span class="line">val := v.Value.(<span class="keyword">int64</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> val &lt; min:</span><br><span class="line">min = val</span><br><span class="line"><span class="keyword">case</span> val &gt; max:</span><br><span class="line">max = val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum = sum + val</span><br><span class="line">&#125;</span><br><span class="line">recved, losted := statistic.Len(), sended_packets-statistic.Len()</span><br><span class="line">fmt.Printf(<span class="string">"%s 的 Ping 统计信息：\n  数据包：已发送 = %d，已接收 = %d，丢失 = %d (%.1f%% 丢失)，\n往返行程的估计时间(以毫秒为单位)：\n  最短 = %dms，最长 = %dms，平均 = %.0fms\n"</span>,</span><br><span class="line">raddr.String(),</span><br><span class="line">sended_packets, recved, losted, <span class="keyword">float32</span>(losted)/<span class="keyword">float32</span>(sended_packets)*<span class="number">100</span>,</span><br><span class="line">min, max, <span class="keyword">float32</span>(sum)/<span class="keyword">float32</span>(recved),</span><br><span class="line">)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>统计过程注意类型的转换和格式化就行了。</p><p>全部代码就这些，执行结果大概是这个样子的：</p><p><img src="173508_b4Xw_580940.png" alt=""></p><p>注意每次Ping后都没有”休息”，不像Windows或者Linux的会停顿几秒再Ping下一轮。</p><h2 id="收尾"><a href="#收尾" class="headerlink" title="收尾"></a>收尾</h2><p>Golang实现整个Ping比我想象中的还要简单很多，静态编译速度是十分快速，相比C而言，你需要更多得了解底层，甚至要从链路层开始，你需要写更多更复杂的代码来完成相同的工作，但究其根本，C语言仍然是鼻祖，功不可没，很多原理和思想都要继承和发展，这一点Golang做的很好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;关于各种语言实现Ping已经是大家喜闻乐见的事情了，网络上利用Golang实现Ping已经有比较详细的代码示例，但大多是仅仅是实现了Requ
      
    
    </summary>
    
    
      <category term="tech" scheme="https://apporz.com/tags/tech/"/>
    
      <category term="net" scheme="https://apporz.com/tags/net/"/>
    
      <category term="golang" scheme="https://apporz.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>关于蹭网检查的原理及实现</title>
    <link href="https://apporz.com/2014/08/02/network-rub-inspection/"/>
    <id>https://apporz.com/2014/08/02/network-rub-inspection/</id>
    <published>2014-08-01T16:00:00.000Z</published>
    <updated>2017-12-08T13:17:42.226Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>网络十分普及的现在,几乎每家每户都用上了无线局域网, 但也时常因为路由器密码泄露或破解被别人蹭网,加之WiFi 万能钥匙等软件的流行, 越来越多人加入了蹭网大军, 也给不少小型局域网用户带来了烦恼. 目前许多安全软件厂商都在推出检查蹭网的小程序, 通过这样的程序可以十分便捷的看到哪些设备在使用局域网, 从而及时发现和采取应对措施, 为广大用户弥补了损失. </p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>笔者手里正好有一款由nisoft发布的检查蹭网的小程序, 叫做Wireless Network Watcher, 软件免费试用, 文末将给出下载地址. 本文将针对该款软件做分析. 其次是WireShark协议分析工具, 这个软件很常见, 感兴趣的话可以百度下载. </p><p>笔者的系统仍然是Windows8.1 Pro.</p><p>操作步骤</p><p>1.打开Wireless Network Watcher, 在Advanced Options中设置合适的Network adapter(可能含有其他网络设备的网段), 笔者主机所在网段是192.168.199.*</p><p>2.打开WireShark,选择合适的网卡然后启动监控</p><p>3.启动Wireless Network Watcher的扫描</p><p>4.等待扫描结束,然后停止两个软件</p><p>5.在WireShark中进行分析</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>从Wireless Network Watcher的扫描结果来看,除了Router之外还发现了3个设备,一个是我的主机(Your Computer),一个是我的安卓手机,还有一个是HyFi智能无线路由器.</p><p><img src="094819_bH4F_580940.png" alt=""></p><p>此外,包括MAC地址在内的IP地址, 设备名称Device Name等等都获取到了.</p><p>从Wireshark的抓包结果来看, 大多数是ARP协议, 在ARP应答报文中可以得到对应在线主机的MAC地址, 程序在收到应答后有一个DNS反向解析动作, 在DNS应答中又可以得到设备的Device Name,而这个Device Name应该是存在Router中的. 过滤其他干扰协议保留ARP和DNS. 可以十分明显的发现ARP请求报文的 Target IP address是从网段中0开始,一直到255, 也就是说软件扫描了整个网段, 发送了256个ARP广播用来查找在线的主机, 然后通过得到的IP地址向路由器发送DNS反向解析请求,用来获取设备的名称.  如图所示:</p><p><img src="095528_SLfJ_580940.png" alt=""></p><p>这里先借一段关于ARP协议的百科:</p><blockquote><p>地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。其功能是：主机将ARP请求广播到网络上的所有主机，并接收返回消息，确定目标IP地址的物理地址，同时将IP地址和硬件地址存入本机ARP缓存中，下次请求时直接查询ARP缓存。地址解析协议是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记录在本地的ARP缓存中，这样攻击者就可以向目标主机发送伪ARP应答报文，使目标主机发送的信息无法到达相应的主机或到达错误的主机，构成一个ARP欺骗。ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等。</p><p>—- 百度百科</p></blockquote><p>通过这段引用可以了解到ARP协议的Request是一个广播,发送到网络上所有主机,然后接收应答.</p><p>关于DNS的工作原理可以参考我的另一篇文: 《利用WireShark进行DNS协议分析》</p><hr><p>现在让我们来分析一个ARP的请求和应答,以及一个DNS的请求和应答.</p><p>以第一个ARP为例:</p><p><img src="100636_zeua_580940.png" alt=""></p><p>第一个包是ARP请求,第二个是ARP应答,第三个是DNS请求,第四个是DNS应答,下面依次分析:</p><p><strong>1. ARP请求</strong></p><p><img src="101024_Bzhc_580940.png" alt=""></p><p>ARP请求的关键在于目标MAC尚未知道,因此全0,注意上层协议中的目标MAC是全f, 表示一个广播, 由于不同层的协议不同, 因此含义也不同. 请求解析的地址是192.168.199.1, opcode为 0x0001代表该ARP是一个Request. </p><p>ARP报文格式不在本文的讨论范围, 其本身也比较简单. 请读者自行百度.</p><p><strong>2. ARP应答</strong></p><p><img src="101615_4Mra_580940.png" alt=""></p><p>当ARP请求广播后, 收到请求的主机检查Target IP address是否和自己相同,相同就回应一个ARP, 注意此时不再是一个广播了,而是定向的回应发送者. Sender MAC address字段里放有我们希望得到的目标MAC地址.</p><p>主机得到来自192.168.199.1的应答后, 取出MAC并记下IP地址, 为后面的DNS反向解析做准备.</p><p>其实到此为止, 就探测到了一个在线的主机, 完成了关键的侦测任务, 下面的DNS是软件本身为了优化用户体验, 向路由器查询一下设备名称而已. 此外,如果广播出去的ARP一定时间内没有收到回应,说明所探测的主机不在线.</p><p><strong>3. DNS请求</strong></p><p><img src="102645_XXOZ_580940.png" alt=""></p><p>主机收到ARP回应后, 利用IP地址进行DNS反向解析, 注意查询IP字段在报文中是逆序存放的. 目的地是路由器.</p><p><strong>4. DNS应答</strong></p><p><img src="102907_mxkv_580940.png" alt=""></p><p>DNS应答报文中指出Domain Name是 Hiwifi.lan 这和软件上的Device Name一致.</p><hr><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>之前直接打算用boost的asio网络库来实现ARP的收发,搞了半天发现asio的rawsocket不能自定义实现这样的底层协议,网络上关于boost实现ARP的资料几乎没有,因此考虑了windows平台下的winpcap.</p><p>首先需要自己定义好arp以及ethernet报文(帧)的标准格式,为了简便起见,成员函数全部使用inline方式, 下面两个hpp分别定义了这两种格式:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ethernet_header.hpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ETHERNET_HEADER_HPP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETHERNET_HEADER_HPP</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;istream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mac_address.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Ethernet header </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The wire format of an Ethernet header is:</span></span><br><span class="line"><span class="comment">// 0                 5                 11    13</span></span><br><span class="line"><span class="comment">// +-----------------+-----------------+-----+</span></span><br><span class="line"><span class="comment">// |destination mac  |source mac       |type |</span></span><br><span class="line"><span class="comment">// |XX:XX:XX:XX:XX:XX|YY:YY:YY:YY:YY:YY|ZZ:ZZ|</span></span><br><span class="line"><span class="comment">// +-----------------+-----------------+-----+</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ethernet_header</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">ethernet_header() &#123; <span class="built_in">std</span>::fill(rep_, rep_ + <span class="keyword">sizeof</span>(rep_), <span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dst</span><span class="params">(<span class="keyword">const</span> MacAddr &amp;mac_address)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mac_address.size(); ++i) &#123;</span><br><span class="line">rep_[<span class="number">0</span> + i] = mac_address[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">src</span><span class="params">(<span class="keyword">const</span> MacAddr &amp;mac_address)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mac_address.size(); ++i) &#123;</span><br><span class="line">rep_[<span class="number">6</span> + i] = mac_address[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">type</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> n)</span> </span>&#123; encode(<span class="number">12</span>, <span class="number">13</span>, n); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">MacAddr <span class="title">dst</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">MacAddr mac_address;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) &#123;</span><br><span class="line">mac_address.push_back(rep_[<span class="number">0</span> + i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mac_address;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">MacAddr <span class="title">src</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">MacAddr mac_address;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) &#123;</span><br><span class="line">mac_address.push_back(rep_[<span class="number">6</span> + i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mac_address;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> decode(<span class="number">12</span>, <span class="number">13</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">friend</span> <span class="built_in">std</span>::istream&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="built_in">std</span>::istream&amp; is, ethernet_header&amp; header)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> is.read(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(header.rep_), <span class="number">14</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; os, <span class="keyword">const</span> ethernet_header&amp; header)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> os.write(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(header.rep_), <span class="number">14</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="title">decode</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (rep_[a] &lt;&lt; <span class="number">8</span>) + rep_[b];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">encode</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">unsigned</span> <span class="keyword">short</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">rep_[a] = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(n &gt;&gt; <span class="number">8</span>);</span><br><span class="line">rep_[b] = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(n &amp; <span class="number">0xFF</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> rep_[<span class="number">14</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// ETHERNET_HEADER_HPP</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//arp_header.hpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ARP_HEADER_HPP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>ARP_HEADER_HPP</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;istream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mac_address.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ARP header</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The wire format of an ARP header is:</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 0               8               16                             31</span></span><br><span class="line"><span class="comment">// +-------------------------------+------------------------------+      ---</span></span><br><span class="line"><span class="comment">// |                               |                              |       ^</span></span><br><span class="line"><span class="comment">// |     Hardware type (HTYPE)     |    Protocol type (PTYPE)     |       |</span></span><br><span class="line"><span class="comment">// |                               |                              |       |</span></span><br><span class="line"><span class="comment">// +---------------+---------------+------------------------------+    4 bytes</span></span><br><span class="line"><span class="comment">// |               |               |                              |       ^</span></span><br><span class="line"><span class="comment">// |   Hard. len.  |  Proto. len.  |       Operation (OPER)       |       |</span></span><br><span class="line"><span class="comment">// |    (HLEN)     |    (PLEN)     |                              |       |</span></span><br><span class="line"><span class="comment">// +-------------------------------+------------------------------+    8 bytes</span></span><br><span class="line"><span class="comment">// |                                                              |       ^</span></span><br><span class="line"><span class="comment">// |                  Sender hardware address (SHA)               |       |</span></span><br><span class="line"><span class="comment">// |                                                              |       |</span></span><br><span class="line"><span class="comment">// +--------------------------------------------------------------+    14 bytes</span></span><br><span class="line"><span class="comment">// |                                                              |       ^</span></span><br><span class="line"><span class="comment">// |                  Sender protocol address (SPA)               |       |</span></span><br><span class="line"><span class="comment">// |                                                              |       |</span></span><br><span class="line"><span class="comment">// +--------------------------------------------------------------+    18 bytes</span></span><br><span class="line"><span class="comment">// |                                                              |       ^</span></span><br><span class="line"><span class="comment">// |                  Target hardware address (THA)               |       |</span></span><br><span class="line"><span class="comment">// |                                                              |       |</span></span><br><span class="line"><span class="comment">// +--------------------------------------------------------------+    24 bytes</span></span><br><span class="line"><span class="comment">// |                                                              |       ^</span></span><br><span class="line"><span class="comment">// |                  Target protocol address (TPA)               |       |</span></span><br><span class="line"><span class="comment">// |                                                              |       |</span></span><br><span class="line"><span class="comment">// +--------------------------------------------------------------+    28 bytes</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">arp_header</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">arp_header()&#123; <span class="built_in">std</span>::fill(rep_, rep_ + <span class="keyword">sizeof</span>(rep_), <span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//setter</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">htype</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> n)</span></span>&#123; encode(<span class="number">0</span>, <span class="number">1</span>, n); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ptype</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> n)</span></span>&#123; encode(<span class="number">2</span>, <span class="number">3</span>, n); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hsize</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> n)</span></span>&#123; rep_[<span class="number">4</span>] = n; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">psize</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> n)</span></span>&#123; rep_[<span class="number">5</span>] = n; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">opcode</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> n)</span></span>&#123; encode(<span class="number">6</span>, <span class="number">7</span>, n); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sha</span><span class="params">(<span class="keyword">const</span> MacAddr &amp; mac)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mac.size(); ++i)</span><br><span class="line">rep_[<span class="number">8</span> + i] = mac[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spa</span><span class="params">(<span class="keyword">const</span> boost::asio::ip::address_v4 &amp;address)</span></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> bytes = address.to_bytes();</span><br><span class="line">rep_[<span class="number">14</span>] = bytes[<span class="number">0</span>];</span><br><span class="line">rep_[<span class="number">15</span>] = bytes[<span class="number">1</span>];</span><br><span class="line">rep_[<span class="number">16</span>] = bytes[<span class="number">2</span>];</span><br><span class="line">rep_[<span class="number">17</span>] = bytes[<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tha</span><span class="params">(<span class="keyword">const</span> MacAddr&amp; mac)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mac.size(); ++i)</span><br><span class="line">rep_[<span class="number">18</span> + i] = mac[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tpa</span><span class="params">(<span class="keyword">const</span> boost::asio::ip::address_v4 &amp;address)</span></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> bytes = address.to_bytes();</span><br><span class="line">rep_[<span class="number">24</span>] = bytes[<span class="number">0</span>];</span><br><span class="line">rep_[<span class="number">25</span>] = bytes[<span class="number">1</span>];</span><br><span class="line">rep_[<span class="number">26</span>] = bytes[<span class="number">2</span>];</span><br><span class="line">rep_[<span class="number">27</span>] = bytes[<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//getter</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="title">htype</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> decode(<span class="number">0</span>, <span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="title">ptype</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> decode(<span class="number">2</span>, <span class="number">3</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">hsize</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> rep_[<span class="number">4</span>]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">psize</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> rep_[<span class="number">5</span>]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="title">opcode</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> decode(<span class="number">6</span>, <span class="number">7</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">MacAddr <span class="title">sha</span><span class="params">()</span><span class="keyword">const</span> </span>&#123;</span><br><span class="line">MacAddr mac;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">mac.push_back(rep_[<span class="number">8</span> + i]);</span><br><span class="line"><span class="keyword">return</span> mac;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boost::asio::ip::<span class="function">address_v4 <span class="title">spa</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">boost::asio::ip::address_v4::bytes_type bytes</span><br><span class="line">= &#123;rep_[<span class="number">14</span>], rep_[<span class="number">15</span>], rep_[<span class="number">16</span>], rep_[<span class="number">17</span>]&#125;;</span><br><span class="line"><span class="keyword">return</span> boost::asio::ip::address_v4(bytes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">MacAddr <span class="title">tha</span><span class="params">()</span><span class="keyword">const</span></span>&#123;</span><br><span class="line">MacAddr mac;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i)</span><br><span class="line">mac.push_back(rep_[<span class="number">18</span> + i]);</span><br><span class="line"><span class="keyword">return</span> mac;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boost::asio::ip::<span class="function">address_v4 <span class="title">tpa</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">boost::asio::ip::address_v4::bytes_type bytes</span><br><span class="line">= &#123;rep_[<span class="number">24</span>], rep_[<span class="number">25</span>], rep_[<span class="number">26</span>], rep_[<span class="number">27</span>]&#125;;</span><br><span class="line"><span class="keyword">return</span> boost::asio::ip::address_v4(bytes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//overloads</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">friend</span> <span class="built_in">std</span>::istream&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="built_in">std</span>::istream&amp; is, arp_header&amp; header)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> is.read(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(header.rep_), <span class="number">28</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; os, <span class="keyword">const</span> arp_header&amp; header)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> os.write(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(header.rep_), <span class="number">28</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">encode</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">unsigned</span> <span class="keyword">short</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">rep_[a] = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(n &gt;&gt; <span class="number">8</span>);<span class="comment">//取出高8位</span></span><br><span class="line">rep_[b] = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(n &amp; <span class="number">0xff</span>);<span class="comment">//取出低8位</span></span><br><span class="line"><span class="comment">//相当于转换字节序,把小端格式转换为网络字节序</span></span><br><span class="line"><span class="comment">//例如 数 0x1234 在小端模式(Little-endian)中表示为:</span></span><br><span class="line"><span class="comment">//低地址----&gt;高地址</span></span><br><span class="line"><span class="comment">//34         12</span></span><br><span class="line"><span class="comment">//网络序,大端模式(Big-endian)应该是:</span></span><br><span class="line"><span class="comment">//12         34</span></span><br><span class="line"><span class="comment">//该函数实现这个功能</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="title">decode</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (rep_[a] &lt;&lt; <span class="number">8</span>) + rep_[b];</span><br><span class="line"><span class="comment">//这个就是encode的反函数,把两个字节倒过来返回</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> rep_[<span class="number">28</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// ARP_HEADER_HPP</span></span></span><br></pre></td></tr></table></figure><p>关于主机字节序(本例为小端)和网络字节序(大端)的转换过程可以参考上面代码中的注释.</p><p>实在贴不下这么多代码了,主函数代码包括所有本文涉及的hpp源代码请见下面的代码分享链接.</p><p>由于时间仓促,代码仅供学习交流,有很多遗留的问题尚未解决,但并不影响大家对整个实现过程的理解</p><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="175051_JQJJ_580940.png" alt=""></p><p>程序将扫描定义好的整个ip区段,发送ARP广播,然后接收响应,列出目标的MAC地址.具体实现请看下面的代码分享.</p><h2 id="代码分享"><a href="#代码分享" class="headerlink" title="代码分享"></a>代码分享</h2><p><a href="http://www.oschina.net/code/snippet_580940_37722" target="_blank" rel="noopener">http://www.oschina.net/code/snippet_580940_37722</a></p><h2 id="相关下载"><a href="#相关下载" class="headerlink" title="相关下载"></a>相关下载</h2><p><a href="http://www.nirsoft.net/utils/wireless_network_watcher.html" target="_blank" rel="noopener">Wireless Network Watcher</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;网络十分普及的现在,几乎每家每户都用上了无线局域网, 但也时常因为路由器密码泄露或破解被别人蹭网,加之WiFi 万能钥匙等软件的流行, 越来
      
    
    </summary>
    
    
      <category term="tech" scheme="https://apporz.com/tags/tech/"/>
    
      <category term="cpp" scheme="https://apporz.com/tags/cpp/"/>
    
      <category term="net" scheme="https://apporz.com/tags/net/"/>
    
      <category term="wireshark" scheme="https://apporz.com/tags/wireshark/"/>
    
  </entry>
  
</feed>
