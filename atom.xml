<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Micooz</title>
  
  <subtitle>Make something different!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://apporz.com/"/>
  <updated>2018-04-13T12:14:00.523Z</updated>
  <id>https://apporz.com/</id>
  
  <author>
    <name>Micooz Lee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于 EventEmitter 的双向数据 pipeline 实现</title>
    <link href="https://apporz.com/2018/04/14/implement-eventemitter-pipline/"/>
    <id>https://apporz.com/2018/04/14/implement-eventemitter-pipline/</id>
    <published>2018-04-14T08:30:00.000Z</published>
    <updated>2018-04-13T12:14:00.523Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于-EventEmitter-的双向数据-pipeline-实现"><a href="#基于-EventEmitter-的双向数据-pipeline-实现" class="headerlink" title="基于 EventEmitter 的双向数据 pipeline 实现"></a>基于 EventEmitter 的双向数据 pipeline 实现</h1><h2 id="想法来源"><a href="#想法来源" class="headerlink" title="想法来源"></a>想法来源</h2><h2 id="Gulp"><a href="#Gulp" class="headerlink" title="Gulp"></a>Gulp</h2><p>Gulp 是前端工具链中常用的流式任务执行器，适用于许多小型库的编译打包任务。它的设计思想其实很像 Linux 命令行里面的 Pipe（管道）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gulp.src(paths.scripts.src, &#123; <span class="attr">sourcemaps</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">    .pipe(babel())</span><br><span class="line">    .pipe(uglify())</span><br><span class="line">    .pipe(concat(<span class="string">'main.min.js'</span>))</span><br><span class="line">    .pipe(gulp.dest(paths.scripts.dest));</span><br></pre></td></tr></table></figure><p>gulp 是单向的，即对于同一个 pipeline，数据一般不能被逆向还原。</p><h2 id="TCP-IP-stack"><a href="#TCP-IP-stack" class="headerlink" title="TCP/IP stack"></a>TCP/IP stack</h2><p>我们知道，计算机网络协议是<strong>分层设计</strong>的，每层分别为数据赋予不同的含义、完成不同的使命。源主机采用网络协议栈将原始二进制流 <strong>层层编码（encode）</strong> 后送往目的主机，目的主机采用同样的协议栈将数据 <strong>层层解码（decode）</strong> 后得到原始数据。典型的 HTTP 协议将请求数据通过 TCP/IP 协议栈自上而下编码后送出，之后自下而上解码后得到响应数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">                                                      +---------+</span><br><span class="line">                                                      | &quot;Hello&quot; |</span><br><span class="line">                                                      +---------+</span><br><span class="line">                                        +-------------+---------+</span><br><span class="line">                                        | HTTP header | PAYLOAD |</span><br><span class="line">                                        +-------------+---------+   </span><br><span class="line">                           +------------+-----------------------+</span><br><span class="line">                           | TCP header |         PAYLOAD       |</span><br><span class="line">                           +------------+-----------------------+</span><br><span class="line">              +------------+------------------------------------+</span><br><span class="line">              | IP header  |              PAYLOAD               |</span><br><span class="line">              +------------+------------------------------------+</span><br><span class="line">+------------+--------------------------------------------------+</span><br><span class="line">| Eth header |                      PAYLOAD                     |</span><br><span class="line">+------------+--------------------------------------------------+</span><br></pre></td></tr></table></figure><p>TCP/IP 协议栈是双向的，即对于同一套协议，数据既可以被编码也可以被解码。</p><p>那么问题来了，是否可以抽象一种轻量的 Pipeline，实现类似网络协议栈双向数据流的处理能力，并且能够让用户定制化每层的处理逻辑？</p><h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h2><p>设计之前，先根据数据流划分功能模块，这里 <code>PIPE</code> 是数据和各个数据处理单元的调度者，<code>PIPE_UNIT_x</code> 是每层数据的处理单元，可以有多个，并且按顺序前后<strong>串联</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">                +------------------ PIPE -------------------+</span><br><span class="line">[RAW_DATA] &lt;==&gt; | [PIPE_UNIT_1] &lt;==&gt; ... &lt;==&gt; [PIPE_UNIT_2] | &lt;==&gt; [ENCODED_DATA]</span><br><span class="line">                +-------------------------------------------+</span><br></pre></td></tr></table></figure><p>用户可以实现自己的 <code>PIPE_UNIT</code> 来达到定制化处理逻辑的功能，也可以任意调换 <code>PIPE_UNIT</code> 的顺序来达到不同的处理效果。</p><h2 id="Pipe-设计"><a href="#Pipe-设计" class="headerlink" title="Pipe 设计"></a>Pipe 设计</h2><p><code>Pipe</code> 需要提供一个数据入口来启动链式处理流程：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PIPE_TYPE_ENCODE = <span class="string">'PIPE_TYPE_ENCODE'</span>;</span><br><span class="line"><span class="keyword">const</span> PIPE_TYPE_DECODE = <span class="string">'PIPE_TYPE_DECODE'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pipe</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造 Pipe 时，传入的处理单元数组约定为 encode 顺序</span></span><br><span class="line">  <span class="keyword">constructor</span>(units) &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>._encode_units = units;</span><br><span class="line">    <span class="keyword">this</span>._decode_units = [].concat(units).reverse();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 数据处理入口</span></span><br><span class="line">  feed(type, data) &#123;</span><br><span class="line">    <span class="keyword">const</span> units = type === PIPE_TYPE_ENCODE ? <span class="keyword">this</span>._encode_units : <span class="keyword">this</span>._decode_units;</span><br><span class="line">    <span class="keyword">if</span> (units.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> first = units[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (first.listenerCount(type) &lt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// 构建链式响应逻辑</span></span><br><span class="line">      <span class="keyword">const</span> last = units.reduce(<span class="function">(<span class="params">prev, next</span>) =&gt;</span> &#123;</span><br><span class="line">        prev.on(type, (dt) =&gt; next._write(type, dt));</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">      &#125;);</span><br><span class="line">      last.on(type, (dt) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 最后一个 unit 完成之后 feed 的任务就结束了</span></span><br><span class="line">        <span class="keyword">this</span>.emit(type, dt);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 触发处理流程</span></span><br><span class="line">    first._write(type, data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PipeUnit-接口设计"><a href="#PipeUnit-接口设计" class="headerlink" title="PipeUnit 接口设计"></a>PipeUnit 接口设计</h2><p><code>PipeUnit</code> 需要暴露编码（encode）和解码（decode）两个接口，考虑到处理单元可能异步执行，因此使用 <code>async</code> 黑膜法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PipeUnit</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> _write(type, data) &#123;</span><br><span class="line">    <span class="keyword">if</span> (type === PIPE_TYPE_ENCODE) &#123;</span><br><span class="line">      <span class="keyword">this</span>.emit(type, <span class="keyword">await</span> <span class="keyword">this</span>.encode(data));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.emit(type, <span class="keyword">await</span> <span class="keyword">this</span>.decode(data));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 编码接口</span></span><br><span class="line">  <span class="keyword">async</span> encode(data) &#123;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解码接口</span></span><br><span class="line">  <span class="keyword">async</span> decode(data) &#123;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现-PipeUnit"><a href="#实现-PipeUnit" class="headerlink" title="实现 PipeUnit"></a>实现 PipeUnit</h2><p>首先实现一个提供压缩、解压缩功能的 <code>PipeUnit</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> zlib = <span class="built_in">require</span>(<span class="string">'zlib'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZipPipeUnit</span> <span class="keyword">extends</span> <span class="title">PipeUnit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> encode(data) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'ZipPipeUnit::encode &lt;-'</span>, data);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      zlib.deflate(data, (err, buffer) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          reject(err);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          resolve(buffer);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> decode(data) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'ZipPipeUnit::decode &lt;-'</span>, data);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      zlib.unzip(data, (err, buffer) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          reject(err);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          resolve(buffer);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面再实现一个提供 <code>AES</code> 对称加解密功能的 <code>PipeUnit</code>，这次采用同步执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CryptoPipeUnit</span> <span class="keyword">extends</span> <span class="title">PipeUnit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 编码实现</span></span><br><span class="line">  encode(plaintext) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'CryptoPipeUnit::encode &lt;-'</span>, plaintext);</span><br><span class="line">    <span class="keyword">const</span> cipher = crypto.createCipher(<span class="string">'aes192'</span>, <span class="string">'a password'</span>);</span><br><span class="line">    <span class="keyword">const</span> encrypted = cipher.update(plaintext);</span><br><span class="line">    <span class="keyword">return</span> Buffer.concat([encrypted, cipher.final()]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解码实现</span></span><br><span class="line">  decode(ciphertext) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'CryptoPipeUnit::decode &lt;-'</span>, ciphertext);</span><br><span class="line">    <span class="keyword">const</span> decipher = crypto.createDecipher(<span class="string">'aes192'</span>, <span class="string">'a password'</span>);</span><br><span class="line">    <span class="keyword">const</span> decrypted = decipher.update(ciphertext);</span><br><span class="line">    <span class="keyword">return</span> Buffer.concat([decrypted, decipher.final()]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实际运行"><a href="#实际运行" class="headerlink" title="实际运行"></a>实际运行</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自由组合处理单元</span></span><br><span class="line"><span class="keyword">const</span> units = [</span><br><span class="line">  <span class="keyword">new</span> ZipPipeUnit(),</span><br><span class="line">  <span class="keyword">new</span> CryptoPipeUnit(),</span><br><span class="line">  <span class="comment">// new CryptoPipeUnit(), // 再来一个也可以</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 来一个 pipe 对象</span></span><br><span class="line"><span class="keyword">const</span> pipe = <span class="keyword">new</span> Pipe(units);</span><br><span class="line"></span><br><span class="line">pipe.on(PIPE_TYPE_ENCODE, (data) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'encoded:'</span>, data);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">''</span>);</span><br><span class="line">  <span class="comment">// 解码</span></span><br><span class="line">  pipe.feed(PIPE_TYPE_DECODE, data);</span><br><span class="line">&#125;);</span><br><span class="line">pipe.on(PIPE_TYPE_DECODE, (data) =&gt; <span class="built_in">console</span>.log(<span class="string">'decoded:'</span>, data.toString()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编码</span></span><br><span class="line">pipe.feed(PIPE_TYPE_ENCODE, Buffer.from(<span class="string">'awesome nodejs'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出如下:</span></span><br><span class="line"><span class="comment">// ZipPipeUnit::encode &lt;- &lt;Buffer 61 77 65 73 6f 6d 65 20 6e 6f 64 65 6a 73&gt;</span></span><br><span class="line"><span class="comment">// CryptoPipeUnit::encode &lt;- &lt;Buffer 78 9c 4b 2c 4f 2d ce cf 4d 55 c8 cb 4f 49 cd 2a 06 00 2a 0c 05 95&gt;</span></span><br><span class="line"><span class="comment">// encoded: &lt;Buffer a9 61 bc 37 1a 4c 41 e8 20 63 d2 90 86 94 7b 48 98 b1 91 16 84 66 58 9b 6d 88 53 da 9b b9 18 fb&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CryptoPipeUnit::decode &lt;- &lt;Buffer a9 61 bc 37 1a 4c 41 e8 20 63 d2 90 86 94 7b 48 98 b1 91 16 84 66 58 9b 6d 88 53 da 9b b9 18 fb&gt;</span></span><br><span class="line"><span class="comment">// ZipPipeUnit::decode &lt;- &lt;Buffer 78 9c 4b 2c 4f 2d ce cf 4d 55 c8 cb 4f 49 cd 2a 06 00 2a 0c 05 95&gt;</span></span><br><span class="line"><span class="comment">// decoded: awesome nodejs</span></span><br></pre></td></tr></table></figure><p>可以看到，通过对 EventEmitter 简单的封装就可以实现双向数据 pipeline，同时支持异步单元操作。</p><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>功能实现了，性能又如何呢？抛开 <code>PipeUnit</code> 的业务实现，简单分析一下链式 EventEmitter 结构的性能影响因素，理论上很大程度取决于 EventEmitter 本身的性能，<code>Pipe::feed</code> 只在第一次被调用时构建响应链，之后的调用几乎不会有性能损失。</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><p>Node.js 版本如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; process.versions</span><br><span class="line">&#123; http_parser: &apos;2.8.0&apos;,</span><br><span class="line">  node: &apos;9.11.1&apos;,</span><br><span class="line">  v8: &apos;6.2.414.46-node.23&apos;,</span><br><span class="line">  uv: &apos;1.19.2&apos;,</span><br><span class="line">  zlib: &apos;1.2.11&apos;,</span><br><span class="line">  ares: &apos;1.13.0&apos;,</span><br><span class="line">  modules: &apos;59&apos;,</span><br><span class="line">  nghttp2: &apos;1.29.0&apos;,</span><br><span class="line">  napi: &apos;3&apos;,</span><br><span class="line">  openssl: &apos;1.0.2o&apos;,</span><br><span class="line">  icu: &apos;61.1&apos;,</span><br><span class="line">  unicode: &apos;10.0&apos;,</span><br><span class="line">  cldr: &apos;33.0&apos;,</span><br><span class="line">  tz: &apos;2018c&apos; &#125;</span><br></pre></td></tr></table></figure><p>下面分别考察 0 ~ 30000（每次递增 1000） 个 <code>PipeUnit</code> 实例的执行时间，来评估上述设计的性能表现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; performance &#125; = <span class="built_in">require</span>(<span class="string">'perf_hooks'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> payload = Buffer.alloc(<span class="number">4096</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= <span class="number">30</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> units = <span class="built_in">Array</span>(i * <span class="number">1000</span>).fill().map(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> PipeUnit());</span><br><span class="line"></span><br><span class="line">  performance.mark(<span class="string">'A_'</span> + i);</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">const</span> pipe = <span class="keyword">new</span> Pipe(units);</span><br><span class="line">    pipe.on(PIPE_TYPE_ENCODE, (data) =&gt; &#123;</span><br><span class="line">      pipe.feed(PIPE_TYPE_DECODE, data);</span><br><span class="line">    &#125;);</span><br><span class="line">    pipe.on(PIPE_TYPE_DECODE, () =&gt; <span class="literal">null</span>);</span><br><span class="line">    pipe.feed(PIPE_TYPE_ENCODE, payload);</span><br><span class="line">  &#125;</span><br><span class="line">  performance.mark(<span class="string">'B_'</span> + i);</span><br><span class="line"></span><br><span class="line">  performance.measure(<span class="string">`<span class="subst">$&#123;units.length&#125;</span> units`</span>, <span class="string">'A_'</span> + i, <span class="string">'B_'</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> entries = performance.getEntriesByType(<span class="string">'measure'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> &#123; name, duration &#125; <span class="keyword">of</span> entries) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;name&#125;</span>: <span class="subst">$&#123;duration&#125;</span>ms`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行4次，可以将结果绘制到一张图中：</p><p><img src="performance.png" alt=""></p><p>可以看到每次运行的结果高度一致，由上万个 <code>PipeUnit</code> 构成的链式 EventEmitter 能够以令人满意的效率完成运行。</p><p>不过出人意料的是，在特定数量的 <code>PipeUnit</code> 上总会出现尖峰，这可能和 V8 引擎的优化机制有关，作者能力有限，感兴趣的同学可以深挖原因。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基于-EventEmitter-的双向数据-pipeline-实现&quot;&gt;&lt;a href=&quot;#基于-EventEmitter-的双向数据-pipeline-实现&quot; class=&quot;headerlink&quot; title=&quot;基于 EventEmitter 的双向数据 pipe
      
    
    </summary>
    
    
      <category term="tech" scheme="https://apporz.com/tags/tech/"/>
    
      <category term="eventemitter" scheme="https://apporz.com/tags/eventemitter/"/>
    
      <category term="nodejs" scheme="https://apporz.com/tags/nodejs/"/>
    
      <category term="pipeline" scheme="https://apporz.com/tags/pipeline/"/>
    
  </entry>
  
  <entry>
    <title>高效加载 WebAssembly 模块</title>
    <link href="https://apporz.com/2018/04/13/loading-webassembly-modules-efficiently/"/>
    <id>https://apporz.com/2018/04/13/loading-webassembly-modules-efficiently/</id>
    <published>2018-04-13T03:50:00.000Z</published>
    <updated>2018-04-13T12:13:17.897Z</updated>
    
    <content type="html"><![CDATA[<h1 id="【译文】高效加载-WebAssembly-模块"><a href="#【译文】高效加载-WebAssembly-模块" class="headerlink" title="【译文】高效加载 WebAssembly 模块"></a>【译文】高效加载 WebAssembly 模块</h1><blockquote><p>原文作者：Mathias Bynens<br>原文地址：<a href="https://developers.google.com/web/updates/2018/04/loading-wasm" target="_blank" rel="noopener">https://developers.google.com/web/updates/2018/04/loading-wasm</a></p></blockquote><p>在使用 WebAssembly 的时候，通常需要下载、编译、实例化一个模块，然后通过 JavaScript 调用由该模块导出的一些东西。这篇文章从一个常见但不是很优秀的代码片段开始，讨论几种可能的优化方法，最后得出最简单、最高效的通过 JavaScript 运行 WebAssembly 的方法。</p><blockquote><p>注意：诸如 Emscripten 的一些工具可以为你准备样板代码，因此你不需要自己编写 wasm 代码。如果你要更加细粒度地控制 WebAssembly 模块加载，那么请专注于下面的最佳实践吧。</p></blockquote><p>下面的代码片段完成了下载-编译-实例化的整个过程，尽管不是很优秀的方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 别这么做</span></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">'fibonacci.wasm'</span>);</span><br><span class="line">  <span class="keyword">const</span> buffer = <span class="keyword">await</span> response.arrayBuffer();</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">module</span> = <span class="keyword">new</span> WebAssembly.Module(buffer);</span><br><span class="line">  <span class="keyword">const</span> instance = <span class="keyword">new</span> WebAssembly.Instance(<span class="built_in">module</span>);</span><br><span class="line">  <span class="keyword">const</span> result = instance.exports.fibonacci(<span class="number">42</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>注意我们是如何使用 <code>new WebAssembly.Module(buffer)</code> 将响应数据转换成一个模块的。这是一个同步 API，意味着它在完成之前会阻塞主线程。为了防止滥用，Chrome 禁止在超过 4KB 的 buffer 上使用 <code>WebAssembly.Module</code>。为了避免大小限制，我们可以用 <code>await WebAssembly.compile(buffer)</code> 来代替：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">'fibonacci.wasm'</span>);</span><br><span class="line">  <span class="keyword">const</span> buffer = <span class="keyword">await</span> response.arrayBuffer();</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">module</span> = <span class="keyword">await</span> WebAssembly.compile(buffer);</span><br><span class="line">  <span class="keyword">const</span> instance = <span class="keyword">new</span> WebAssembly.Instance(<span class="built_in">module</span>);</span><br><span class="line">  <span class="keyword">const</span> result = instance.exports.fibonacci(<span class="number">42</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p><code>await WebAssembly.compile(buffer)</code> 仍然不是一个优秀的方式，不过姑且先这样。</p><p>在修改后的代码片段中，几乎所有的操作都是异步的，因为 <code>await</code> 使之变得很清晰。只有 <code>new WebAssembly.Instance(module)</code> 是个例外。为了一致性，我们可以用异步 <code>WebAssembly.instantiate(module)</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">'fibonacci.wasm'</span>);</span><br><span class="line">  <span class="keyword">const</span> buffer = <span class="keyword">await</span> response.arrayBuffer();</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">module</span> = <span class="keyword">await</span> WebAssembly.compile(buffer);</span><br><span class="line">  <span class="keyword">const</span> instance = <span class="keyword">await</span> WebAssembly.instantiate(<span class="built_in">module</span>);</span><br><span class="line">  <span class="keyword">const</span> result = instance.exports.fibonacci(<span class="number">42</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>让我们回顾一下我之前提到的对于 <code>compile</code> 的优化。利用 <a href="https://v8project.blogspot.com/2018/02/v8-release-65.html" target="_blank" rel="noopener">流式编译</a>，浏览器可以在模块数据下载过程中就开始编译 WebAssembly 模块。因为下载和编译过程是并发的，特别是对于大模块，这样将会更快。</p><p><img src="streaming.png" alt=""></p><p>使用 <code>WebAssembly.compileStreaming</code> 替换 <code>WebAssembly.compile</code> 可以开启这个功能。这么做之后还可以避免产生中间数据，因为现在我们可以直接传递由 <code>await fetch(url)</code> 返回的 <code>Response</code> 实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">'fibonacci.wasm'</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">module</span> = <span class="keyword">await</span> WebAssembly.compileStreaming(response);</span><br><span class="line">  <span class="keyword">const</span> instance = <span class="keyword">await</span> WebAssembly.instantiate(<span class="built_in">module</span>);</span><br><span class="line">  <span class="keyword">const</span> result = instance.exports.fibonacci(<span class="number">42</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><blockquote><p>注意：服务端必须经过配置能够支持以 <strong>Content-Type: application/wasm</strong> 头发送 <strong>.wasm</strong> 文件。在之前的例子中，我们将响应数据当做 arraybuffer 传递，因此不需要进行 MIME 类型检查。</p></blockquote><p><code>WebAssembly.compileStreaming</code> API 也能接收一个 resolve 为 <code>Response</code> 的 promise 实例。如果你没在别的地方使用 <code>response</code>，你可以直接传递由 <code>fetch</code> 返回的 promise 对象，而不需要 <code>await</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> fetchPromise = fetch(<span class="string">'fibonacci.wasm'</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">module</span> = <span class="keyword">await</span> WebAssembly.compileStreaming(fetchPromise);</span><br><span class="line">  <span class="keyword">const</span> instance = <span class="keyword">await</span> WebAssembly.instantiate(<span class="built_in">module</span>);</span><br><span class="line">  <span class="keyword">const</span> result = instance.exports.fibonacci(<span class="number">42</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>如果你也没在其他地方使用 <code>fetch</code> 的结果，你甚至也可以直接传递它：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">module</span> = <span class="keyword">await</span> WebAssembly.compileStreaming(</span><br><span class="line">    fetch(<span class="string">'fibonacci.wasm'</span>));</span><br><span class="line">  <span class="keyword">const</span> instance = <span class="keyword">await</span> WebAssembly.instantiate(<span class="built_in">module</span>);</span><br><span class="line">  <span class="keyword">const</span> result = instance.exports.fibonacci(<span class="number">42</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>我个人认为将其单独成行可读性更好。</p><p>想知道我们是如何将响应数据编译为模块然后实例化的？事实证明，<code>WebAssembly.instantiate</code> 可以一步到位。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> fetchPromise = fetch(<span class="string">'fibonacci.wasm'</span>);</span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="built_in">module</span>, instance &#125; = <span class="keyword">await</span> WebAssembly.instantiateStreaming(fetchPromise);</span><br><span class="line">  <span class="comment">// 稍后创建 instance 对象:</span></span><br><span class="line">  <span class="keyword">const</span> otherInstance = <span class="keyword">await</span> WebAssembly.instantiate(<span class="built_in">module</span>); </span><br><span class="line">  <span class="keyword">const</span> result = instance.exports.fibonacci(<span class="number">42</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>如果你只需要 instance 对象，那没理由再保留 module 对象，简化代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是加载 WebAssembly 的建议方式。</span></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> fetchPromise = fetch(<span class="string">'fibonacci.wasm'</span>);</span><br><span class="line">  <span class="keyword">const</span> &#123; instance &#125; = <span class="keyword">await</span> WebAssembly.instantiateStreaming(fetchPromise);</span><br><span class="line">  <span class="keyword">const</span> result = instance.exports.fibonacci(<span class="number">42</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>总结一下我们所用过的优化方法：</p><ul><li>使用异步 API 来避免阻塞主线程</li><li>使用流式 API 来加快 WebAssembly 模块的编译和实例化速度</li><li>不要写你不需要的代码</li></ul><p>尽情享用 WebAssembly 吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;【译文】高效加载-WebAssembly-模块&quot;&gt;&lt;a href=&quot;#【译文】高效加载-WebAssembly-模块&quot; class=&quot;headerlink&quot; title=&quot;【译文】高效加载 WebAssembly 模块&quot;&gt;&lt;/a&gt;【译文】高效加载 WebAssem
      
    
    </summary>
    
    
      <category term="tech" scheme="https://apporz.com/tags/tech/"/>
    
      <category term="webassembly" scheme="https://apporz.com/tags/webassembly/"/>
    
  </entry>
  
  <entry>
    <title>React 16.3 Context API 实践</title>
    <link href="https://apporz.com/2018/03/12/react-16-3-context-api/"/>
    <id>https://apporz.com/2018/03/12/react-16-3-context-api/</id>
    <published>2018-03-11T16:00:00.000Z</published>
    <updated>2018-04-13T12:07:32.406Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React-16-3-Context-API-实践"><a href="#React-16-3-Context-API-实践" class="headerlink" title="React 16.3 Context API 实践"></a>React 16.3 Context API 实践</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文简单介绍了 Context API 的提出背景、API 设计和用法；之后比较了 React-Redux 的设计；然后提出了一种基于 Context API 的二次封装；最后再将二次封装和 mobx-react 进行了比较。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>React 项目组成员 <a href="https://github.com/acdlite" target="_blank" rel="noopener">@acdlite</a> 于 2017-12-05 提出关于新 Context API 的 <a href="https://github.com/reactjs/rfcs/pull/2" target="_blank" rel="noopener">RFC</a>。</p><p>实际上 Context 在 React 的早期版本中就已经存在，但不能解决当 <code>shouldComponentUpdate</code> 返回 <code>false</code> 时，组件无法响应 context 的改变的问题。由于 <code>shouldComponentUpdate</code> 常用于性能优化，被大量开源库或框架广泛使用，因此原版的 Context 变得十分鸡肋，新的 Context API 很好地解决了这一问题。</p><h2 id="Context-API"><a href="#Context-API" class="headerlink" title="Context API"></a>Context API</h2><p>首先安装 16.3.x 版本的 <code>react</code> 及 <code>react-dom</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn add react@next react-dom@next</span><br></pre></td></tr></table></figure><p>来看一个简单的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; createContext &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; Provider, Consumer &#125; = createContext(&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// const &#123; date &#125; = this.props;</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Consumer&gt;</span><br><span class="line">          <span class="comment">// 子组件在任意位置通过 &lt;Consumer&gt; 消费顶层给 &lt;Provider&gt; 传入的 value，</span></span><br><span class="line">          <span class="comment">// 感知 value 的变化来重新渲染该区块。</span></span><br><span class="line">          &#123;(&#123; date &#125;) =&gt; <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;date&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#125;</span><br><span class="line">        &lt;<span class="regexp">/Consumer&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  state = &#123;</span><br><span class="line">    date: <span class="string">''</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 在父组件中更新状态</span></span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>().toString() &#125;);</span><br><span class="line">    &#125;, <span class="number">1e3</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Provider value=&#123;<span class="keyword">this</span>.state&#125;&gt;</span><br><span class="line">        <span class="comment">// 父组件不用给子组件显式传入任何数据</span></span><br><span class="line">        &lt;Child/&gt;</span><br><span class="line">      &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;App/</span>&gt;, <span class="built_in">document</span>.querySelector(<span class="string">'#root'</span>));</span><br></pre></td></tr></table></figure><p>使用 Context API 最大的好处就是解决深层嵌套组件层层传递 props 的问题。但这样做也存在一个问题： state 的被保存在 <code>&lt;App&gt;</code> 中，更新状态时必须调用 <code>&lt;App&gt;</code> 的 <code>this.setState()</code>，如果子组件需要更新 <code>state</code>，那么需要通过 <code>&lt;Provider&gt;</code> 向下传递封装了 <code>this.setState()</code> 的回调函数:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;Provider value=&#123;&#123; </span><br><span class="line">  state: <span class="keyword">this</span>.state,</span><br><span class="line">  actions: &#123; </span><br><span class="line">    doSomething(newState) &#123; <span class="keyword">this</span>.setState(newState); &#125;</span><br><span class="line">  &#125;&#125;&#125;</span><br><span class="line">&gt;</span><br><span class="line">  &lt;Child/&gt;</span><br><span class="line">&lt;<span class="regexp">/Provider&gt;</span></span><br></pre></td></tr></table></figure><p>之后，子组件要求改变状态时，在 <code>&lt;Consumer&gt;</code> 中调用该回调方法即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Consumer&gt;</span><br><span class="line">  &#123;(&#123; <span class="attr">state</span>: &#123; date &#125;, actions &#125;) =&gt; </span><br><span class="line">    &lt;button onClick=&#123;() =&gt; actions.doSomething(...)&#125;&gt;&#123;date&#125;&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>Consumer&gt;</span><br></pre></td></tr></table></figure><p>另有一个问题是如何实现在 <strong>组件外</strong> 更新状态，让组件也能响应状态变化？</p><p>这样的需求通常在应用需要与第三方库交互时会遇到，举一个实际的例子：</p><p>Q: 一个 web 应用使用 websocket 做数据交换，我们需要在页面上<strong>实时显示</strong> websocket 连接的延迟：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ws.js</span></span><br><span class="line"><span class="keyword">const</span> ws = io.connect(<span class="string">'/'</span>);</span><br><span class="line"></span><br><span class="line">ws.on(<span class="string">'pong'</span>, (latency) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 如何将 latency 渲染到组件里？</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>先前例子中将 state 内化的方式显然不可行了，这个时候联想到 Redux，利用它全局 store 的设计，借助 <code>store.dispatch</code> 就可以实现上面的需求了。</p><h3 id="Redux-React-Redux"><a href="#Redux-React-Redux" class="headerlink" title="Redux/React-Redux"></a>Redux/React-Redux</h3><p><code>React-Redux</code> 是对 React 老版本 Context 的封装，它允许子组件通过 <code>connect</code> 方法建立对 store 中状态变化的响应，下面是一个简单的 Redux 应用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 reducer 来处理 action</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state = &#123; date: <span class="string">''</span> &#125;, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'UPDATE_DATE'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">date</span>: action.date &#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个全局 store 来存储状态</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 发一个 action 来更新 store</span></span><br><span class="line">      store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'UPDATE_DATE'</span>, <span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>().toString() &#125;);</span><br><span class="line">    &#125;, <span class="number">1e3</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">        <span class="comment">// 父组件不用给子组件显式传入任何数据</span></span><br><span class="line">        &lt;Child/&gt;</span><br><span class="line">      &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;App/</span>&gt;, <span class="built_in">document</span>.querySelector(<span class="string">'#root'</span>));</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// child.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapStateToProps</span>(<span class="params">state</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">date</span>: state.date &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 connect 来感知全局 store 的变化</span></span><br><span class="line">@connect(mapStateToProps, <span class="literal">null</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;&#123;<span class="keyword">this</span>.props.date&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>可以看到在 Redux 的套路中，完成一次 <code>状态更新</code> 需要 dispatch 一个 action 到 reducer，这个过程同时牵扯到三个概念，有些复杂；而在 Context API 的套路中，完成一次 <code>状态更新</code> 只需要 <code>setState(...)</code> 就够了，但单纯的 Context API 无法解决先前提到的 <strong>组件外</strong> 更新状态的问题。</p><h3 id="对-Context-API-的简单封装"><a href="#对-Context-API-的简单封装" class="headerlink" title="对 Context API 的简单封装"></a>对 Context API 的简单封装</h3><p>下面对 Context API 进行二次封装，让它支持类似 Redux 全局 store 的特性，但用法又比 Redux 更加简单。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// context.js</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; createContext &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> AppContext = createContext();</span><br><span class="line"></span><br><span class="line"><span class="comment">// self 是对 &lt;Provider&gt; 组件实例的引用</span></span><br><span class="line"><span class="keyword">let</span> self = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Provider</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  state = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    self = <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;AppContext.Provider value=&#123;<span class="keyword">this</span>.state&#125;&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.props.children&#125;</span><br><span class="line">      &lt;<span class="regexp">/AppContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const Consumer = AppContext.Consumer;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function getState() &#123;</span></span><br><span class="line"><span class="regexp">  if (self) &#123;</span></span><br><span class="line"><span class="regexp">    return self.state;</span></span><br><span class="line"><span class="regexp">  &#125; else &#123;</span></span><br><span class="line"><span class="regexp">    console.warn('cannot getState() because &lt;Provider&gt; is not initialized');</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function setState(...args) &#123;</span></span><br><span class="line"><span class="regexp">  if (self) &#123;</span></span><br><span class="line"><span class="regexp">    self.setState(...args);</span></span><br><span class="line"><span class="regexp">  &#125; else &#123;</span></span><br><span class="line"><span class="regexp">    console.warn('cannot setState() because &lt;Provider&gt; is not initialized');</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function createStore() &#123;</span></span><br><span class="line"><span class="regexp">  return &#123; getState, setState &#125;;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export &#123; Provider, Consumer, createStore &#125;;</span></span><br></pre></td></tr></table></figure><p>用法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Provider, Consumer, createStore &#125; <span class="keyword">from</span> <span class="string">'./context'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建一个全局 store</span></span><br><span class="line"><span class="keyword">const</span> store = createStore();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;<span class="number">1.</span> 通过回调参数获取最新状态&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Consumer&gt;</span></span><br><span class="line"><span class="regexp">          &#123;(&#123; date &#125;) =&gt; &lt;div&gt;&#123;date&#125;&lt;/</span>div&gt;&#125;</span><br><span class="line">        &lt;<span class="regexp">/Consumer&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p&gt;2. 通过 store.getState() 获取所有状态&lt;/</span>p&gt;</span><br><span class="line">        &lt;Consumer&gt;</span><br><span class="line">          &#123;() =&gt; <span class="xml"><span class="tag">&lt;<span class="name">pre</span>&gt;</span>&#123;JSON.stringify(store.getState(), null, 2)&#125;<span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span>&#125;</span><br><span class="line">        &lt;<span class="regexp">/Consumer&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p&gt;3. 通过 store.setState() 更新状态&lt;/</span>p&gt;</span><br><span class="line">        &lt;Consumer&gt;</span><br><span class="line">          &#123;() =&gt; <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> store.setState(&#123; foo: new Date().toString() &#125;)&#125;&gt;子组件触发状态更新<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>&#125;</span><br><span class="line">        &lt;<span class="regexp">/Consumer&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="comment">// 父组件触发状态更新</span></span><br><span class="line">    setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      store.setState(&#123; <span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>().toString() &#125;);</span><br><span class="line">    &#125;, <span class="number">1e3</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="comment">// 现在 &lt;Provider&gt; 不需要任何参数了</span></span><br><span class="line">      &lt;Provider&gt;</span><br><span class="line">        &lt;Child/&gt;</span><br><span class="line">      &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;App/</span>&gt;, <span class="built_in">document</span>.querySelector(<span class="string">'#root'</span>));</span><br></pre></td></tr></table></figure><p>现在在应用的任意位置调用 <code>store.setState()</code> 方法，就能更新组件的状态了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ws.js</span></span><br><span class="line"><span class="keyword">const</span> ws = io.connect(<span class="string">'/'</span>);</span><br><span class="line"></span><br><span class="line">ws.on(<span class="string">'pong'</span>, (latency) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 如何将 latency 渲染到组件里？</span></span><br><span class="line">  store.setState(&#123; latency &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="和-mobx-mobx-react-进行比较"><a href="#和-mobx-mobx-react-进行比较" class="headerlink" title="和 mobx/mobx-react 进行比较"></a>和 mobx/mobx-react 进行比较</h3><p>MobX 基于观察者模式，通过 mobx-react 封装后许多地方和 Context API 类似，下面是官方提供的一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">     <span class="keyword">return</span> (</span><br><span class="line">         &lt;div&gt;</span><br><span class="line">            &#123;<span class="keyword">this</span>.props.person.name&#125;</span><br><span class="line">            &lt;Observer&gt;</span><br><span class="line">                &#123;() =&gt; <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.person.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&#125;</span><br><span class="line">            &lt;<span class="regexp">/Observer&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">     )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = observable(&#123; <span class="attr">name</span>: <span class="string">"John"</span> &#125;)</span><br><span class="line"></span><br><span class="line">React.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> <span class="attr">person</span>=<span class="string">&#123;person&#125;</span> /&gt;</span>, document.body)</span></span><br><span class="line"><span class="xml">person.name = "Mike" // will cause the Observer region to re-render</span></span><br></pre></td></tr></table></figure><p>在 mobx-react 的套路中，组件可以通过 <code>&lt;Observer&gt;</code> 消费由 <code>observable()</code> 创建出来的对象，直接修改该对象中的键值可以实现组件的重新渲染。</p><p>二次封装后的 Context API 相比 mobx-react 用法相近，但 mobx 得益于 setter/getter Hooks 具有更直观的状态改变方式。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://github.com/acdlite/rfcs/blob/new-version-of-context/text/0000-new-version-of-context.md" target="_blank" rel="noopener">https://github.com/acdlite/rfcs/blob/new-version-of-context/text/0000-new-version-of-context.md</a></li><li><a href="https://github.com/reactjs/rfcs/pull/2" target="_blank" rel="noopener">https://github.com/reactjs/rfcs/pull/2</a></li><li><a href="https://github.com/facebook/react/pull/11818" target="_blank" rel="noopener">https://github.com/facebook/react/pull/11818</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;React-16-3-Context-API-实践&quot;&gt;&lt;a href=&quot;#React-16-3-Context-API-实践&quot; class=&quot;headerlink&quot; title=&quot;React 16.3 Context API 实践&quot;&gt;&lt;/a&gt;React 16.3 
      
    
    </summary>
    
    
      <category term="tech" scheme="https://apporz.com/tags/tech/"/>
    
      <category term="react" scheme="https://apporz.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>Qnimate, an animated colorful voronoi diagram powered by d3.js</title>
    <link href="https://apporz.com/2016/10/11/qnimate/"/>
    <id>https://apporz.com/2016/10/11/qnimate/</id>
    <published>2016-10-11T06:28:57.000Z</published>
    <updated>2017-12-11T12:45:45.303Z</updated>
    
    <content type="html"><![CDATA[<h1 id="qnimate"><a href="#qnimate" class="headerlink" title="qnimate"></a>qnimate</h1><p>An animated colorful <a href="https://en.wikipedia.org/wiki/Voronoi_diagram" target="_blank" rel="noopener">Voronoi diagram</a><br>powered by <a href="https://github.com/d3/d3" target="_blank" rel="noopener">d3</a>.</p><h2 id="Live-demo"><a href="#Live-demo" class="headerlink" title="Live demo"></a>Live demo</h2><p><a href="https://micooz.github.io/qnimate" target="_blank" rel="noopener">https://micooz.github.io/qnimate</a></p><h2 id="Try-it"><a href="#Try-it" class="headerlink" title="Try it!"></a>Try it!</h2><p>Install via npm:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/micooz/qnimate</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> qnimate &amp;&amp; npm i</span></span><br></pre></td></tr></table></figure><p>Run in development:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm start</span></span><br></pre></td></tr></table></figure><p>Build and bundle:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm run build:prod</span></span><br></pre></td></tr></table></figure><h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><p><strong>HTML</strong>:</p><pre><code>&lt;div id=&quot;&quot;playground&quot;&quot;&gt;&lt;/div&gt;</code></pre><p><strong>js</strong>:</p><pre><code>&lt;script src=&quot;&quot;qnimate.min.js&quot;&quot;&gt;&lt;/script&gt;</code></pre><p><code>Qnimate</code> will be exposed to <code>window</code>, create an instance of <code>Qnimate</code>, pass an option object and then call <code>run()</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> qnimate = <span class="keyword">new</span> Qnimate(&#123;</span><br><span class="line">    id: <span class="string">'playground'</span>,</span><br><span class="line">    width: <span class="number">960</span>,</span><br><span class="line">    height: <span class="number">500</span>,</span><br><span class="line">    vertices: <span class="number">40</span></span><br><span class="line">  &#125;);</span><br><span class="line">  qnimate.run();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="Acknowledgments"><a href="#Acknowledgments" class="headerlink" title="Acknowledgments"></a>Acknowledgments</h2><p><code>d3.voronoi</code> - <a href="https://github.com/d3/d3-voronoi" target="_blank" rel="noopener">https://github.com/d3/d3-voronoi</a></p><h2 id="Known-issues"><a href="#Known-issues" class="headerlink" title="Known issues"></a>Known issues</h2><ul><li>New triangle appears suddenly.</li><li>White triangle appears from time to time.</li></ul><h2 id="Any-advice"><a href="#Any-advice" class="headerlink" title="Any advice?"></a>Any advice?</h2><p>Send me <a href="https://github.com/micooz/qnimate/issues" target="_blank" rel="noopener">issue</a>.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;qnimate&quot;&gt;&lt;a href=&quot;#qnimate&quot; class=&quot;headerlink&quot; title=&quot;qnimate&quot;&gt;&lt;/a&gt;qnimate&lt;/h1&gt;&lt;p&gt;An animated colorful &lt;a href=&quot;https://en.wikipedia
      
    
    </summary>
    
    
      <category term="tech" scheme="https://apporz.com/tags/tech/"/>
    
      <category term="d3" scheme="https://apporz.com/tags/d3/"/>
    
  </entry>
  
  <entry>
    <title>How to disable text selection in svg</title>
    <link href="https://apporz.com/2016/07/26/how-to-disable-text-selection-in-svg/"/>
    <id>https://apporz.com/2016/07/26/how-to-disable-text-selection-in-svg/</id>
    <published>2016-07-25T16:00:00.000Z</published>
    <updated>2017-12-07T11:52:35.388Z</updated>
    
    <content type="html"><![CDATA[<p>In sass style:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">text</span> &#123;</span><br><span class="line">  <span class="attribute">user-select</span>: none;</span><br><span class="line">  </span><br><span class="line">  &amp;::selection &#123;</span><br><span class="line">    <span class="selector-tag">background</span>: <span class="selector-tag">none</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;In sass style:&lt;/p&gt;&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/s
      
    
    </summary>
    
    
      <category term="tech" scheme="https://apporz.com/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title>D3绘图套路</title>
    <link href="https://apporz.com/2016/06/16/d3-stereotype/"/>
    <id>https://apporz.com/2016/06/16/d3-stereotype/</id>
    <published>2016-06-16T08:46:12.000Z</published>
    <updated>2017-12-11T12:45:45.303Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>接触D3三天，发现有些套路可以反复运用，所以记录一下。</p></blockquote><p><code>D3</code>相比其他图表库，学习成本较高。但最为灵活，需要使用者精雕细琢图形的每个细节。D3处处体现了<strong>函数式</strong>的编程思维。</p><p><strong>NOTE:</strong> 这里所用D3版本是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;dependencies&quot;&quot;: &#123;</span><br><span class="line">  &quot;&quot;d3&quot;&quot;: &quot;&quot;^4.0.0-alpha.49&quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面以一个简单的横纵坐标图为例。</p><h2 id="①-定义高宽"><a href="#①-定义高宽" class="headerlink" title="① 定义高宽"></a>① 定义高宽</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> margin = &#123;<span class="attr">left</span>: <span class="number">70</span>, <span class="attr">top</span>: <span class="number">20</span>, <span class="attr">right</span>: <span class="number">20</span>, <span class="attr">bottom</span>: <span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> svgWidth = <span class="number">800</span>;</span><br><span class="line"><span class="keyword">var</span> svgHeight = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> graphWidth = svgWidth - margin.left - margin.right;</span><br><span class="line"><span class="keyword">var</span> graphHeight = svgHeight - margin.top - margin.bottom;</span><br></pre></td></tr></table></figure><p>这一步实际上比较重要，图形高宽参数会在后面绘图中常常用到。</p><h2 id="②-创建svg"><a href="#②-创建svg" class="headerlink" title="② 创建svg"></a>② 创建svg</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> svg = d3.select(<span class="string">'.container'</span>).append(<span class="string">'svg'</span>)</span><br><span class="line">    .attr(<span class="string">'width'</span>, svgWidth)</span><br><span class="line">    .attr(<span class="string">'height'</span>, svgHeight);</span><br></pre></td></tr></table></figure><p>这里可以直接在html中放一个<code>&lt;svg&gt;</code>，但为了可移植性，用脚本生成。</p><h2 id="③-创建绘制区域"><a href="#③-创建绘制区域" class="headerlink" title="③ 创建绘制区域"></a>③ 创建绘制区域<g></g></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> graph = svg.append(<span class="string">'g'</span>)</span><br><span class="line">    .attr(<span class="string">'width'</span>, graphWidth)</span><br><span class="line">    .attr(<span class="string">'height'</span>, graphHeight)</span><br><span class="line">    .attr(<span class="string">'transform'</span>, <span class="string">'translate('</span> + margin.left + <span class="string">','</span> + margin.top + <span class="string">')'</span>);</span><br></pre></td></tr></table></figure><p><code>&lt;g&gt;</code>中将包含所有图形元素（坐标轴、标签、线条……），现在svg树是这样的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">g</span>&gt;</span><span class="tag">&lt;/<span class="name">g</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="④-设置X、Y的图形坐标范围"><a href="#④-设置X、Y的图形坐标范围" class="headerlink" title="④ 设置X、Y的图形坐标范围"></a>④ 设置X、Y的图形坐标范围</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = d3.scaleTime()</span><br><span class="line">    .range([<span class="number">0</span>, graphWidth]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> y = d3.scaleLinear()</span><br><span class="line">    .range([graphHeight, <span class="number">0</span>]);</span><br></pre></td></tr></table></figure><p>这个时候由于数据还没获取，只能先设置他们的<strong>图形坐标</strong>范围，注意这个<strong>不是</strong>数据的定义域。</p><p>这个两个<code>函数</code>通常有两个用途，以<code>x</code>为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> px = x(data); <span class="comment">// 根据数据值计算对应的x坐标值</span></span><br><span class="line"><span class="keyword">var</span> data = x.invert(px); <span class="comment">// 根据x坐标值反算对应的数据值</span></span><br></pre></td></tr></table></figure><h2 id="⑤-获取数据"><a href="#⑤-获取数据" class="headerlink" title="⑤ 获取数据"></a>⑤ 获取数据</h2><p>一般情况下都是从远端取回特定格式的数据，这是个异步过程：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d3.csv(<span class="string">'data.csv'</span>, parser, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// data</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>D3很人性化的给你留了个格式化数据的地方<code>parser</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parser</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    date: d3.timeParse(<span class="string">'%b %Y'</span>)(d.date),</span><br><span class="line">    value: +(d.price)</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>D3取出数据的每一行，依次传入该函数，然后可以返回你需要的格式化数据，最后以数组形成出现在<code>data</code>变量中。</p><h2 id="⑥-设置X、Y的值域"><a href="#⑥-设置X、Y的值域" class="headerlink" title="⑥ 设置X、Y的值域"></a>⑥ 设置X、Y的值域</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// value domain of x and y</span></span><br><span class="line">x.domain(d3.extent(data, <span class="function"><span class="keyword">function</span> (<span class="params">d</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> d.date;</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">y.domain([<span class="number">0</span>, d3.max(data, <span class="function"><span class="keyword">function</span> (<span class="params">d</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> d.value;</span><br><span class="line">&#125;)]);</span><br></pre></td></tr></table></figure><p>现在可以给x和y设置值域了，值域类型可以很灵活，上面设置x的值域是一个时间范围。</p><h2 id="⑦-开始绘制"><a href="#⑦-开始绘制" class="headerlink" title="⑦ 开始绘制"></a>⑦ 开始绘制</h2><p>接下来就是构思你图形的各个部分了，坐标轴、标签、图形内容等等，也是逐步生成一个完整<code>svg</code>的过程。为了简便起见，这里不会贴出冗余代码。</p><p>绘制X轴：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// X、Y轴可以利用D3的axisXXXXXX函数简单创建，</span></span><br><span class="line"><span class="comment">// 它会把坐标轴的每个数据标签、包括刻度线都为你生成好</span></span><br><span class="line">graph.append(<span class="string">'g'</span>)</span><br><span class="line">    .attr(<span class="string">'class'</span>, <span class="string">'.x-axis'</span>)</span><br><span class="line">    .attr(<span class="string">'transform'</span>, <span class="string">'translate(-1,'</span> + graphHeight + <span class="string">')'</span>)</span><br><span class="line">    .call(d3.axisBottom(x));</span><br></pre></td></tr></table></figure><p>绘制折线：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个线段生成器，会根据绑定数据，通过x和y访问器计算每个点的坐标位置</span></span><br><span class="line"><span class="keyword">var</span> line = d3.line()</span><br><span class="line">    .x(<span class="function"><span class="keyword">function</span> (<span class="params">d</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> x(d.date)</span><br><span class="line">    &#125;)</span><br><span class="line">    .y(<span class="function"><span class="keyword">function</span> (<span class="params">d</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> y(d.value)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 折线图可以用svg中的&lt;path&gt;并设置其d属性来绘制</span></span><br><span class="line"><span class="comment">// line函数需要一个点集来生成一个字符串，这个字符串可以直接填充&lt;path&gt;的d属性</span></span><br><span class="line"><span class="comment">// 为了使线段可见，还需要设置其stroke和stroke-width样式。</span></span><br><span class="line"><span class="keyword">var</span> path = graph.append(<span class="string">'path'</span>)</span><br><span class="line">    .attr(<span class="string">'d'</span>, line(data));</span><br></pre></td></tr></table></figure><p>至此，就可以看到一个基本图形了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;接触D3三天，发现有些套路可以反复运用，所以记录一下。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;code&gt;D3&lt;/code&gt;相比其他图表库，学习成本较高。但最为灵活，需要使用者精雕细琢图形的每个细节。D3处处体现了&lt;strong&gt;函数式&lt;/stron
      
    
    </summary>
    
    
      <category term="tech" scheme="https://apporz.com/tags/tech/"/>
    
      <category term="d3" scheme="https://apporz.com/tags/d3/"/>
    
  </entry>
  
  <entry>
    <title>【记坑】关于d3.zoom</title>
    <link href="https://apporz.com/2016/06/14/d3-zoom/"/>
    <id>https://apporz.com/2016/06/14/d3-zoom/</id>
    <published>2016-06-14T06:28:57.000Z</published>
    <updated>2017-12-11T12:45:45.303Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>D3.js的最新v4版提供了d3.zoom模块，用它可以给svg图形增加缩放/移动的特性，但通过非鼠标/触控的方式改变图形的位置和缩放比例后，d3.zoom的行为就变得不正常了。本文给出一个解决方法。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 初始化一个zoom行为</span></span><br><span class="line"><span class="keyword">const</span> zoom = d3.zoom();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 设置zoom行为参数</span></span><br><span class="line">zoom.scaleExtent([<span class="number">.5</span>, <span class="number">5</span>]);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 添加三个事件监听器</span></span><br><span class="line">zoom.on(<span class="string">'start'</span>, () =&gt; &#123;...&#125;);</span><br><span class="line">zoom.on(<span class="string">'zoom'</span>, zoom);</span><br><span class="line">zoom.on(<span class="string">'end'</span>, () =&gt; &#123;...&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 应用行为</span></span><br><span class="line">g.call(zoom);</span><br></pre></td></tr></table></figure><p>我们一般会关注<code>zoom</code>事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> zoom = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// d3自动计算的transform值会放在d3.event里</span></span><br><span class="line">  container.attr(<span class="string">'transform'</span>, d3.event.transform);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有趣的是，如果我们在其他地方主动设置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">container.attr(<span class="string">'transform'</span>, <span class="string">'translate(10, 10)'</span>);</span><br></pre></td></tr></table></figure><p>再用鼠标或者触控板调整图形时，zoom行为并不会从(10, 10)位置开始计算下一个<code>d3.event.transform</code>，zoom行为似乎<code>自己保存</code>了上一次的transform，而不关心我们设置到<code>container</code>上的transform。</p><p>结果就是我们用attr设置的transform其实是<code>临时的</code>。</p><p>如果查看应用了zoom行为的宿主元素（这里是<code>g</code>）的属性，会发现其Element上有一个<code>__zoom: Transform</code>，这个玩意儿每次走<code>zoom</code>方法的时候都会变化，这正是zoom自己保存的transform对象。</p><p>所以我们在主动设置transform后，只需要想办法更新这个__zoom就可以<code>骗过</code>zoom行为，让它下一次调用zoom()事，从我们设置的值开始计算。</p><p>查阅文档：</p><p><a href="https://github.com/d3/d3-zoom/blob/master/README.md#zoom_transform" target="_blank" rel="noopener">https://github.com/d3/d3-zoom/blob/master/README.md#zoom_transform</a></p><p><a href="https://github.com/d3/d3-zoom/blob/master/README.md#transform_scale" target="_blank" rel="noopener">https://github.com/d3/d3-zoom/blob/master/README.md#transform_scale</a></p><p>可以这样设置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义transform</span></span><br><span class="line">container.attr(<span class="string">'transform'</span>, <span class="string">'translate(10, 10)'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个空的Transform对象，这一点文档没说明怎么构造一个Transform对象</span></span><br><span class="line"><span class="keyword">const</span> transform = d3.zoomTransform(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充&#123;x, y&#125;</span></span><br><span class="line">    .translate(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意一定要设置在.call(zoom)的元素上，它才有'__zoom'</span></span><br><span class="line">d3.zoom().transform(g, transform);</span><br></pre></td></tr></table></figure><p>之后d3触发zoom回调之前会取g的__zoom计算下一次的transform，这个transform才是我们想要的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;D3.js的最新v4版提供了d3.zoom模块，用它可以给svg图形增加缩放/移动的特性，但通过非鼠标/触控的方式改变图形的位置和缩放比例后，d3.zoom的行为就变得不正常了。本文给出一个解决方法。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure 
      
    
    </summary>
    
    
      <category term="tech" scheme="https://apporz.com/tags/tech/"/>
    
      <category term="d3" scheme="https://apporz.com/tags/d3/"/>
    
  </entry>
  
  <entry>
    <title>link in docker</title>
    <link href="https://apporz.com/2016/05/12/link-in-docker/"/>
    <id>https://apporz.com/2016/05/12/link-in-docker/</id>
    <published>2016-05-11T16:00:00.000Z</published>
    <updated>2017-12-07T11:52:35.388Z</updated>
    
    <content type="html"><![CDATA[<h1 id="–link-in-docker"><a href="#–link-in-docker" class="headerlink" title="–link in docker"></a>–link in docker</h1><p>容器A通过–link选项使用容器B的某个服务，<code>docker-compose.yml</code> 配置如下：</p><pre><code>A:  image: image_a  links:    - B:B  ...B:  image: image_b  ...</code></pre><p>当容器B被重启后，A的link不会被自动更新，要一并重启A才行：</p><pre><code>$ docker-compose restart B # A doesn&apos;t work$ docker-compose restart A # it works well</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;–link-in-docker&quot;&gt;&lt;a href=&quot;#–link-in-docker&quot; class=&quot;headerlink&quot; title=&quot;–link in docker&quot;&gt;&lt;/a&gt;–link in docker&lt;/h1&gt;&lt;p&gt;容器A通过–link选项使用容器B的
      
    
    </summary>
    
    
      <category term="tech" scheme="https://apporz.com/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title>webpack-dev-server 最佳实践</title>
    <link href="https://apporz.com/2016/05/10/webpack-dev-server-best-practice/"/>
    <id>https://apporz.com/2016/05/10/webpack-dev-server-best-practice/</id>
    <published>2016-05-09T16:00:00.000Z</published>
    <updated>2017-12-07T11:52:35.389Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p><a href="https://github.com/webpack/webpack-dev-server" target="_blank" rel="noopener">webpack-dev-server</a> 是用express和websocket实现的一套在开发环境下前端自动更新的工具。</p><p>webpack-dev-server提供CLI接口，读取传入的webpack.config.js配置文件，根据webpack配置，建立一个静态服务器，供前端加载静态资源，其中有一个关键附加脚本是 <code>webpack-dev-server.js</code>，位于PATH根路径，即 <code>/webpack-dev-server.js</code>，其中存放着websocket客户端。</p><h2 id="一般使用方法"><a href="#一般使用方法" class="headerlink" title="一般使用方法"></a>一般使用方法</h2><p>可以通过下面的命令运行webpack-dev-server：</p><pre><code>$ node node_modules/.bin/webpack-dev-server --config webpack/dev.config.js --inline --profile --colors --watch --display-error-details --display-cached</code></pre><p>参数说明参考：<a href="http://webpack.github.io/docs/webpack-dev-server.html#webpack-dev-server-cli" target="_blank" rel="noopener">这里</a></p><p>执行后会自动运行webpack进行打包等一系列操作。</p><p>在webpack配置文件中只需添加一个 <code>devServer</code> 配置项即可定义webpack-dev-server的行为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  port: <span class="number">3000</span>,</span><br><span class="line">  host: <span class="string">'localhost'</span>,</span><br><span class="line">  historyApiFallback: <span class="literal">true</span>,</span><br><span class="line">  quiet: <span class="literal">false</span>,</span><br><span class="line">  watchOptions: &#123;</span><br><span class="line">    aggregateTimeout: <span class="number">300</span>,</span><br><span class="line">    poll: <span class="number">1000</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>在这个例子中，webpack-dev-server会在本地<strong>3000</strong>端口上启动一个静态服务器，服务器serve的目录是webpack的必选配置 <code>output.path</code>，这是一个绝对路径。</p><h2 id="一些问题？"><a href="#一些问题？" class="headerlink" title="一些问题？"></a>一些问题？</h2><p>请考虑下面这个问题：</p><p>我有一个网站项目，分模块，每个模块是一个node项目，且每个模块可以<strong>独立存在</strong>（启动，调试，运行），它们有些用到了webpack-dev-server。</p><p>再次强调每个模块相互独立，它们之间的耦合方式只有一种：<strong>请求代理</strong>。</p><p>现在假设模块A作为API服务器，监听3000端口；模块B作为应用服务器，要提供资源给浏览器，于是用webpack-dev-server在端口3001的 <code>/</code> 上建立了静态服务器。模块B还要从模块A存取数据，那么必定存在从3001跨域请求到3000的问题，消除这个问题有多种解决办法：</p><ol><li>在A上设置 <code>Access-Control-Allow-Origin</code> 为B的域。</li><li>在A、B上层建立代理服务器，屏蔽端口限制。</li></ol><p>不深入讨论上面的方法，现在假设我们<strong>采用方法二</strong>解决了跨域请求问题，然后我们再考虑一下接下来的一个问题：</p><p>假设存在模块C，和B十分类似，也属于应用服务器；如果B和C存在同名资源，比如 <code>main.js</code>，访问该资源就会引发冲突，因为两个模块都在 <code>/</code> 上建立了静态服务器，而这又符合每个模块可以<strong>独立存在</strong>的先决条件：</p><pre><code>// Bhttp://localhost/B/index.htmlhttp://localhost/main.js// Chttp://localhost/C/index.htmlhttp://localhost/main.js // 哪个 main.js ?</code></pre><p>解决办法看似很明显：</p><pre><code>// Bhttp://localhost/B/index.htmlhttp://localhost/B/main.js// Chttp://localhost/C/index.htmlhttp://localhost/C/main.js // everyone is happy</code></pre><p>但这又破坏了每个模块的独立性，我希望单独启动C时，C总能从 <code>/</code> 上获取资源，而不是 <code>/C/...</code> 这么冗余。</p><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>问题就出在 <code>webpack-dev-server</code>，它适合作为<strong>静态资源服务器</strong>，而不是<strong>开发服务器</strong>。因此，我们的开发环境除了需要 <code>webpack-dev-server</code>，还需要专门的<strong>开发服务器</strong>。</p><pre><code>// =&gt; Module B// dev serverhttp://localhost/B/index.html// webpack-dev-server for Bhttp://localhost:3001/...// =&gt; Module C// dev serverhttp://localhost/C/index.html// webpack-dev-server for Chttp://localhost:3003/...</code></pre><p>每个模块从对应的 <code>webpack-dev-server</code> 获取资源，解决了冲突又保留了每个模块的独立性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/webpack/webpack-dev-server&quot; target=&quot;_blank
      
    
    </summary>
    
    
      <category term="tech" scheme="https://apporz.com/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title>Angular2 如何多次触发子组件的 ngOnInit</title>
    <link href="https://apporz.com/2016/03/29/angular2-multiple-ngoninit/"/>
    <id>https://apporz.com/2016/03/29/angular2-multiple-ngoninit/</id>
    <published>2016-03-28T16:00:00.000Z</published>
    <updated>2017-12-07T11:52:35.387Z</updated>
    
    <content type="html"><![CDATA[<p>通常子组件加载后只会执行一次<code>ngOnInit</code>，不利于子组件的自我更新，但设法使子组件从Dom中移除后重建就可以多次触发<code>ngOnInit</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">person</span> *<span class="attr">ngIf</span>=<span class="string">"show"</span>&gt;</span><span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonComponent</span> </span>&#123;</span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">    <span class="comment">// triggered if show is available</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像这种<strong>带星号的指令</strong>就是Angular2中一种模板语法糖，可以管控组件的生命周期。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通常子组件加载后只会执行一次&lt;code&gt;ngOnInit&lt;/code&gt;，不利于子组件的自我更新，但设法使子组件从Dom中移除后重建就可以多次触发&lt;code&gt;ngOnInit&lt;/code&gt;。&lt;/p&gt;&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;
      
    
    </summary>
    
    
      <category term="tech" scheme="https://apporz.com/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title>webpack复习</title>
    <link href="https://apporz.com/2016/03/22/webpack-review/"/>
    <id>https://apporz.com/2016/03/22/webpack-review/</id>
    <published>2016-03-21T16:00:00.000Z</published>
    <updated>2017-12-07T11:52:35.390Z</updated>
    
    <content type="html"><![CDATA[<p>使用<code>ProvidePlugin</code>暴露对象到全局：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> webpack.ProvidePlugin(&#123;</span><br><span class="line">    $: <span class="string">'jquery'</span>,</span><br><span class="line">    jQuery: <span class="string">'jquery'</span>,</span><br><span class="line">    <span class="string">'window.jQuery'</span>: <span class="string">'jquery'</span></span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>自定义require返回值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"></span><br><span class="line">externals: &#123;</span><br><span class="line">  <span class="string">'data'</span>: <span class="string">'data data...'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// use in code</span></span><br><span class="line"><span class="keyword">var</span> data = <span class="built_in">require</span>(<span class="string">'data'</span>); <span class="comment">// 'data data...'</span></span><br></pre></td></tr></table></figure><p><strong>开启Hot Module Replacement(HMR)</strong></p><p>方法一：</p><pre><code>$ webpack --hot --inline</code></pre><ul><li>–hot: 添加HotModuleReplacementPlugin</li><li>–inline: 在生成的js中添加websocket客户端</li></ul><p>方法二：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"></span><br><span class="line">entry: &#123;</span><br><span class="line">  <span class="string">'webpack/hot/dev-server'</span>, <span class="comment">// 仅仅是为window添加一个listener</span></span><br><span class="line">  <span class="string">'webpack-dev-server/client?http://localhost:8000'</span> <span class="comment">// websocket客户端</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用&lt;code&gt;ProvidePlugin&lt;/code&gt;暴露对象到全局：&lt;/p&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/spa
      
    
    </summary>
    
    
      <category term="tech" scheme="https://apporz.com/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title>利用索引提升js的执行效率</title>
    <link href="https://apporz.com/2016/03/17/improve-js-performance-by-using-index/"/>
    <id>https://apporz.com/2016/03/17/improve-js-performance-by-using-index/</id>
    <published>2016-03-16T16:00:00.000Z</published>
    <updated>2017-12-07T11:52:35.388Z</updated>
    
    <content type="html"><![CDATA[<p><strong>问题引入：</strong></p><p>前段时间，有一个任务是需要<strong>频繁</strong>在<strong>大量的数据</strong>集合中<strong>快速定位</strong>并修改某个元素某个字段的值。</p><p>数据结构是<strong>数组</strong>，元素的结构可能相当复杂且<strong>乱序</strong>。</p><p><strong>问题分析：</strong></p><p>假定这个数据集如下：</p><pre><code>// array dataset[{  name: &apos;name1&apos;,  body: {    metadata: {      header: {        id: 1 // unique      }    }  },  ...}]</code></pre><p>实际上就是一个<strong>查找算法</strong>问题，假设要从1000条数据中查找id为1的元素，最SB做法是直接遍历整个数据集：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> ele <span class="keyword">of</span> dataset) &#123;</span><br><span class="line">  <span class="keyword">if</span> (ele.body.metadata.header.id === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ele;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最坏的情况是O(n)，当然也可以使用其他常见的查找算法减少遍历次数，但如果要<strong>频繁</strong>查找，同步操作会导致页面直接卡死。</p><p>如果有一张<strong>哈希表</strong>就帮大忙了，不妨先想想下面这个问题：</p><blockquote><p>在数据库里，为什么给一个字段加个索引就可以极大提升查询效率（通常情况）？</p></blockquote><p><strong>解决方案：</strong></p><p>首先理解索引的含义，在js中，数组是线性结构，它的下标可以当成一种索引，通过下标访问元素时间复杂度为O(1)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> db = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, ...];</span><br><span class="line"><span class="keyword">const</span> ele = db[<span class="number">2</span>]; <span class="comment">// very quick</span></span><br></pre></td></tr></table></figure><p>对于一个Object，同样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  col1: <span class="number">1</span>,</span><br><span class="line">  col2: <span class="number">2</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> col2 = obj[<span class="string">'col2'</span>]; <span class="comment">// very quick</span></span><br><span class="line"><span class="keyword">const</span> col2 = obj.col2; <span class="comment">// very quick</span></span><br></pre></td></tr></table></figure><p>再看看最开始的那个问题，如果我们可以：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> id = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> ele = dataset[id]; <span class="comment">// very quick</span></span><br></pre></td></tr></table></figure><p>实现这个效果实际上就要<strong>建立索引</strong>，此时的 <code>dataset</code> 显然已经不能是最原始的数组了。当id不是数字的时候，<code>dataset</code> 也不能是数组，<br>那么Object就理所当然地充当js里的HashMap了（ES6中已经有标准的<a href="http://es6.ruanyifeng.com/#docs/set-map#Map" target="_blank" rel="noopener">Map</a>实现）。</p><p>编写一个通用的索引创建函数，这个函数可以为一个数组，通过传入的回调函数的返回值创建一个包含所有数据引用的索引对象（Object）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> index = <span class="function">(<span class="params">arr, fn</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> indexes = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> it <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = fn(it);</span><br><span class="line">    <span class="keyword">if</span> (!indexes[key]) &#123;</span><br><span class="line">      indexes[key] = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    indexes[key] = it;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> indexes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数只需要<strong>遍历一次数据集</strong>来建立索引。</p><p>用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> our_index = _index(dataset, ele =&gt; ele.body.metadata.header.id);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  "1": &#123;</span></span><br><span class="line"><span class="comment">    name: 'name1',</span></span><br><span class="line"><span class="comment">    body: &#123;</span></span><br><span class="line"><span class="comment">      metadata: &#123;</span></span><br><span class="line"><span class="comment">        header: &#123;</span></span><br><span class="line"><span class="comment">          id: 1 // unique</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  "2": &#123;...&#125;,</span></span><br><span class="line"><span class="comment">  ...</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>有了这个索引 <code>our_index</code>，就可以愉快的以<strong>O(1)</strong>的复杂度来访问任意元素，取出的元素是引用，于是也可以直接对原存储空间的数据进行操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ele = our_index[<span class="number">1</span>];</span><br><span class="line"><span class="comment">// operation on ele</span></span><br><span class="line">ele.name = <span class="string">'_'</span> + ele.name;</span><br></pre></td></tr></table></figure><p><strong>小结</strong></p><p>原生JavaScript不支持Map数据结构，因此可以通过对象来实现；关键在于如何根据需要建立索引，建立索引的字段必须满足<strong>唯一性</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;问题引入：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;前段时间，有一个任务是需要&lt;strong&gt;频繁&lt;/strong&gt;在&lt;strong&gt;大量的数据&lt;/strong&gt;集合中&lt;strong&gt;快速定位&lt;/strong&gt;并修改某个元素某个字段的值。&lt;/p&gt;&lt;p&gt;数据结构是&lt;st
      
    
    </summary>
    
    
      <category term="tech" scheme="https://apporz.com/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title>Angular2 事件绑定注意</title>
    <link href="https://apporz.com/2016/02/23/angular2-events-bind/"/>
    <id>https://apporz.com/2016/02/23/angular2-events-bind/</id>
    <published>2016-02-22T16:00:00.000Z</published>
    <updated>2017-12-07T11:52:35.386Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> [(<span class="attr">ngModel</span>)]=<span class="string">"value"</span> (<span class="attr">change</span>)=<span class="string">"onSelect(value)"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onSelect(value) &#123;</span><br><span class="line">  <span class="comment">// value 还是原来的值，没来得及改变</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决办法</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">onSelect(value) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// value 绑定完成后的值</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="console-log-或者说Chrome-DevTools的坑"><a href="#console-log-或者说Chrome-DevTools的坑" class="headerlink" title="console.log 或者说Chrome DevTools的坑"></a>console.log 或者说Chrome DevTools的坑</h1><p>考虑下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: []&#125;, n = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">while</span>(n--) &#123;</span><br><span class="line">  obj.a.push(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// obj.a[50]: -100</span></span><br><span class="line"></span><br><span class="line">obj.a[<span class="number">50</span>] = <span class="number">-100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// obj.a[50]: -100</span></span><br></pre></td></tr></table></figure><p>浏览器里可以发现两次输出的结果中 <code>a[50]</code> 都是 <code>-100</code>。这一点如果第一次遇到的话还真是匪夷所思。</p><p>这里我故意把 <code>a</code> 数组的元素弄得很多，使 <code>DevTools</code> 以 <strong>折叠</strong> 方式显示：</p><blockquote><p>Object {a: Array[100]}<br>Object {a: Array[100]}</p></blockquote><p>看似友好的显示方式，实际上里面有很大的问题。</p><p>当我们<strong>展开第一个输出</strong>时， <code>DevTools</code> 会 <strong>及时</strong> 读取变量值，由于这是个 <strong>引用</strong> 类型，实际上它读到的是 <code>obj</code> 的最终值，及 <code>a[50]</code> 是 <code>-100</code>。</p><p>如果数组a只有很少的元素，<code>DevTools</code> 不启用智能显示时就不会出现这个问题。</p><p>也就是说，<code>console.log</code> 到 <code>DevTools</code> 里的实际上<strong>是引用而不是拷贝</strong>，<strong>展开</strong>操作会及时读取变量值。</p><p>如果把上面例子的两个输出改成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj));</span><br></pre></td></tr></table></figure><p>结果将和预期的一致。</p><p><strong>因此</strong>，在浏览器中调试 <code>js</code> 程序应该以 <code>调试器</code> 下断点为主，日志为辅。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="tech" scheme="https://apporz.com/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title>Angular2 @Input 绑定问题</title>
    <link href="https://apporz.com/2016/02/19/angular2-input-bind/"/>
    <id>https://apporz.com/2016/02/19/angular2-input-bind/</id>
    <published>2016-02-18T16:00:00.000Z</published>
    <updated>2017-12-07T11:52:35.386Z</updated>
    
    <content type="html"><![CDATA[<pre><code>@Component({  template: `&lt;child [value]=&quot;bindValue&quot;&gt;&lt;/child&gt;`})class HomeComponent {  bindValue:string = &apos;hello&apos;;}@Component({  selector: &apos;child&apos;,  template: `...`})class ChildComponent{  @Input() value;  ngOnInit(){    // 这里可以取到value的值为&apos;hello&apos;    // 当bindValue动态改变时，此函数不会再次调用，需要在ngOnChanges中手动更新  }  ngOnChanges(changes) {    // this.value = changes[&apos;value&apos;].currentValue;    // ...    // 但是要小心这个函数会被频繁调用，    // 不要做复杂逻辑  }}</code></pre><h1 id="Array-prototype-map-的坑"><a href="#Array-prototype-map-的坑" class="headerlink" title="Array.prototype.map 的坑"></a>Array.prototype.map 的坑</h1><p>map回调如果不给出返回值，则默认返回 <code>undefined</code>，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" target="_blank" rel="noopener">MDN文档</a>中似乎并未提到这一点。</p><pre><code>var numbers = [1, 4, 9];var roots = numbers.map(n =&gt; {  if (n === 4) {    return -1;  }});// [undefined, -1, undefined]</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;@Component({
  template: `&amp;lt;child [value]=&amp;quot;bindValue&amp;quot;&amp;gt;&amp;lt;/child&amp;gt;`
})
class HomeComponent {
  bindValue:string 
      
    
    </summary>
    
    
      <category term="tech" scheme="https://apporz.com/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title>浮动元素z-index无效问题</title>
    <link href="https://apporz.com/2016/02/18/float-element-z-index-problem/"/>
    <id>https://apporz.com/2016/02/18/float-element-z-index-problem/</id>
    <published>2016-02-17T16:00:00.000Z</published>
    <updated>2017-12-07T11:52:35.387Z</updated>
    
    <content type="html"><![CDATA[<pre><code>.view-container {  float: right !important;  z-index: 999; /* invalid! */  /* position must be set */  position: relative;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;.view-container {
  float: right !important;
  z-index: 999; /* invalid! */

  /* position must be set */
  position: relative;
}
      
    
    </summary>
    
    
      <category term="tech" scheme="https://apporz.com/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title>Object.assign</title>
    <link href="https://apporz.com/2016/02/17/object-assign/"/>
    <id>https://apporz.com/2016/02/17/object-assign/</id>
    <published>2016-02-16T16:00:00.000Z</published>
    <updated>2017-12-07T11:52:35.389Z</updated>
    
    <content type="html"><![CDATA[<pre><code>const _new = Object.assign(target, {...});</code></pre><p>会改变 <code>target</code> 本身，引发问题。</p><blockquote><p>The Object.assign() method is used to copy the values of all enumerable own properties from one or more source objects <strong>to</strong> a target object. It will return the target object.</p></blockquote><p>有三个解决办法：</p><p><strong>逐个拷贝</strong></p><pre><code>const _new = {k1: target.k1, k2: target.k2, ...};</code></pre><p><strong>ES6</strong></p><pre><code>const _new = {...target, ...{...}};</code></pre><p><strong>（最佳）把第一个参数设成空对象</strong></p><pre><code>const _new = Object.assign({}, target, {...});</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;const _new = Object.assign(target, {...});
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;会改变 &lt;code&gt;target&lt;/code&gt; 本身，引发问题。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;The Object.assign()
      
    
    </summary>
    
    
      <category term="tech" scheme="https://apporz.com/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title>Angular2 - Routing &amp; Navigation</title>
    <link href="https://apporz.com/2016/02/15/angular2-routing-navigation/"/>
    <id>https://apporz.com/2016/02/15/angular2-routing-navigation/</id>
    <published>2016-02-14T16:00:00.000Z</published>
    <updated>2017-12-07T11:52:35.387Z</updated>
    
    <content type="html"><![CDATA[<p><code>@routerCanActive</code> 在加载组件前执行，其回调函数有两种返回方式：</p><pre><code>@routerCanActive(function() {  // return true; 同步  // return Promise.resolve(true); 异步})</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;@routerCanActive&lt;/code&gt; 在加载组件前执行，其回调函数有两种返回方式：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;@routerCanActive(function() {
  // return true; 同步
  // return Promise
      
    
    </summary>
    
    
      <category term="tech" scheme="https://apporz.com/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title>使用Docker部署PHP应用的设计方案</title>
    <link href="https://apporz.com/2015/08/29/docker-lnmp/"/>
    <id>https://apporz.com/2015/08/29/docker-lnmp/</id>
    <published>2015-08-28T16:00:00.000Z</published>
    <updated>2017-12-08T13:17:42.223Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Docker"><a href="#1-Docker" class="headerlink" title="1. Docker"></a>1. Docker</h1><p>Docker的官方定义是：</p><blockquote><p>Docker allows you to package an application with all of its dependencies into a standardized unit for software development.</p><p>– <a href="https://www.docker.com/whatisdocker" target="_blank" rel="noopener">https://www.docker.com/whatisdocker</a></p></blockquote><p>毫无疑问的是，Docker解决了应用部署上一个巨大的问题：</p><p>客户: 安装好了，用不了。</p><p>发布者：我的机器上没问题。</p><p>如何解决每个应用的依赖在Docker出现之前是个头疼的问题，现在仅仅通过一次配置，Dockerfile或者image作为最终交付，就能在任何Linux上完美运行了。说起来很简单的样子，但在Docker配置过程中，又存在很多值得思考的问题：应用各个组件如何安排？一个Container解决问题还是细化Container？Container之间何如通信？等等。。下面用一个最普遍的WEB应用配置部署来说明这些问题。</p><p><strong>NOTE</strong>：本文假定读者对Docker中的一些概念有基本的认识，如果不甚了解，我推荐这篇文章：</p><p><a href="https://linux.cn/article-6074-weibo.html" target="_blank" rel="noopener">https://linux.cn/article-6074-weibo.html</a></p><h1 id="2-LNMP"><a href="#2-LNMP" class="headerlink" title="2. LNMP"></a>2. LNMP</h1><p>典型的PHP应用配置方案是LAMP或者LNMP，本文以LNMP为例。</p><p>设计方案如下图:</p><p><img src="202542_DLat_580940.png" alt=""></p><p>应用由4个组件组成，分别是Nginx，PHP-FPM(PHP)，MySQL以及WWW，4个组件运行在由各自镜像创建出来的独立的容器中。其中WWW Container只是一个存储业务代码和静态资源的容器，可以认为是”死”的。</p><p>事实上LNMP架构采用上面的设计方式应该是最容易想到的，也是最清晰的，每个组件有相对的独立性。其中除了WWW容器，其他3个容器都可以直接通过官方镜像构建出来。</p><p>然而网上很多同学并不是这样做的，不会分的这么细，通常是把Nginx和WWW放到一个容器内，或者干脆全部放到一个容器中。可以学习一下大家的Dockerfile:</p><p><a href="https://github.com/search?utf8=✓&amp;q=docker-lnmp" target="_blank" rel="noopener">https://github.com/search?utf8=✓&amp;q=docker-lnmp</a></p><p>细化Container这种设计的优缺点：</p><ol><li>容器间的耦合性增大。可以看到PHP-FPM容器和另外三个容器间有耦合关系，MySQL容器最独立。</li><li>虽然耦合性比较大，但这种端口耦合，文件系统耦合关系可以通过增加几个运行选项解决掉，后面有介绍。</li><li>由于容器对整个架构的划分，使得容器中的内容变得十分独立和安全。例如，我希望在线上更新WWW中的代码，只需要进入WWW容器做修改，不会影响到Nginx，PHP-FPM或者是MySQL。</li><li>各容器可灵活拆卸更换，比如我想把MySQL换成Mongodb，或者干脆把业务代码搬个家，不会影响到其他容器（仅仅更改相关配置文件）</li><li>由于各容器经由官方的镜像创建，因此可以随时花最少的代价使用最新的官方镜像尝鲜。</li><li>占用空间会比较大，一个简单的应用要这么做的话，四个镜像会占用大量的存储空间。</li></ol><h1 id="2-1-容器间通信问题"><a href="#2-1-容器间通信问题" class="headerlink" title="2.1 容器间通信问题"></a>2.1 容器间通信问题</h1><p>细化Container面临着另一个问题，就是如何进行容器间通信。下面简要描述一下上图中的数据流程：</p><ol><li>客户端的http请求达到server的80端口，该端口被映射到Nginx Container的80端口，因此进入Nginx处理。Nginx会分析请求资源，判定是静态资源还是php脚本，如果是静态资源，则直接从WWW中取出发回客户端；如果是脚本程序，则要告诉PHP-FPM到WWW获取相应脚本，然后通过php-cgi处理。</li><li>fast-cgi通过php执行脚本，必要时访问MySQL存取数据。</li></ol><p>这样耦合关系就出来了：</p><ol><li>Nginx需要连接PHP-FPM开放的9000端口，需要访问WWW中的文件系统。</li><li>PHP-FPM也需要访问WWW中的文件系统，还要访问MySQL的3306端口。</li></ol><h1 id="2-2-解决问题"><a href="#2-2-解决问题" class="headerlink" title="2.2 解决问题"></a>2.2 解决问题</h1><p>可以看出有两类耦合关系：端口和文件系统。</p><p>对于端口耦合，docker是通过–link选项解决的；对于文件系统耦合，docker是通过–volumes-from选项解决的。</p><p>解决第一个耦合关系：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -p 80:80 -p 443:443  <span class="comment"># 主机端口映射到容器</span></span><br><span class="line">--volumes-from WWW_CONTAINER_NAME  <span class="comment"># 把WWW容器VOLUME过的文件夹挂载到将启动的容器上</span></span><br><span class="line">--link PHP_FPM_CONTAINER_NAME:fpmservice  <span class="comment"># 冒号前是正在运行的FPM容器名称，后面是别名，别名会作为hostname在将启动的容器内可见</span></span><br><span class="line">-d  <span class="comment"># detach</span></span><br><span class="line">NGINX_IMAGE  <span class="comment"># 镜像名</span></span><br></pre></td></tr></table></figure><p>解决第二个耦合关系：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run --volumes-from WWW_CONTAINER_NAME</span><br><span class="line">--link MYSQL_CONTAINER_NAME:mysql</span><br><span class="line">-d</span><br><span class="line">PHP_FPM_IMAGE</span><br></pre></td></tr></table></figure><p>参考文档：<a href="https://docs.docker.com/reference/run/" target="_blank" rel="noopener">https://docs.docker.com/reference/run/</a></p><p>因此容器启动的先后顺序就出来了：</p><ol><li>MySQL Container</li><li>WWW Container (由于没有任何服务运行，容器run后会立即exit，可以使用 tail -f 等block命令使容器保持运行不退出)</li><li>PHP-FPM Container</li><li>Nginx Container</li></ol><p>其中1和2可以对换。</p><h1 id="3-Dockerfile"><a href="#3-Dockerfile" class="headerlink" title="3. Dockerfile"></a>3. Dockerfile</h1><p>Dockerfiles 请参见：</p><p><a href="https://github.com/micooz/dockerfile" target="_blank" rel="noopener">https://github.com/micooz/dockerfile</a></p><p><a href="http://git.oschina.net/micooz/dockerfile" target="_blank" rel="noopener">http://git.oschina.net/micooz/dockerfile</a></p><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><p>利用Docker部署Web应用可以带来很多便利，在宏观上实现应用组件化，为实现分布式系统奠定了基础。</p><p>可以看到实际上在Docker容器间共享数据是很方便的，搞清楚各容器的依赖关系就不难解决。</p><p>P.s. 本文是我学习docker两天后的心得体会，纰漏在所难免，如有错误还请斧正。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Docker&quot;&gt;&lt;a href=&quot;#1-Docker&quot; class=&quot;headerlink&quot; title=&quot;1. Docker&quot;&gt;&lt;/a&gt;1. Docker&lt;/h1&gt;&lt;p&gt;Docker的官方定义是：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Docker allow
      
    
    </summary>
    
    
      <category term="tech" scheme="https://apporz.com/tags/tech/"/>
    
      <category term="docker" scheme="https://apporz.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>C++使用模板类实现任意类型switch和变量case</title>
    <link href="https://apporz.com/2015/06/02/cpp-template-class-switch-case/"/>
    <id>https://apporz.com/2015/06/02/cpp-template-class-switch-case/</id>
    <published>2015-06-01T16:00:00.000Z</published>
    <updated>2017-12-08T13:17:42.217Z</updated>
    
    <content type="html"><![CDATA[<p>最近自己维护的一个项目<a href="https://github.com/micooz/program_options" target="_blank" rel="noopener">program_options</a>(是一个命令行生成与解析的C++库)在实际应用的时候遇到一个需求：</p><p>需要switch一个字符串来执行相应代码块，然而原生的switch-case条件选择语法针对condition有严格的限制，下面摘录一段switch的语法标准：</p><h2 id="switch-statement"><a href="#switch-statement" class="headerlink" title="switch statement"></a>switch statement</h2><p>Transfers control to one of the several statements, depending on the value of a condition.</p><p>Syntax</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">attr(optional) switch ( condition ) statement</span><br><span class="line"></span><br><span class="line">attr(C++11)-any number of attributes</span><br><span class="line">condition-any expression of integral or enumeration type, or of a class type contextually implicitly convertible to an integral or enumeration type, or a declaration of a single non-array variable of such type with a brace-or-equals initializer.</span><br><span class="line">statement-any statement (typically a compound statement). case: and default: labels are permitted in statement and break; statement has special meaning.</span><br><span class="line"></span><br><span class="line">attr(optional) case constant_expression : statement(1)</span><br><span class="line">attr(optional) default : statement(2)</span><br><span class="line"></span><br><span class="line">constant_expression-a constant expression of the same type as the type of condition after conversions and integral promotions</span><br></pre></td></tr></table></figure><h3 id="condition"><a href="#condition" class="headerlink" title="condition"></a>condition</h3><p>原生switch语法的condition支持整数，枚举或者根据上下文能够隐式转换为整数或者枚举的类，再或者是非数组类型的=或{}初始化语句，举例来说就是如下四类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(<span class="number">100</span>)</span><br><span class="line"><span class="keyword">enum</span> color &#123;r, g, b&#125;</span><br><span class="line"><span class="keyword">switch</span>(r)</span><br><span class="line"><span class="keyword">switch</span>(<span class="keyword">int</span> n = <span class="number">1</span>)</span><br><span class="line"><span class="keyword">switch</span>(<span class="keyword">int</span> n = &#123;<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><h3 id="case"><a href="#case" class="headerlink" title="case"></a>case</h3><p>必须是常量，这样一来就无法做变量与变量之间的比较。</p><h3 id="statement"><a href="#statement" class="headerlink" title="statement"></a>statement</h3><p>当statement没有被{}包围的时候，在其内使用声明语句会导致编译错误。比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(num)&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>; <span class="comment">// error: jump bypasses variable initialization</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然我的需求不能用原生的switch来实现，得老老实实if-elseif-elseif…来分别判断，导致代码又长又臭，if越套越多，逐条判断效率也让人心塞。</p><p>有需求就有想法，有想法就有创新，相信这样的需求早就有人实现过了，比如：</p><ul><li>为C++添加短字符串的switch-case支持<br>将字符串通过#@转换为整形再进行case</li><li>使用C++11新特性，实现用字符串作为switch的case子句<br>利用C++11的constexpr，计算字符串的hash值再进行case</li></ul><p>想法很不错，但是我想要更灵活的解决方案，我希望新的switch支持switch(object)，case(object)，还希望statement对变量声明没有限制，何不完全抛开原生switch的枷锁，自己利用标准库造一个switch来解决问题呢。</p><h2 id="蓝图"><a href="#蓝图" class="headerlink" title="蓝图"></a>蓝图</h2><p>我希望利用C++强大的<strong>template</strong>来兼容任意类型，用C++11的<strong>lambda</strong>匿名函数实现statement，用<strong>操作符重载</strong>operator==来匹配条件，用<strong>hash表</strong>来提升匹配效率，看起来很容易不是吗？</p><p>开始Coding之前我先拟定好蓝图：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 蓝图1</span></span><br><span class="line">select(condition, &#123;</span><br><span class="line">  &#123;<span class="string">"case1"</span>, []() &#123;</span><br><span class="line">    <span class="comment">// code goes here</span></span><br><span class="line">  &#125;&#125;,</span><br><span class="line">  &#123;<span class="string">"case2"</span>, []() &#123;</span><br><span class="line">    <span class="comment">// code goes here</span></span><br><span class="line">  &#125;&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 蓝图2</span></span><br><span class="line">select(condition)</span><br><span class="line">  .found(<span class="string">"case1"</span>, []() &#123;</span><br><span class="line">    <span class="comment">// code goes here</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .found(<span class="string">"case2"</span>, []() &#123;</span><br><span class="line">    <span class="comment">// code goes here</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .others([]() &#123;</span><br><span class="line">    <span class="comment">// default</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>我承认我是受到了javascript的影响，我一直以为C++越来越像是一种高级的脚本语言，或许也是它未来的发展趋势。</p><p>蓝图的设计首先符合C++的语法规范，没有语法错误，其次力求语义明确，简洁。</p><p>蓝图1的大括号太多，书写时容易出错。</p><p>蓝图2语法简洁明了，我相信任何会闭包的Coder都能理解。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>有了蓝图后我们就可以照着这个模样来写代码了，首先分析一下蓝图2。</p><ul><li>存在链式操作，显然select函数要返回一个对象，该对象有found和others方法，并且，found方法要返回实例本身。</li><li>condition和found的第一个参数类型必须一致，但不一定是string，也可以是int，Object，可用template实现</li><li>found第二个参数是lambda表达式，类型是std::function&lt;…&gt;，类似C里面的函数指针，可定义为回调函数。</li><li>每个found块对应于switch里的case，是一个kv关系，可用std::map来存储关联。</li></ul><p>C++建议模板类的声明和定义必须写在同一个文件里，因此起一个<strong>switch.hpp</strong>文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Ty&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Switch</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Switch()&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Switch</span><span class="params">(<span class="keyword">const</span> Ty&amp; target)</span></span></span><br><span class="line">      : target_(target) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  Switch&amp; found(const Ty&amp; _case, const std::function&lt;void(void)&gt;&amp; callback) &#123;</span><br><span class="line">    reflections_[_case] = callback;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">const</span> Ty&amp; target_;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">const</span> Ty, <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">void</span>)&gt;&gt; reflections_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Ty&gt;</span><br><span class="line">Switch&lt;Ty&gt; select(<span class="keyword">const</span> Ty&amp; expression) &#123;</span><br><span class="line">  <span class="keyword">return</span> Switch&lt;Ty&gt;(expression);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么一来就实现了found得链式操作，存储了kv对，全局(也可以在某个命名空间内)select函数是一个简化书写的帮助函数，创建对象后返回该对象的拷贝，实现了如下调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select(<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"condition"</span>))</span><br><span class="line">  .found ...</span><br></pre></td></tr></table></figure><p>接下来我需要实现查找到对应的target，然后调用它的callback。</p><p>增加一个done()方法，该方法被调用意味着结束整个Switch，开始匹配found块，如果没找到，调用others函数(对应default块)：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> kv = reflections_.find(target_);</span><br><span class="line">  <span class="keyword">if</span> (kv != reflections_.end()) &#123;</span><br><span class="line">    <span class="comment">// found</span></span><br><span class="line">    <span class="keyword">auto</span> scope = kv-&gt;second;</span><br><span class="line">    scope();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (has_others_scope_) &#123;</span><br><span class="line">    <span class="comment">// not found, call others</span></span><br><span class="line">    others_();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>std::map的find方法时间复杂度是O(logN)，而原生switch匹配时间复杂度是O(1)，肯定是有很大差距的，但是为了实现switch没有的功能，这点损失也是十分值得的。</p><p>others方法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">others</span><span class="params">(<span class="keyword">const</span> Scope&amp; callback)</span> </span>&#123;</span><br><span class="line">  has_others_scope_ = <span class="literal">true</span>;</span><br><span class="line">  others_ = callback;</span><br><span class="line">  <span class="keyword">this</span>-&gt;done();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当用户调用others方法定义了default块之后，就没必要再调用done了，又可以减少7个字符的书写。</p><p>这里has_others_scope_为bool成员；others_是单独存放的lambda表达式成员，为了简化查找，不宜放在reflections_中。</p><p>再简化书写，用typedef缩短类型，然后替换原类中相应类型为短类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">void</span>)&gt; Scope;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">const</span> Ty, Scope&gt; Reflections;</span><br></pre></td></tr></table></figure><p>这么一来几乎很完美了，全新的Switch如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> printl(<span class="meta-keyword">line</span>) printf((<span class="meta-keyword">line</span>)); printf(<span class="meta-string">"\n"</span>)</span></span><br><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">condition</span><span class="params">(<span class="string">"windows"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// match std::string</span></span><br><span class="line">select(condition)</span><br><span class="line">  .found(<span class="string">"apple"</span>, []() &#123;</span><br><span class="line">    printl(<span class="string">"it's apple"</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .found(<span class="string">"windows"</span>, []() &#123;</span><br><span class="line">    printl(<span class="string">"it's windows"</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .found(<span class="string">"linux"</span>, []() &#123;</span><br><span class="line">    printl(<span class="string">"it's linux"</span>);</span><br><span class="line">  &#125;).done();</span><br><span class="line"></span><br><span class="line"><span class="comment">// match int</span></span><br><span class="line">select(<span class="number">100</span>)</span><br><span class="line">  .found(<span class="number">10</span>, []() &#123;</span><br><span class="line">    printl(<span class="string">"it's 10"</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .found(<span class="number">20</span>, []() &#123;</span><br><span class="line">    printl(<span class="string">"it's 20"</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .others([]() &#123;</span><br><span class="line">    printl(<span class="string">"nothing found"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="comment">// it's windows</span></span><br><span class="line"><span class="comment">// nothing found</span></span><br></pre></td></tr></table></figure><p>我想进一步实现<strong>自定义class</strong>的case，定义一个User类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  explicit User(int age) : age_(age) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> User&amp; user) <span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;age_ &lt; user.age(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> age_; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> age_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Switch如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">User u1(20), u2(22), ux(20);</span><br><span class="line">  select(ux)</span><br><span class="line">    .found(u1, []() &#123;</span><br><span class="line">      printl(<span class="string">"it's u1"</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .found(u2, []() &#123;</span><br><span class="line">      printl(<span class="string">"it's u2"</span>);</span><br><span class="line">    &#125;).done();</span><br><span class="line">  <span class="comment">// it's u2</span></span><br></pre></td></tr></table></figure><p>非常有必要说明的是这个重载：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> User&amp; user) <span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;age_ &lt; user.age(); &#125;</span><br></pre></td></tr></table></figure><p>返回bool没有问题，但为什么必须是operator&lt;呢，原因在这句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> kv = reflections_.find(target_);</span><br></pre></td></tr></table></figure><p>std::map&lt;&gt;::find不是通过==进行查找的，而是&lt;，因此必须重载&lt;。</p><p>该重载必须被const修饰，原因也是find这句里面，const对象只能调用const方法。</p><p>标准库里的实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">LIBCPP_TYPE_VIS_ONLY</span> <span class="title">less</span> :</span> binary_function&lt;_Tp, _Tp, <span class="keyword">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x, <span class="keyword">const</span> _Tp&amp; __y)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;<span class="keyword">return</span> __x &lt; __y;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以非常明显的看到const和&lt;。</p><p>此外我还实现了Switch之间的found块组合，比较简单就不阐述了。</p><h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><p>常量字符串的转型问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select(<span class="string">"condition"</span>)</span><br><span class="line">  .found(<span class="string">"case"</span>, ...)</span><br><span class="line">  .done();</span><br></pre></td></tr></table></figure><p>编译器将”condition”理解为const char[10]，数组类型有固定长度，found块的_case参数类型是const char[5]，导致编译错误。原因在于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Switch&amp; <span class="title">found</span><span class="params">(<span class="keyword">const</span> Ty&amp; _case, <span class="keyword">const</span> Scope&amp; callback)</span></span></span><br></pre></td></tr></table></figure><p>这里传递const引用，因此编译器把”case”当做了const char[5]。此时Ty的类型和说好的const char[10]不一致，编译失败。</p><p>解决方法是通过std::string来避免数组长度不匹配问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select(<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"condition"</span>))</span><br><span class="line">  .found(<span class="string">"case"</span>, ...)</span><br><span class="line">  .done();</span><br></pre></td></tr></table></figure><p>希望读者有更好地解决方案。</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>这里直接引用我项目里面的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PROGRAM_OPTIONS_SWITCH_HPP_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROGRAM_OPTIONS_SWITCH_HPP_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> program_options &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief The Switch template class.</span></span><br><span class="line"><span class="comment">* @param Ty The target type.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Ty&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Switch</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">void</span>)&gt; Scope;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">const</span> Ty, Scope&gt; Reflections;</span><br><span class="line"></span><br><span class="line">  Switch() : has_others_scope_(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Switch</span><span class="params">(<span class="keyword">const</span> Ty&amp; target)</span></span></span><br><span class="line">      : target_(target), has_others_scope_(false) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief Create a case block with an expression and a callback function.</span></span><br><span class="line"><span class="comment">   * @param _case The case expression, variable is allowed.</span></span><br><span class="line"><span class="comment">   * @param callback The callback function, can be a lambda expression.</span></span><br><span class="line"><span class="comment">   * @return The current Switch instance.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">Switch&amp; <span class="title">found</span><span class="params">(<span class="keyword">const</span> Ty&amp; _case, <span class="keyword">const</span> Scope&amp; callback)</span> </span>&#123;</span><br><span class="line">    reflections_[_case] = callback;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief Create a default block with a callback function,</span></span><br><span class="line"><span class="comment">   *        if no cases matched, this block will be called.</span></span><br><span class="line"><span class="comment">   * @param callback</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">others</span><span class="params">(<span class="keyword">const</span> Scope&amp; callback)</span> </span>&#123;</span><br><span class="line">    has_others_scope_ = <span class="literal">true</span>;</span><br><span class="line">    others_ = callback;</span><br><span class="line">    <span class="keyword">this</span>-&gt;done();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief Finish the cases,</span></span><br><span class="line"><span class="comment">   * others() will call this method automatically.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> kv = reflections_.find(target_);</span><br><span class="line">    <span class="keyword">if</span> (kv != reflections_.end()) &#123;</span><br><span class="line">      <span class="comment">// found</span></span><br><span class="line">      <span class="keyword">auto</span> scope = kv-&gt;second;</span><br><span class="line">      scope();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (has_others_scope_) &#123;</span><br><span class="line">      <span class="comment">// not found, call others</span></span><br><span class="line">      others_();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief Combine the cases to this Switch from another Switch.</span></span><br><span class="line"><span class="comment">   *        Note that this two Switch should be the same template.</span></span><br><span class="line"><span class="comment">   * @param _switch Another Switch instance.</span></span><br><span class="line"><span class="comment">   * @return</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> Switch&amp; <span class="title">combine</span><span class="params">(<span class="keyword">const</span> Switch&amp; _switch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> kv : _switch.reflections()) &#123;</span><br><span class="line">      <span class="keyword">this</span>-&gt;reflections_[kv.first] = kv.second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief Return the case-callback pairs.</span></span><br><span class="line"><span class="comment">   * @return</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> Reflections <span class="title">reflections</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> reflections_; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">const</span> Ty&amp; target_;</span><br><span class="line">  <span class="keyword">bool</span> has_others_scope_;</span><br><span class="line">  Scope others_;</span><br><span class="line">  Reflections reflections_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Define which expression does the Switch match.</span></span><br><span class="line"><span class="comment"> * @param expression</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Ty&gt;</span><br><span class="line">Switch&lt;Ty&gt; select(<span class="keyword">const</span> Ty&amp; expression) &#123;</span><br><span class="line">  <span class="keyword">return</span> Switch&lt;Ty&gt;(expression);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// PROGRAM_OPTIONS_SWITCH_HPP_</span></span></span><br></pre></td></tr></table></figure><p>欢迎各位读者指正。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近自己维护的一个项目&lt;a href=&quot;https://github.com/micooz/program_options&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;program_options&lt;/a&gt;(是一个命令行生成与解析的C++库)在实际应用的
      
    
    </summary>
    
    
      <category term="tech" scheme="https://apporz.com/tags/tech/"/>
    
      <category term="cpp" scheme="https://apporz.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>Google C++ Style Guide 笔记</title>
    <link href="https://apporz.com/2015/02/23/google-cpp-style-guide-note/"/>
    <id>https://apporz.com/2015/02/23/google-cpp-style-guide-note/</id>
    <published>2015-02-22T16:00:00.000Z</published>
    <updated>2017-12-08T13:17:42.226Z</updated>
    
    <content type="html"><![CDATA[<p>英文原版: <a href="http://google-styleguide.googlecode.com/svn/trunk/cppguide.html" target="_blank" rel="noopener">http://google-styleguide.googlecode.com/svn/trunk/cppguide.html</a></p><h1 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h1><p>每个源文件都要对应一个头文件。例外：单元测试文件和仅包含main的小型源文件。</p><h2 id="独立头文件"><a href="#独立头文件" class="headerlink" title="独立头文件"></a>独立头文件</h2><p>以.h结尾的都是应该是独立的，以.inc结尾的仅用作文本包含，所有头文件都必须是独立的。</p><p>inline和template函数的声明和定义(实现)应该在同一个文件中。</p><p>Note:这里的独立是指，用户和重构工具可以无特殊限制地包含头文件。</p><h2 id="define宏保护"><a href="#define宏保护" class="headerlink" title="define宏保护"></a>define宏保护</h2><p>所有头文件都应该使用#define来防止重复包含。格式如下：</p><p>头文件路径：foo/src/bar/baz.h</p><pre><code>&lt;!-- lang: cpp --&gt;#ifndef FOO_BAR_BAZ_H_#define FOO_BAR_BAZ_H_...#endif  // FOO_BAR_BAZ_H_</code></pre><h2 id="前置声明"><a href="#前置声明" class="headerlink" title="前置声明"></a>前置声明</h2><p>前置声明用来避免不必要的include，但有很多缺陷。</p><ul><li>当使用在一个头文件中已声明的函数时，总是include那个头文件</li><li>当使用类模板，最好include它的头文件</li><li>当使用一个一般的class时，可以进行前置声明，但是要小心它可能是不完整或不正确的，不确定时，就include合适的头文件</li><li>不要为了避免使用include而把数据成员换成指针</li></ul><h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>仅在函数少于10行时，才可以把函数定义为inline。</p><p>过度使用inline，实际上会使程序变慢。inline一个非常短的函数可以缩短代码长度，而inline一个很长的函数反而会戏剧性地增大代码长度。</p><p>小心析构函数，他们的代码通常比表面上的更长，因为存在虚函数和父析构函数调用。</p><p>虚函数和递归函数不应该被inline。</p><h2 id="参数顺序"><a href="#参数顺序" class="headerlink" title="参数顺序"></a>参数顺序</h2><p>顺序应该是：输入，输出</p><p>输入参数通常是按值，或按const引用传入。输出则是non-const的指针（引用也是指针实现的）。</p><p>当要新增一个参数时，应该按照上面顺序加入。</p><p>注意这个规则不是硬性的，可以放宽这个规则以确保一致性。</p><h2 id="includes的名称和顺序"><a href="#includes的名称和顺序" class="headerlink" title="includes的名称和顺序"></a>includes的名称和顺序</h2><p>顺序：</p><ol><li>关联的头文件 —-&gt; 确保编译当前源文件时提前报错，而不牵扯到别人的文件。</li><li>C库</li><li>C++库</li><li>第三方库</li><li>你的项目头文件</li></ol><p>每个部分再按字典顺序排列。例如：</p><pre><code>&lt;!-- lang: cpp --&gt;#include &quot;foo/server/fooserver.h&quot;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;hash_map&gt;#include &lt;vector&gt;#include &quot;base/basictypes.h&quot;#include &quot;base/commandlineflags.h&quot;#include &quot;foo/server/bar.h&quot;</code></pre><p>系统相关的头文件可用宏来限定，以减小代码和保持本地化。</p><pre><code>&lt;!-- lang: cpp --&gt;#include &quot;foo/public/fooserver.h&quot;#include &quot;base/port.h&quot;  // For LANG_CXX11.#ifdef LANG_CXX11#include &lt;initializer_list&gt;#endif  // LANG_CXX11</code></pre><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>在源文件中鼓励使用匿名命名空间（ namespace {…} ），对于非匿名命名空间则选取它的路径来命名。不要使用using namespace。不要使用inline命名空间。</p><h2 id="匿名命名空间"><a href="#匿名命名空间" class="headerlink" title="匿名命名空间"></a>匿名命名空间</h2><ol><li><p>可以避免链接期的名字冲突：</p><p>namespace { // This is in a .cc file.</p><p>// The content of a namespace is not indented.<br>//<br>// This function is guaranteed not to generate a colliding symbol<br>// with other symbols at link time, and is only visible to<br>// callers in this .cc file.<br>bool UpdateInternals(Frobber* f, int newval) {<br>…<br>}</p><p>} // namespace</p></li><li><p>不要在头文件中使用匿名命名空间。</p></li></ol><h2 id="含名称的命名空间"><a href="#含名称的命名空间" class="headerlink" title="含名称的命名空间"></a>含名称的命名空间</h2><ul><li><p>在includes，gflags声明和定义，其他命名空间中class的前置声明之后，包裹全部的代码：</p><p>// In the .h file<br>namespace mynamespace {</p><p>// All declarations are within the namespace scope.<br>// Notice the lack of indentation.<br>class MyClass {<br>public:</p><pre><code>...void Foo();</code></pre><p>};</p><p>} // namespace mynamespace<br>// In the .cc file<br>namespace mynamespace {</p><p>// Definition of functions is within scope of the namespace.<br>void MyClass::Foo() {</p><pre><code>...</code></pre><p>}</p><p>} // namespace mynamespace</p></li><li><p>不要在std中声明任何东西，也不要对标准库的class进行前置声明。</p></li><li><p>不要使用using namespace</p><p>// Forbidden – This pollutes the namespace.<br>using namespace foo;</p></li><li><p>可以在源文件的任意位置，在头文件的函数，方法，class中使用using声明</p><p>// OK in .cc files.<br>// Must be in a function, method or class in .h files.<br>using ::foo::bar;</p></li><li><p>别名命名空间可以在源文件的任意位置，头文件的namespace内，函数，方法内使用。</p><p>// Shorten access to some commonly used names in .cc files.<br>namespace fbz = ::foo::bar::baz;</p><p>// Shorten access to some commonly used names (in a .h file).<br>namespace librarian {<br>// The following alias is available to all files including<br>// this header (in namespace librarian):<br>// alias names should therefore be chosen consistently<br>// within a project.<br>namespace pd_s = ::pipeline_diagnostics::sidetable;</p><p>inline void my_inline_function() {</p><pre><code>// namespace alias local to a function (or method).namespace fbz = ::foo::bar::baz;...</code></pre><p>}<br>} // namespace librarian</p></li></ul><p>Note：尽量避免在公共头文件中使用别名命名空间。</p><ul><li>不要使用inline命名空间</li></ul><h2 id="成员类"><a href="#成员类" class="headerlink" title="成员类"></a>成员类</h2><pre><code>&lt;!-- lang: cpp --&gt;class Foo { private:  // Bar is a member class, nested within Foo.  class Bar {    ...  };};</code></pre><p>不要把成员类公开，除非他们确实是这个接口的一部分。</p><h2 id="非成员，静态成员和全局函数"><a href="#非成员，静态成员和全局函数" class="headerlink" title="非成员，静态成员和全局函数"></a>非成员，静态成员和全局函数</h2><p>最好在命名空间中使用非成员函数，或使用静态成员函数，而不要或很少使用全局函数。</p><p>非成员函数不应该依赖于外部变量，并且应该总处于一个命名空间中。</p><p>那些仅仅用来集结静态成员函数，且没有共享静态数据的类，应该用命名空间取而代之。</p><p>如果必须要使用非成员函数并且只在当前这个源文件中使用，则用一个匿名命名空间或static修饰来限制它的作用域。</p><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>将一个函数中的变量放到尽可能有限的作用域内，并在声明时初始化。</p><pre><code>&lt;!-- lang: cpp --&gt;int i;i = f();      // Bad -- initialization separate from declaration.int j = g();  // Good -- declaration has initialization.vector&lt;int&gt; v;v.push_back(1);  // Prefer initializing using brace initialization.v.push_back(2);vector&lt;int&gt; v = {1, 2};  // Good -- v starts initialized.</code></pre><p>一些供if,while,for使用的变量应该在statement处声明。</p><pre><code>&lt;!-- lang: cpp --&gt;while (const char* p = strchr(str, &apos;/&apos;)) str = p + 1;</code></pre><p>一点注意：如果是变量是一个对象，构造函数将在每次进入作用域时被执行，析构函数将在每次离开作用域时被执行。</p><pre><code>&lt;!-- lang: cpp --&gt;// Inefficient implementation:for (int i = 0; i &lt; 1000000; ++i) {  Foo f;  // My ctor and dtor get called 1000000 times each.  f.DoSomething(i);}// 对象放在外面更高效Foo f;  // My ctor and dtor get called once each.for (int i = 0; i &lt; 1000000; ++i) {  f.DoSomething(i);}</code></pre><h2 id="静态和全局变量"><a href="#静态和全局变量" class="headerlink" title="静态和全局变量"></a>静态和全局变量</h2><p>类的静态或全局变量是禁止使用的。然而constexpr的变量是被允许的，因为他们不会动态初始化或销毁。</p><p>静态存储的对象，包括全局变量，静态变量，静态类成员变量以及函数内静态变量，必须是Plain Old Data(POD)。</p><p>只有int,char,float,pointer,或者arrays/structs属于POD。</p><p>静态vector应该用C数组代替，静态string应该用const char []代替。</p><p>如果需要使用静态或全局类对象，考虑初使用它的指针类型（不会被order-of-destrctor释放掉），注意必须是一个纯的指针，而不是一个智能指针。</p><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><h2 id="构造函数该做的事"><a href="#构造函数该做的事" class="headerlink" title="构造函数该做的事"></a>构造函数该做的事</h2><p>避免在构造函数中进行复杂初始化，比如那些可能会失败或者进行虚函数调用的步骤。</p><p>构造函数不应该调用虚函数，或者试图抛出非致命性错误。如果你的对象需要进行重要的初始化工作，考虑使用一个工厂函数或init方法。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h2 id="明确构造函数"><a href="#明确构造函数" class="headerlink" title="明确构造函数"></a>明确构造函数</h2><p>在具有一个参数的构造函数上使用explicit关键字。因为构造时传入一个参数可能会被编译器当做拷贝构造进行隐式转换。</p><pre><code>&lt;!-- lang: cpp --&gt;explicit Foo(string name);</code></pre><p>除了构造函数的第一个参数外，其他参数都应该指定一个默认值,来防止不期望的类型转换。</p><pre><code>&lt;!-- lang: cpp --&gt;Foo::Foo(string name, int id = 42)</code></pre><p>拷贝构造函数，以及作为其他类的透明包装的类，不应该被explicit修饰。</p><h2 id="可拷贝和可移动类型"><a href="#可拷贝和可移动类型" class="headerlink" title="可拷贝和可移动类型"></a>可拷贝和可移动类型</h2><p>可拷贝的例子：std::string</p><p>可移动但不可拷贝的例子：std::unique_ptr<int></int></p><p>对于一些不需要拷贝操作的类型，提供拷贝操作符可能会产生混淆，无意义或者完全是不正确的。</p><p>基类的拷贝、赋值操作符是有风险的，他们会导致对象分裂。</p><p>如果要加入拷贝特性，就要同时定义拷贝构造函数和赋值操作符。</p><p>如果你的类型可拷贝，但移动操作符更高效，那么就同时定义移动操作。</p><p>避免给试图被继承的类提供赋值操作符或公开的拷贝/移动构造函数。</p><p>如果你的基类需要被拷贝，提供一个公开的虚Clone()方法，和一个保护的拷贝构造函数，来使子类能够实现它。</p><p>如果你不想支持拷贝/移动操作，使用 = delete 来明确地禁用它们。</p><h2 id="委托和继承构造函数"><a href="#委托和继承构造函数" class="headerlink" title="委托和继承构造函数"></a>委托和继承构造函数</h2><p>委托构造的例子：</p><pre><code>&lt;!-- lang: cpp --&gt;X::X(const string&amp; name) : name_(name) {  ...}X::X() : X(&quot;&quot;) { }</code></pre><p>继承构造的例子：</p><pre><code>&lt;!-- lang: cpp --&gt;class Base { public:  Base();  Base(int n);  Base(const string&amp; s);  ...};class Derived : public Base { public:  using Base::Base;  // Base&apos;s constructors are redeclared here.};</code></pre><p>在能减少冗余和改善可读性的前提下使用委托和继承。</p><h2 id="结构体-vs-类"><a href="#结构体-vs-类" class="headerlink" title="结构体 vs. 类"></a>结构体 vs. 类</h2><p>struct仅在存储数据时使用，否则使用class。</p><p>struct可以直接访问字段而不通过方法调用。struct内的方法只用来设置数据成员。</p><p>如果需要更多地函数支持，class更合适，如果不确定用哪个，就用class。</p><p>注意struct和class内的成员变量具有不同的命名方式。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>组合通常比继承更合适。当使用继承时，指明为public。</p><p>实际上，继承在C++中主要应用于两个方面：</p><ul><li>实现继承（最普通意义上的继承）</li><li>接口继承（仅继承方法，实现接口）</li></ul><p>所有的继承都应当是public的，如果你需要用private继承，你就应该保存一份基类的成员实例来替代private继承（达到private的效果）。</p><p>不要过度使用实现继承，因为代码实现被分散于子类和基类。</p><p>继承应该被限定为”is-a”的关系，即”子类是基类的特例”。</p><p>如果你的类中有虚函数，那么你的析构函数也必须是virtual。</p><p>数据成员应该是private的。</p><h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><p>仅有很少的多重实现继承是有用的。你通常可以找到一个不同的，更明确地，更干净的解决方案。</p><p>多继承仅允许在父类都是纯接口的时候使用。</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>一个类是纯接口的条件：</p><ul><li>只有public的纯虚函数（= 0）和静态方法（析构函数除外）</li><li>不含非静态的数据成员</li><li>不需要构造函数，如果有，一定没有参数以及被声明为protected</li><li>如果它是子类，它的父类也必须符合这些条件</li></ul><h2 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h2><p>不要重载那些很少使用的，特殊的操作符。不要给用户字面值定义操作符。</p><p>为了使类模板函数正常工作，你或许需要定义操作符。</p><p>虽然操作符重载可以使代码更简洁，但它有以下几个缺点：</p><ul><li>它会让我们以为原本高代价的操作是划算的</li><li>不便于寻找到底调用了那个方法，例如Equals()要比==更方便查找</li><li>许多操作符对指针也有效，很容易出bug。例如：Foo + 4和 &amp;Foo + 4截然不同</li><li>用户字面值允许创造出新的句法，即使经验丰富的C++程序员也会觉得陌生</li></ul><p>重载也会出现意想不到的后果，比如，一个类重载了一元operator&amp;，它将不能安全的被前置声明。</p><p>一般而言，不要定义操作符重载。需要时你可以用普通的函数例如Equals()来替代。</p><p>不要重载operator””，即用户字面值。</p><p>当然，有些情况下可以进行重载，例如对标准C++库：</p><pre><code>&lt;!-- lang: cpp --&gt;operator&lt;&lt;(ostream&amp;, const T&amp;) for logging</code></pre><h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><p>使数据成员是private的，然后提供访问函数（getter/setter）来访问它们。例如：一个叫做foo_的变量有一个foo()访问函数，或者set_foo()。</p><p>例外：static const 数据成员(kFoo)不应该是private。</p><p>访问器的定义通常是内联在头文件中的。</p><h2 id="声明顺序"><a href="#声明顺序" class="headerlink" title="声明顺序"></a>声明顺序</h2><p>public: protected: private: ；方法在数据成员之前。</p><p>每个区块内的顺序：</p><ul><li>typedef &amp; enum</li><li>常量（包括静态数据成员）</li><li>构造函数</li><li>析构函数</li><li>方法（包括静态方法）</li><li>数据成员（静态数据除外）</li></ul><p>友元函数总是在private内声明。</p><p>在源文件中的方法定义应该和声明顺序尽量保持一致。</p><h2 id="写出短小的函数"><a href="#写出短小的函数" class="headerlink" title="写出短小的函数"></a>写出短小的函数</h2><p>书写短小的，清晰地函数。如果一个函数超过40行，可以考虑是否可以在不改变程序结构的前提下进行分割。</p><h1 id="Google经验技巧"><a href="#Google经验技巧" class="headerlink" title="Google经验技巧"></a>Google经验技巧</h1><h2 id="所有权和智能指针"><a href="#所有权和智能指针" class="headerlink" title="所有权和智能指针"></a>所有权和智能指针</h2><p>最好使用std::unique_ptr来使所有权传递更明确：</p><pre><code>&lt;!-- lang: cpp --&gt;std::unique_ptr&lt;Foo&gt; FooFactory();void FooConsumer(std::unique_ptr&lt;Foo&gt; ptr);</code></pre><p>在没有一个非常好的理由的前提下，不要把你的代码设计为共享所有权。</p><p>不要再新的代码中使用scoped_ptr除非为了适配老版本的C++。</p><p>不要使用std::auto_ptr，用std::unique_ptr代替。</p><h2 id="cpplint"><a href="#cpplint" class="headerlink" title="cpplint"></a>cpplint</h2><p>使用cpplint.py来检查风格错误。</p><h1 id="其他C-特性"><a href="#其他C-特性" class="headerlink" title="其他C++特性"></a>其他C++特性</h1><h2 id="引用参数"><a href="#引用参数" class="headerlink" title="引用参数"></a>引用参数</h2><p>所有按引用传递的参数必须被const修饰。</p><pre><code>&lt;!-- lang: cpp --&gt;void Foo(const string &amp;in, string *out);</code></pre><p>有些情况下用const T* 做输入参数比const T&amp;好：</p><ul><li>要传递一个空指针</li><li>该函数将指针或引用保存到输入参数</li></ul><p>记住大多数时候输入参数都写为const T&amp;。</p><h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><p>右值引用只在move构造函数以及move赋值操作符定义时使用，不要使用std::forward。</p><ul><li>在move构造函数中应用右值引用，可以实现移动数据而不是复制数据，例如：auto v2(std::move(v1))会把v1数据移动到v2中，而不是完全复制一遍，可用于性能提升。</li><li>无论参数是否为临时对象，右值引用都可以经行参数传递。</li><li>右值引用对于没有明确定义拷贝操作，但你仍想向其传递参数的函数有很大的意义，比如向容器内存放数据而不需要copy。</li><li>std::move对高效使用一些标准库类型，例如std::unique_ptr很有必要。</li><li>右值引用作为C++11的新特性，还没有被广泛得理解和应用。</li></ul><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>如果一个函数依靠参数类型的不同来进行重载，读者可能必须理解C++的复杂匹配机制来确定接下来会发生什么。</p><p>如果你像重载一个函数，考虑给出一些信息对参数进行限定，例如使用AppendString(), AppendInt()而不仅仅是Append()。</p><h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><p>除了下面几个情形，我们不允许默认函数参数。如果合适的话，请用函数重载在替代。</p><p>当默认参数做函数指针时容易使人混淆，因为函数签名常常不会匹配调用。加入默认参数时会改变函数的类型，这样会在获取它的地址时造成一些问题。使用函数重载可以避免这个问题。</p><p>一些例外：</p><p>当一个静态函数出现在源文件中时，由于本地化的缘故上述规则不再适用。</p><p>另外，默认参数可在构造函数中使用，上述规则也不适用，因为不可能获取到构造函数的地址。</p><p>还有一个例外是默认参数用来模拟变长数组时，例如：</p><pre><code>&lt;!-- lang: cpp --&gt;// Support up to 4 params by using a default empty AlphaNum.string StrCat(const AlphaNum &amp;a,              const AlphaNum &amp;b = gEmptyAlphaNum,              const AlphaNum &amp;c = gEmptyAlphaNum,              const AlphaNum &amp;d = gEmptyAlphaNum);</code></pre><h2 id="变长数组和alloca"><a href="#变长数组和alloca" class="headerlink" title="变长数组和alloca()"></a>变长数组和alloca()</h2><p>我们不允许使用变长数组或者alloca()</p><p>变长数组和alloca()并不是标准C++的一部分。更重要的是，他会在栈空间中分配大量的空间，可能会触发内存覆盖的bug：在我机器上运行的好好的，在生产环境却死掉了。。</p><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>友元通常都应该被定义在同一个文件中。</p><p>通常会定义一个FooBuilder作为Foo的一个友元。</p><p>在创建一个单元测试的时候，使用友元很管用。</p><h2 id="例外"><a href="#例外" class="headerlink" title="例外"></a>例外</h2><p>我们不使用C++的exceptions。</p><h2 id="运行时类型信息（RTTI）"><a href="#运行时类型信息（RTTI）" class="headerlink" title="运行时类型信息（RTTI）"></a>运行时类型信息（RTTI）</h2><p>避免使用RTTI。</p><p>在运行时查询对象的类型可以说是一个错误的设计问题。</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>使用C++的类型转换如static_cast<int>()。而不要用C-style的int y = (int)x或者int y = int(x)。</int></p><p>使用const_cast来除去const限定，只在你知道你在做什么的情况下，使用reinterpret_cast来做不安全的指针转换。</p><h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><p>流仅用于日志。使用类似printf的形式来代替流。</p><h2 id="前加和前减"><a href="#前加和前减" class="headerlink" title="前加和前减"></a>前加和前减</h2><p>在迭代器和其他模板对象上使用前加或前减。</p><p>当表达式的返回值被忽略时，++i比i++更高效。如果i是一个迭代器，由于i++的复制，开销很大。</p><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>只要讲得通，随时随地使用const。C++11中的constexpr是更好的选择。</p><ul><li>如果一个函数不会修改按引用传递，指针传递的参数，那么这个参数应该是const。</li><li>如果可以，把方法声明为const。访问器应该总是const的。其他方法如果不修改任何数据成员，不调用任何非const方法，不返回非const指针或非const引用，也应该修饰为const。</li><li>数据成员在构造函数执行之后不会被修改，应该声明为const。</li></ul><p>const应该放在哪儿？</p><pre><code>&lt;!-- lang: cpp --&gt;int const *foo;const int* foo;</code></pre><p>把const放在第一位具有更好地可读性，因为它符合英语的习惯：形容词（const），然后是名词（int）。</p><h2 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h2><p>在C++11中，可以使用constexpr来定义真实地常量或者确保常量初始化。</p><h2 id="整形"><a href="#整形" class="headerlink" title="整形"></a>整形</h2><p>&lt;stdint.h&gt;中定义了一些不同长度的整形：int16_t, uint32_t, int64_t 等等。你应该总是使用这些整形，特别是你需要保证整形的长度时。</p><p>当我们认为一个整数”比较大”时，用int64_t。</p><p>你不应该使用无符号整形，如uint32_t，除非有一个合理的原因。特别的，不要认为使用了无符号类型它就不会是负数，使用断言来检验正负。</p><p>如果你需要接收一个容器的大小，确保你的类型能够容纳这个数字，否则使用一个更大的类型。</p><p>注意整形转换、类型提升可能会导致非预期行为。</p><p>关于无符号整形</p><pre><code>&lt;!-- lang: cpp --&gt;for (unsigned int i = foo.Length()-1; i &gt;= 0; --i) ...</code></pre><p>这将是一个死循环，因为unsigned int 和 int 比较。因此使用断言来证明非负。不要使用无符号类型来表示非负数。</p><h2 id="预处理宏"><a href="#预处理宏" class="headerlink" title="预处理宏"></a>预处理宏</h2><p>最好使用内联函数、枚举和const量代替宏。在使用宏之前，考虑是否有非宏的解决方案。</p><p>如果你使用了宏，应该注意：</p><ul><li>不要在头文件中定义宏</li><li>使用前正确定义它，使用后undef它</li><li>不要仅仅是为了替换为自己的而undef一个宏，应该取一个唯一的新名字</li><li>最好不要用##来生成函数、类、变量名</li></ul><h2 id="0-、nullptr、NULL"><a href="#0-、nullptr、NULL" class="headerlink" title="0 、nullptr、NULL"></a>0 、nullptr、NULL</h2><p>用0表示整形，0.0表示实数、nullptr（或NULL）表示指针，’\0’表示字符。</p><p>特别在一些情况下，sizeof(NULL)和sizeof(0)不同。</p><h2 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h2><p>最好使用sizeof(varname)而非sizeof(type)。因为当var改变时，sizeof(type)不会改变而sizeof(varname)会跟着改变。</p><pre><code>&lt;!-- lang: cpp --&gt;Struct data;memset(&amp;data, 0, sizeof(data));memset(&amp;data, 0, sizeof(Struct));if (raw_size &lt; sizeof(int)) {  LOG(ERROR) &lt;&lt; &quot;compressed record not big enough for count: &quot; &lt;&lt; raw_size;  return false;}</code></pre><h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h2><p>只在类型名十分混乱时使用auto，如果能增加可读性，继续使用完整地类型声明，除了局部变量外不要到处都用auto。</p><p>不要在文件域，命名空间域，类成员中使用auto。从不对大括号初始化列表使用auto。</p><h2 id="括号初始化列表"><a href="#括号初始化列表" class="headerlink" title="括号初始化列表"></a>括号初始化列表</h2><p>一些例子：</p><pre><code>&lt;!-- lang: cpp --&gt;// Basically the same, ignoring some small technicalities.// You may choose to use either form.vector&lt;string&gt; v = {&quot;foo&quot;, &quot;bar&quot;};// Usable with &apos;new&apos; expressions.auto p = new vector&lt;string&gt;{&quot;foo&quot;, &quot;bar&quot;};// A map can take a list of pairs. Nested braced-init-lists work.map&lt;int, string&gt; m = {{1, "one"}, {2, "2"}};// A braced-init-list can be implicitly converted to a return type.vector&lt;int&gt; test_function() { return {1, 2, 3}; }// Iterate over a braced-init-list.for (int i : {-1, -2, -3}) {}// Call a function using a braced-init-list.void TestFunction2(vector&lt;int&gt; v) {}TestFunction2({1, 2, 3});</code></pre><p>也可以给自己的类型定义初始化列表：</p><pre><code>&lt;!-- lang: cpp --&gt;class MyType { public:  // std::initializer_list references the underlying init list.  // It should be passed by value.  MyType(std::initializer_list&lt;int&gt; init_list) {    for (int i : init_list) append(i);  }  MyType&amp; operator=(std::initializer_list&lt;int&gt; init_list) {    clear();    for (int i : init_list) append(i);  }};MyType m{2, 3, 5, 7};</code></pre><p>在没有使用std::initializer_list<t>的情况下也可以：</t></p><pre><code>&lt;!-- lang: cpp --&gt;double d{1.23};// Calls ordinary constructor as long as MyOtherType has no// std::initializer_list constructor.class MyOtherType { public:  explicit MyOtherType(string);  MyOtherType(int, string);};MyOtherType m = {1, &quot;b&quot;};// If the constructor is explicit, you can&apos;t use the &quot;= {}&quot; form.MyOtherType m{&quot;b&quot;};</code></pre><p>不要给{}使用auto：</p><pre><code>&lt;!-- lang: cpp --&gt;auto d = {1.23};        // d is a std::initializer_list&lt;double&gt;auto d = double{1.23};  // Good -- d is a double, not a std::initializer_list.</code></pre><h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p>在适当的条件下用lambda表达式，不要使用默认的lambda捕获，把所有捕获明确地写出来。</p><p>如果匿名函数超过了5行，考虑给它起一个名字或者使用一个有名函数代替lambda表达式。</p><h2 id="C-11"><a href="#C-11" class="headerlink" title="C++11"></a>C++11</h2><p>合适的时候，用C++11编写的类库。在使用C++11之前，考虑好对其他环境的可移植性。</p><h1 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h1><h2 id="普遍命名规则"><a href="#普遍命名规则" class="headerlink" title="普遍命名规则"></a>普遍命名规则</h2><p>函数名，变量名和文件名应该是具有描述性的，而不是缩略的。</p><pre><code>&lt;!-- lang: cpp --&gt;int price_count_reader;    // No abbreviation.int num_errors;            // &quot;num&quot; is a widespread convention.int num_dns_connections;   // Most people know what &quot;DNS&quot; stands for.int n;                     // Meaningless.int nerr;                  // Ambiguous abbreviation.int n_comp_conns;          // Ambiguous abbreviation.int wgc_connections;       // Only your group knows what this stands for.int pc_reader;             // Lots of things can be abbreviated &quot;pc&quot;.int cstmr_id;              // Deletes internal letters.</code></pre><h2 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h2><p>文件名都该是小写的，并且可以包含下划线<em>或者短划线-。如果你的项目没有约定，最好用下划线</em>。</p><p>一些例子：</p><pre><code>&lt;!-- lang: cpp --&gt;my_useful_class.ccmy-useful-class.ccmyusefulclass.ccmyusefulclass_test.cc // _unittest and _regtest are deprecated.</code></pre><p>不要使用在/usr/include中已近存在的文件名，例如：db.h</p><p>普遍地，明确你的文件名。例如：http_server_logs.h 比 logs.h 好很多。</p><p>如果内联函数非常短，应该直接写在头文件中。</p><h2 id="类型名"><a href="#类型名" class="headerlink" title="类型名"></a>类型名</h2><p>类型名以大写字母开头，并且每个词开头都是大写的：MyExcitingClass, MyExcitingEnum。</p><pre><code>&lt;!-- lang: cpp --&gt;// classes and structsclass UrlTable { ...class UrlTableTester { ...struct UrlTableProperties { ...// typedefstypedef hash_map&lt;UrlTableProperties *, string&gt; PropertiesMap;// enumsenum UrlTableErrors { ...</code></pre><h2 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h2><p>变量和数据成员都是小写的，单词间有下划线：a_local_variable, a_struct_data_member, a_class_data_member_。</p><pre><code>&lt;!-- lang: cpp --&gt;string table_name;  // OK - uses underscore.string tablename;   // OK - all lowercase.string tableName;   // Bad - mixed case.</code></pre><p>类数据成员，末尾一个下划线：</p><pre><code>&lt;!-- lang: cpp --&gt;class TableInfo {  ... private:  string table_name_;  // OK - underscore at end.  string tablename_;   // OK.  static Pool&lt;TableInfo&gt;* pool_;  // OK.};</code></pre><p>结构体数据成员，末尾没有下划线：</p><pre><code>&lt;!-- lang: cpp --&gt;struct UrlTableProperties {  string name;  int num_entries;  static Pool&lt;UrlTableProperties&gt;* pool;};</code></pre><p>全局变量，没有一个特定的规则。如果你需要一个规则，考虑给全局变量加上g_前缀，来区分局部变量。</p><h2 id="常量名"><a href="#常量名" class="headerlink" title="常量名"></a>常量名</h2><p>在常量之前加上k，例如：const int kDaysInWeek = 7。</p><h2 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h2><p>和变量命名方式相似，但可以是大小写混合：</p><pre><code>&lt;!-- lang: cpp --&gt;MyExcitingFunction(), MyExcitingMethod(), my_exciting_member_variable(), set_my_exciting_member_variable().</code></pre><p>访问器(get)和修改器(set)应该匹配要访问或修改的那个变量名：</p><pre><code>&lt;!-- lang: cpp --&gt;class MyClass { public:  ...  int num_entries() const { return num_entries_; }  void set_num_entries(int num_entries) { num_entries_ = num_entries; } private:  int num_entries_;};</code></pre><h2 id="命名空间名"><a href="#命名空间名" class="headerlink" title="命名空间名"></a>命名空间名</h2><p>全为小写，并且尽可能是表示目录结构：google_awesome_project.</p><h2 id="枚举名"><a href="#枚举名" class="headerlink" title="枚举名"></a>枚举名</h2><pre><code>&lt;!-- lang: cpp --&gt;enum UrlTableErrors {  kOK = 0,  kErrorOutOfMemory,  kErrorMalformedInput,};enum AlternateUrlTableErrors {  OK = 0,  OUT_OF_MEMORY = 1,  MALFORMED_INPUT = 2,};</code></pre><h2 id="宏名"><a href="#宏名" class="headerlink" title="宏名"></a>宏名</h2><p>通常情况下宏不应该被使用，然而它又绝对是需要的，宏名应该全为大写。</p><pre><code>&lt;!-- lang: cpp --&gt;#define ROUND(x) ...#define PI_ROUNDED 3.0</code></pre><h2 id="命名规则的例外"><a href="#命名规则的例外" class="headerlink" title="命名规则的例外"></a>命名规则的例外</h2><p>如果你在为现存的C/C++代码工作，依据现存的命名方式，例如：</p><pre><code>&lt;!-- lang: cpp --&gt;bigopen()    function name, follows form of open()uint    typedefbigpos    struct or class, follows form of possparse_hash_map    STL-like entity; follows STL naming conventionsLONGLONG_MAX    a constant, as in INT_MAX</code></pre><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>为你的读者写注释，因为下一个读者也许就是你。</p><h2 id="注释风格"><a href="#注释风格" class="headerlink" title="注释风格"></a>注释风格</h2><p>保持//和/**/的一致性，通常//更普遍。</p><h2 id="文件注释"><a href="#文件注释" class="headerlink" title="文件注释"></a>文件注释</h2><p>以许可协议（例如：Apache 2.0, BSD, LGPL, GPL）开头，接下来是关于内容的描述。</p><p>如果你对一个已近存在作者标记的文件进行了修改，请删除作者那一行。</p><p>不要重复在头文件和源文件中书写注释。</p><h2 id="类注释"><a href="#类注释" class="headerlink" title="类注释"></a>类注释</h2><p>每个类定义都应该有一个用于描述它的作用，如何使用的注释：</p><pre><code>&lt;!-- lang: cpp --&gt;// Iterates over the contents of a GargantuanTable.  Sample usage://    GargantuanTableIterator* iter = table-&gt;NewIterator();//    for (iter-&gt;Seek(&quot;foo&quot;); !iter-&gt;done(); iter-&gt;Next()) {//      process(iter-&gt;key(), iter-&gt;value());//    }//    delete iter;class GargantuanTableIterator {  ...};</code></pre><h2 id="函数注释"><a href="#函数注释" class="headerlink" title="函数注释"></a>函数注释</h2><pre><code>&lt;!-- lang: cpp --&gt;// Returns an iterator for this table.  It is the client&apos;s// responsibility to delete the iterator when it is done with it,// and it must not use the iterator once the GargantuanTable object// on which the iterator was created has been deleted.//// The iterator is initially positioned at the beginning of the table.//// This method is equivalent to://    Iterator* iter = table-&gt;NewIterator();//    iter-&gt;Seek(&quot;&quot;);//    return iter;// If you are going to immediately seek to another place in the// returned iterator, it will be faster to use NewIterator()// and avoid the extra seek.Iterator* GetIterator() const;</code></pre><p>去掉不必要的注释：</p><pre><code>&lt;!-- lang: cpp --&gt;// Returns true if the table cannot hold any more entries.bool IsTableFull();</code></pre><h2 id="变量注释"><a href="#变量注释" class="headerlink" title="变量注释"></a>变量注释</h2><p>应该说明这个变量用来干什么，在特定的情况下，需要更多的注释。例如：</p><pre><code>&lt;!-- lang: cpp --&gt;private: // Keeps track of the total number of entries in the table. // Used to ensure we do not go over the limit. -1 means // that we don&apos;t yet know how many entries the table has. int num_total_entries_;</code></pre><p>所有的全局变量都应该给出一个注释，来描述它用来做什么。</p><pre><code>&lt;!-- lang: cpp --&gt;// The total number of tests cases that we run through in this regression test.const int kNumTestCases = 6;</code></pre><h2 id="实现注释"><a href="#实现注释" class="headerlink" title="实现注释"></a>实现注释</h2><p>一些难懂的，复杂的代码块应该被注释：</p><pre><code>&lt;!-- lang: cpp --&gt;// Divide result by two, taking into account that x// contains the carry from the add.for (int i = 0; i &lt; result-&gt;size(); i++) {  x = (x &lt;&lt; 8) + (*result)[i];  (*result)[i] = x &gt;&gt; 1;  x &amp;= 1;}</code></pre><p>意义不明显的行末应该空两个字符并给出注释：</p><pre><code>&lt;!-- lang: cpp --&gt;// If we have enough memory, mmap the data portion too.mmap_budget = max&lt;int64&gt;(0, mmap_budget - index_-&gt;length());if (mmap_budget &gt;= data_size_ &amp;&amp; !MmapData(mmap_chunk_bytes, mlock))  return;  // Error already logged.</code></pre><p>如果接下来的几行都有注释，最好排列起来增强可读性：</p><pre><code>&lt;!-- lang: cpp --&gt;DoSomething();                           // Comment here so the comments line up.DoSomethingElseThatIsLonger();  // Two spaces between the code and the comment.{ // One space before comment when opening a new scope is allowed,  // thus the comment lines up with the following comments and code.  DoSomethingElse();  // Two spaces before line comments normally.}vector&lt;string&gt; list{// Comments in braced lists describe the next element ..                    &quot;First item&quot;,                    // .. and should be aligned appropriately.                    &quot;Second item&quot;};DoSomething(); /* For trailing block comments, one space is fine. */</code></pre><p>当你传递一个空指针，布尔值或者字面整形值时，你应该考虑添加注释来说明他们是什么，或者使你的代码自我注释：</p><pre><code>&lt;!-- lang: cpp --&gt;bool success = CalculateSomething(interesting_value,                                  10,                                  false,                                  NULL);  // What are these arguments??versus:bool success = CalculateSomething(interesting_value,                                  10,     // Default base value.                                  false,  // Not the first time we&apos;re calling this.                                  NULL);  // No callback.Or alternatively, constants or self-describing variables:const int kDefaultBaseValue = 10;const bool kFirstTimeCalling = false;Callback *null_callback = NULL;bool success = CalculateSomething(interesting_value,                                  kDefaultBaseValue,                                  kFirstTimeCalling,                                  null_callback);</code></pre><p>切记不要描述代码自身：</p><pre><code>&lt;!-- lang: cpp --&gt;// Now go through the b array and make sure that if i occurs,// the next element is i+1....        // Geez.  What a useless comment.</code></pre><h2 id="标点，拼写和语法"><a href="#标点，拼写和语法" class="headerlink" title="标点，拼写和语法"></a>标点，拼写和语法</h2><p>完整的句子往往比句子片段更容易理解。</p><h2 id="TODO-注释"><a href="#TODO-注释" class="headerlink" title="TODO 注释"></a>TODO 注释</h2><p>使用TODO注释是一个临时的，短期的解决方案，很好的但不是完美的。</p><p>当你创建一个TODO时，总是给出你的名字：</p><pre><code>&lt;!-- lang: cpp --&gt;// TODO(kl@gmail.com): Use a &quot;*&quot; here for concatenation operator.// TODO(Zeke) change this to use relations.</code></pre><h2 id="弃用注释"><a href="#弃用注释" class="headerlink" title="弃用注释"></a>弃用注释</h2><p>使用DEPRECATED注释标记一个弃用的接口。</p><p>在DEPRECATED之后写出你的名字，email地址或其他能标识你的信息。</p><p>弃用注释必须包含简易的，清楚的指引来帮助使用者修复他们的问题。C++中，你可以将弃用的方法放在内联函数中，然后调用新的接口。</p><h1 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h1><h2 id="行长度"><a href="#行长度" class="headerlink" title="行长度"></a>行长度</h2><p>一行最多80个字符。</p><p>一些原始字符串可能会超出80个字符，除了测试外，这样的字符串应该出现在该文件的顶部。</p><p>#include 语句可能会超过80列。</p><h2 id="非ascii字符"><a href="#非ascii字符" class="headerlink" title="非ascii字符"></a>非ascii字符</h2><p>非ascii字符很少出现，但必须使用UTF-8编码。</p><p>十六进制也可以使用，在那些需要加强可读性的地方更建议使用。</p><p>你不应该使用C++11提供的char116_t和char32_t，因为他们用于非UTF8得文本。同样的，，你也不应该使用wchar_t，除非你是在用Windows API编写程序。</p><h2 id="空格和制表符"><a href="#空格和制表符" class="headerlink" title="空格和制表符"></a>空格和制表符</h2><p>只用空格并且缩进两个字符。</p><h2 id="函数声明和定义"><a href="#函数声明和定义" class="headerlink" title="函数声明和定义"></a>函数声明和定义</h2><p>返回类型出现在函数名的同一行，如果能适应，参数也出现在同一行。如果不能适应，折行书写参数表。</p><pre><code>&lt;!-- lang: cpp --&gt;ReturnType ClassName::FunctionName(Type par_name1, Type par_name2) {  DoSomething();  ...}If you have too much text to fit on one line:ReturnType ClassName::ReallyLongFunctionName(Type par_name1, Type par_name2,                                             Type par_name3) {  DoSomething();  ...}or if you cannot fit even the first parameter:ReturnType LongClassName::ReallyReallyReallyLongFunctionName(    Type par_name1,  // 4 space indent    Type par_name2,    Type par_name3) {  DoSomething();  // 2 space indent  ...}</code></pre><p>需要指出：</p><ul><li>如果不能把返回类型和函数名放在同一行，请折行</li><li>如果折行书写了返回类型，不要缩进</li><li>左圆括号始终和函数名处在同一行</li><li>括号和参数之间没有空格</li><li>左花括号始终和最后一个参数在同一行</li><li>右花括号在最后一行或者和左花括号在同一行</li><li>右小括号和左花括号之间有一个空格</li><li>所有参数都改命名，无论是在头文件，或者源文件中</li><li>如果可能，所有参数都要对齐</li><li>默认缩进2个字符</li><li>折行的参数有4个字符缩进</li></ul><p>如果一些参数未使用，在函数声明处注释出来：</p><pre><code>&lt;!-- lang: cpp --&gt;// Always have named parameters in interfaces.class Shape { public:  virtual void Rotate(double radians) = 0;};// Always have named parameters in the declaration.class Circle : public Shape { public:  virtual void Rotate(double radians);};// Comment out unused named parameters in definitions.void Circle::Rotate(double /*radians*/) {}// Bad - if someone wants to implement later, it&apos;s not clear what the// variable means.void Circle::Rotate(double) {}</code></pre><h2 id="lambda表达式-1"><a href="#lambda表达式-1" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p>像其他函数一样格式化参数和函数体，捕获表如其他逗号分隔的列表。</p><pre><code>&lt;!-- lang: cpp --&gt;int x = 0;auto add_to_x = [&amp;x](int n) { x += n; };</code></pre><p>简短的lambda表达式应该作为函数参数内联：</p><pre><code>&lt;!-- lang: cpp --&gt;std::set&lt;int&gt; blacklist = {7, 8, 9};std::vector&lt;int&gt; digits = {3, 9, 1, 8, 4, 7, 1};digits.erase(std::remove_if(digits.begin(), digits.end(), [&amp;blacklist](int i) {               return blacklist.find(i) != blacklist.end();             }),             digits.end());</code></pre><h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>将函数调用写在一行，用小括号包裹参数；或者将参数置于新行，用4个空格缩进。使用最小的行数。</p><p>如下格式：</p><pre><code>&lt;!-- lang: cpp --&gt;bool retval = DoSomething(argument1, argument2, argument3);</code></pre><p>如果参数太多，折行书写，括号左右不要有空格。</p><pre><code>&lt;!-- lang: cpp --&gt;bool retval = DoSomething(averyveryveryverylongargument1,                                        argument2, argument3);if (...) {  ...  ...  if (...) {    DoSomething(        argument1, argument2,  // 4 space indent        argument3, argument4);  }</code></pre><h2 id="花括号初始化列表格式"><a href="#花括号初始化列表格式" class="headerlink" title="花括号初始化列表格式"></a>花括号初始化列表格式</h2><pre><code>&lt;!-- lang: cpp --&gt;// Examples of braced init list on a single line.return {foo, bar};functioncall({foo, bar});pair&lt;int, int&gt; p{foo, bar};// When you have to wrap.SomeFunction(    {&quot;assume a zero-length name before {&quot;},    some_other_function_parameter);SomeType variable{    some, other, values,    {&quot;assume a zero-length name before {&quot;},    SomeOtherType{        &quot;Very long string requiring the surrounding breaks.&quot;,        some, other values},    SomeOtherType{&quot;Slightly shorter string&quot;,                  some, other, values}};SomeType variable{    &quot;This is too long to fit all in one line&quot;};MyType m = {  // Here, you could also break before {.    superlongvariablename1,    superlongvariablename2,    {short, interior, list},    {interiorwrappinglist,     interiorwrappinglist2}};</code></pre><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p>最好括号内无空格。if和else关键字属于分立的行中。</p><pre><code>&lt;!-- lang: cpp --&gt;if(condition) {   // Bad - space missing after IF.if (condition){   // Bad - space missing before {.if(condition){    // Doubly bad.if (condition) {  // Good - proper space after IF and before {.</code></pre><p>简短的条件块可以写在一行，如果能强化可读性。</p><pre><code>&lt;!-- lang: cpp --&gt;if (x == kFoo) return new Foo();if (x == kBar) return new Bar();</code></pre><p>如果含有else块，则不允许写在一行：</p><pre><code>&lt;!-- lang: cpp --&gt;// Not allowed - IF statement on one line when there is an ELSE clauseif (x) DoThis();else DoThat();</code></pre><p>一般而言，单行条件语句不需要花括号，如果你喜欢也可以加上，特别是在循环中存在复杂的条件时，使用花括号可增加可读性。有些项目还要求if块必须含有完整地括号对。</p><p>然而，if-else一部分使用了花括号，那么所有块都必须使用：</p><pre><code>&lt;!-- lang: cpp --&gt;// Not allowed - curly on IF but not ELSEif (condition) {  foo;} else  bar;// Not allowed - curly on ELSE but not IFif (condition)  foo;else {  bar;}// Curly braces around both IF and ELSE required because// one of the clauses used braces.if (condition) {  foo;} else {  bar;}</code></pre><h2 id="循环和选择语句"><a href="#循环和选择语句" class="headerlink" title="循环和选择语句"></a>循环和选择语句</h2><p>switch块必须包含default，如果default永不会被执行，则写一个assert：</p><pre><code>&lt;!-- lang: cpp --&gt;switch (var) {  case 0: {  // 2 space indent    ...      // 4 space indent    break;  }  case 1: {    ...    break;  }  default: {    assert(false);  }}</code></pre><p>空的case块用花括号括起来。</p><p>单语句循环，花括号可以省略，空循环用花括号括起来或者写continue，而不仅仅是分号。</p><pre><code>&lt;!-- lang: cpp --&gt;while (condition) {  // Repeat test until it returns false.}for (int i = 0; i &lt; kSomeNumber; ++i) {}  // Good - empty body.while (condition) continue;  // Good - continue indicates no logic.while (condition);  // Bad - looks like part of do/while loop.</code></pre><h2 id="指针和引用表达式"><a href="#指针和引用表达式" class="headerlink" title="指针和引用表达式"></a>指针和引用表达式</h2><p>句号和箭头周围无空格：</p><pre><code>&lt;!-- lang: cpp --&gt;x = *p;p = &amp;x;x = r.y;x = r-&gt;y;</code></pre><p>当声明一个指针类型变量时，保证星号两侧仅有一个空格：</p><pre><code>&lt;!-- lang: cpp --&gt;// These are fine, space preceding.char *c;const string &amp;str;// These are fine, space following.char* c;    // but remember to do &quot;char* c, *d, *e, ...;&quot;!const string&amp; str;char * c;  // Bad - spaces on both sides of *const string &amp; str;  // Bad - spaces on both sides of &amp;</code></pre><h2 id="布尔表达式"><a href="#布尔表达式" class="headerlink" title="布尔表达式"></a>布尔表达式</h2><p>当一个布尔表达式超过标准行长度(80)时，保证折行书写的一致性。</p><pre><code>&lt;!-- lang: cpp --&gt;if (this_one_thing &gt; this_other_thing &amp;&amp;    a_third_thing == a_fourth_thing &amp;&amp;    yet_another &amp;&amp; last_one) {  ...}</code></pre><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>不要给return语句加上括号。仅在返回一个逻辑表达式的时候加括号。</p><pre><code>&lt;!-- lang: cpp --&gt;return result;                  // No parentheses in the simple case.// Parentheses OK to make a complex expression more readable.return (some_long_condition &amp;&amp;        another_condition);return (value);                // You wouldn&apos;t write var = (value);return(result);                // return is not a function!</code></pre><h2 id="变量和数组初始化"><a href="#变量和数组初始化" class="headerlink" title="变量和数组初始化"></a>变量和数组初始化</h2><p>可以选择=，()或者{}。下面都是正确的：</p><pre><code>&lt;!-- lang: cpp --&gt;int x = 3;int x(3);int x{3};string name = &quot;Some Name&quot;;string name(&quot;Some Name&quot;);string name{&quot;Some Name&quot;};</code></pre><p>当心{}会调用std::initializer_list 构造函数。为了避免这个问题，使用()：</p><pre><code>&lt;!-- lang: cpp --&gt;vector&lt;int&gt; v(100, 1);  // A vector of 100 1s.vector&lt;int&gt; v{100, 1};  // A vector of 100, 1.</code></pre><h2 id="预处理指令"><a href="#预处理指令" class="headerlink" title="预处理指令"></a>预处理指令</h2><p>总是在一行的开头书写，无论是不是在代码块内：</p><pre><code>&lt;!-- lang: cpp --&gt;// Good - directives at beginning of line  if (lopsided_score) {#if DISASTER_PENDING      // Correct -- Starts at beginning of line    DropEverything();# if NOTIFY               // OK but not required -- Spaces after #    NotifyClient();# endif#endif    BackToNormal();  }// Bad - indented directives  if (lopsided_score) {    #if DISASTER_PENDING  // Wrong!  The &quot;#if&quot; should be at beginning of line    DropEverything();    #endif                // Wrong!  Do not indent &quot;#endif&quot;    BackToNormal();  }</code></pre><h2 id="类格式化"><a href="#类格式化" class="headerlink" title="类格式化"></a>类格式化</h2><p>public,protected,private前面有一个空格：</p><pre><code>&lt;!-- lang: cpp --&gt;class MyClass : public OtherClass { public:      // Note the 1 space indent!  MyClass();  // Regular 2 space indent.  explicit MyClass(int var);  ~MyClass() {}  void SomeFunction();  void SomeFunctionThatDoesNothing() {  }  void set_some_var(int var) { some_var_ = var; }  int some_var() const { return some_var_; } private:  bool SomeInternalFunction();  int some_var_;  int some_other_var_;};</code></pre><p>注意：</p><ul><li>基类名和子类名放在一行</li><li>除了第一个public，其他关键字前需要空一行，这个规则在小型类中可选。</li><li>这些关键字下面不要有空行</li></ul><h2 id="构造函数初始化列表"><a href="#构造函数初始化列表" class="headerlink" title="构造函数初始化列表"></a>构造函数初始化列表</h2><p>初始化列表可以在一行内，也可以折行，前面缩进4个字符：</p><pre><code>&lt;!-- lang: cpp --&gt;// When it all fits on one line:MyClass::MyClass(int var) : some_var_(var), some_other_var_(var + 1) {}or// When it requires multiple lines, indent 4 spaces, putting the colon on// the first initializer line:MyClass::MyClass(int var)    : some_var_(var),             // 4 space indent      some_other_var_(var + 1) {  // lined up  ...  DoSomething();  ...}</code></pre><h2 id="命名空间格式"><a href="#命名空间格式" class="headerlink" title="命名空间格式"></a>命名空间格式</h2><p>命名空间内的内容不缩进。</p><pre><code>&lt;!-- lang: cpp --&gt;namespace {void foo() {  // Correct.  No extra indentation within namespace.  ...}}  // namespaceDo not indent within a namespace:namespace {  // Wrong.  Indented when it should not be.  void foo() {    ...  }}  // namespace</code></pre><h2 id="水平空格"><a href="#水平空格" class="headerlink" title="水平空格"></a>水平空格</h2><p>水平空格依赖于位置，不要行末添加空格。</p><pre><code>&lt;!-- lang: cpp --&gt;void f(bool b) {  // Open braces should always have a space before them.  ...int i = 0;  // Semicolons usually have no space before them.// Spaces inside braces for braced-init-list are optional.  If you use them,// put them on both sides!int x[] = { 0 };int x[] = {0};// Spaces around the colon in inheritance and initializer lists.class Foo : public Bar { public:  // For inline function implementations, put spaces between the braces  // and the implementation itself.  Foo(int b) : Bar(), baz_(b) {}  // No spaces inside empty braces.  void Reset() { baz_ = 0; }  // Spaces separating braces from implementation.  ...</code></pre><p>循环和条件，</p><pre><code>&lt;!-- lang: cpp --&gt;if (b) {          // Space after the keyword in conditions and loops.} else {          // Spaces around else.}while (test) {}   // There is usually no space inside parentheses.switch (i) {for (int i = 0; i &lt; 5; ++i) {// Loops and conditions may have spaces inside parentheses, but this// is rare.  Be consistent.switch ( i ) {if ( test ) {for ( int i = 0; i &lt; 5; ++i ) {// For loops always have a space after the semicolon.  They may have a space// before the semicolon, but this is rare.for ( ; i &lt; 5 ; ++i) {  ...// Range-based for loops always have a space before and after the colon.for (auto x : counts) {  ...}switch (i) {  case 1:         // No space before colon in a switch case.    ...  case 2: break;  // Use a space after a colon if there&apos;s code after it.</code></pre><p>操作符，</p><pre><code>&lt;!-- lang: cpp --&gt;// Assignment operators always have spaces around them.x = 0;// Other binary operators usually have spaces around them, but it&apos;s// OK to remove spaces around factors.  Parentheses should have no// internal padding.v = w * x + y / z;v = w*x + y/z;v = w * (x + z);// No spaces separating unary operators and their arguments.x = -5;++x;if (x &amp;&amp; !y)  ...</code></pre><p>模板和类型转换，</p><pre><code>&lt;!-- lang: cpp --&gt;// No spaces inside the angle brackets (&lt; and &gt;), before// &lt;, or between &gt;( in a castvector&lt;string&gt; x;y = static_cast&lt;char*&gt;(x);// Spaces between type and pointer are OK, but be consistent.vector&lt;char *&gt; x;set&lt;list&lt;string&gt;&gt; x;        // Permitted in C++11 code.set&lt;list&lt;string&gt; &gt; x;       // C++03 required a space in &gt; &gt;.// You may optionally use symmetric spacing in &lt; &lt;.set&lt; list&lt;string&gt; &gt; x;</code></pre><h2 id="纵向空格"><a href="#纵向空格" class="headerlink" title="纵向空格"></a>纵向空格</h2><p>使纵向空格最小化。</p><p>当你没必要时，不要留很多空行。特别的，在函数间不要留超过一行或两行的空白。</p><p>函数开始不要有空行，函数结束也不要有空行。</p><p>基本原则：一个屏幕上有越多的代码，就越容易理解程序的控制流程。当然，可读性也很重要。</p><h1 id="以上规则的例外情况"><a href="#以上规则的例外情况" class="headerlink" title="以上规则的例外情况"></a>以上规则的例外情况</h1><h2 id="现存的不一致代码"><a href="#现存的不一致代码" class="headerlink" title="现存的不一致代码"></a>现存的不一致代码</h2><p>你可能会在不符合本规则的代码上工作，为了保持一致性，你不应该生搬硬套这个规则。</p><h2 id="Windows代码"><a href="#Windows代码" class="headerlink" title="Windows代码"></a>Windows代码</h2><ul><li>不要使用匈牙利命名法，例如 iNum。使用上面介绍的命名规则。</li><li>Windows定义了许多自己的类型，如DWORD，HANDLE等等。即便这样，你也应该使用你熟知的C++类型，例如：const TCHAR * 来代替LPCTSTR。</li><li>当使用Microsoft Visual C++编译时，将编译器设置3或以上的警告等级，并把所有警告视为错误。</li><li>不要使用#pragma once。使用第一个介绍的头文件保护策略。</li><li>实际上，不要使用任何非标准的扩展指令，像#pragma和<strong>declspec，除非你必须使用。允许使用</strong>declspec(dllimport) 和 __declspec(dllexport)。当然，你必须通过DLLIMPORT和DLLEXPORT宏来间接使用它们。</li></ul><p>上面的一些规则在Windows上不适用：</p><ul><li>禁止多重实现继承。在使用COM和一些ATL/WTL类时，多重继承是必要的。</li><li>不使用exception。在ATL和一些Visual C++的STL中使用了exception。使用ATL时，你应该定义_ATL_NO_EXCEPTIONS来禁用异常。</li><li>使用预编译头文件的一贯方法是包含StdAfx.h或者precompile.h。你应该避免手动包含预编译头文件，使用/FI编译器选项来自动包含这个文件。</li><li>资源头文件resource.h，仅包含宏，不需要套用本规则。</li></ul><h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><p>符合常识以及保持一致性。</p><p>在编辑代码之前，花几分钟看看当前代码的编码风格。并与之保持一致的风格。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;英文原版: &lt;a href=&quot;http://google-styleguide.googlecode.com/svn/trunk/cppguide.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://google-styleguide.g
      
    
    </summary>
    
    
      <category term="tech" scheme="https://apporz.com/tags/tech/"/>
    
      <category term="cpp" scheme="https://apporz.com/tags/cpp/"/>
    
  </entry>
  
</feed>
